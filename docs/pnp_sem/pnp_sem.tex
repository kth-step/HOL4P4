\documentclass[UTF8]{article}
%\documentclass[a4paper,11pt,reqno]{amsart}

\pagestyle{headings}
\usepackage{graphicx}
\usepackage[english]{babel}
\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}
\usepackage{verbatim}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{pstricks}
\usepackage{mathrsfs}
\usepackage{textcomp}
\usepackage{tikz}
\usepackage{subfig}
\usepackage{fancyvrb}

\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=cyan,
}

\usepackage{csquotes}
\usepackage[backend=biber]{biblatex}
\usepackage{todonotes}

\usepackage{supertabular}
\usepackage{geometry}
\usepackage{ifthen}
\usepackage{alltt}%hack

\include{p4_parser_defs}

\addbibresource{p4.bib}
\newtheorem{thm}{Theorem}
\newtheorem{lemma}{Lemma}

\title{%
Pen-and-paper semantics for P4}
\author{Anoud Alshnakat\\
Didrik Lundberg
}
\date{\today}
\begin{document}
\maketitle
\noindent
This is a pen-and-paper semantics of P4, inspired by Core P4~\cite{doenges2021petr4}.

%\newpage
\section{Syntax}
\subsection{Types and Typing Rules}

Base types (integers, booleans, bit strings, errors, headers...), function types (superset of base types also including tables, functions and constructors) and directions (in, out, inout), are currently TODO.

\begin{figure}[h!]
\centering
TODO
\caption{P4 Types}
\end{figure}

\begin{figure}[h!]
\centering
TODO
\caption{P4 Typing Rules}
\end{figure}

\newpage
\subsection{Expressions}

Let $b$ be a Boolean value and $\mathit{bs} = [b_1 , \ldots , b_n]$ a bitstring. As shown in Figure~\ref{fig:exp}, an expression is either the parser input ($\mathbf{In}$, a bitstring), or the parser output ($\mathbf{Out}$, a map from field names $f$ (strings) to bitstrings - supposed to represent a record), a comparison between two expressions, or a constant bitstring. Note that this means we have currently ignored most unary and binary expressions, keeping only the equality comparison.

Note also that $\mathbf{In}$ and $\mathbf{Out}$ are hard-coded in the sense that they will syntactically be part of the execution state, which is introduced later on. More generally you might have something like just a variable environment, where the variable names $\mathbf{In}$ and $\mathbf{Out}$ map to their respective values.

{\color{red} NOTE: $\mathbf{In}$ and $\mathbf{Out}$ could be renamed with a prefix ``Pars'' or similar, to distinguish them from direction types.}

\begin{figure}[h!]
\centering\ottgrammartabular{
\ottexp\ottafterlastrule
}
\caption{P4 Expressions}
\label{fig:exp}
\end{figure}

\newpage
\subsection{Statements}
\newcommand{\bstmt}{\textit{bstmt}}
\newcommand{\estmt}{\textit{estmt}}
\newcommand{\transition}[1]{$\textbf{transition} \, {#1}$}
\newcommand{\start}{\textbf{start}}
\newcommand{\accept}{\textbf{accept}}
\newcommand{\reject}[1]{$\textbf{reject} \, {#1}$}
%TODO hyperlinks to P4 specification
P4 statements currently include basic statements \bstmt{} and ending statements \estmt{}, as shown in Figure~\ref{fig:stmt}. Basic statements can be found in the body of a parser state, and ending statements are uniquely found at the end of a parser state.

Basic statements are sequenced using semicoli. \href{https://p4.org/p4-spec/docs/P4-16-v1.2.1.html#sec-packet-data-extraction}{\textbf{extract}} extracts a prefix substring from the input bitstring $\mathbf{In}$, and puts this in the field $f$ of the output map $\mathbf{Out}$. It is a function defined on the pre-defined P4 extern object \texttt{packet\_in} found in the \texttt{core.p4} library, but is here treated as a statement.  Currently, only the version for extracting fixed-size headers is modeled.

\href{https://p4.org/p4-spec/docs/P4-16-v1.2.1.html#sec-verify}{\textbf{verify}} is more like an actual statement in the sense that it behaves like an extern function which can only be used inside the parser. It evaluates the expression $\textit{exp}$ and does nothing if it evaluates to true, otherwise it will transition to the final parser state \reject{m}, where $m$ is the provided error message.

\begin{figure}[h!]
\centering\ottgrammartabular{
\ottbstmt\ottinterrule
\ottestmt\ottafterlastrule
}
\caption{P4 Statements}
\label{fig:stmt}
\end{figure}

The only ending statement is \href{https://p4.org/p4-spec/docs/P4-16-v1.2.1.html#sec-transition}{\transition{pst\_id}}, which continues execution in the parser state with ID $\textit{pst\_id}$,  unless this is \accept{} or \reject{m}, in which case the parsing is finished. Note that the syntax and semantics of this statement is more complex in actual P4, where a \textbf{select} expression can choose to transition to different state IDs.

\newpage
\subsection{Parser}
A \href{https://p4.org/p4-spec/docs/P4-16-v1.2.1.html#sec-packet-parsing}{P4 parser} can be thought of as a state machine with three hard-coded states: \start{} (the initial state), \accept{} (the accepting state), and \reject{m} (the rejecting state, here coupled with an error message $m$). Additional states are given concrete names.

Here, a $\mathit{parser}$ is shown in Figure~\ref{fig:parser} and consists of a map from names (a subtype of parser state ID) to tuples of $\mathit{bstmt}$ and $\mathit{estmt}$. The parser state IDs are shown in Figure~\ref{fig:pst_id}.

{\color{red} NOTE: \start{} also needs to map to some statements, whereas \accept{} and \reject{m} do not.}

\begin{figure}[h!]
\centering\ottgrammartabular{
\ottparser\ottafterlastrule
}
\caption{P4 Parser}
\label{fig:parser}
\end{figure}

\begin{figure}[h!]
\centering\ottgrammartabular{
\ottpstXXid\ottafterlastrule
}
\caption{P4 Parser State IDs}
\label{fig:pst_id}
\end{figure}

\newpage
\newcommand{\state}{\textit{state}}
\subsection{Execution State}
The execution state \state{} holds a parser state ID $\textit{pst\_id}$, the parser input $\textit{inp}$ (a bitstring), the parser output $\textit{out}$ (a map from field names (strings) to bitstrings) and the execution status $\textit{status}$.

\textbf{Running} represents that the parser is executing under regular circumstances. \textbf{TypeError} represents a crash caused by some badly-typed part of the program and \textbf{JumpOutside} is a crash caused by jumping to an undefined parser state. \accept{} and \reject{m} might not be needed in the final treatment, but represents regular termination of the parser by acceptance or rejection.

\begin{figure}[h!]
\centering\ottgrammartabular{
\ottstatus\ottinterrule
\ottstate\ottafterlastrule
}
\caption{P4 Execution State}
\label{fig:status}
\end{figure}


\section{Semantics}
\subsection{Expressions}
\begin{figure}[h!]
\centering\ottgrammartabular{
\ottpFourXXparserXXexpXXred\ottafterlastrule
}
\caption{Judgment Forms of P4 Expression Evaluation}
\label{fig:judgexp}
\end{figure}

\begin{figure}[h!]
\centering\ottdefnspFourXXparserXXexpXXred
\caption{P4 Expression Evaluation Semantics}
\label{fig:semexp}
\end{figure}

\newpage
\subsection{Parser Execution}
\begin{figure}[h!]
\centering\ottgrammartabular{
\ottpFourXXparserXXbstmtXXred\ottinterrule
\ottpFourXXparserXXblockXXred\ottinterrule
\ottpFourXXparserXXnblockXXred\ottafterlastrule
}
\caption{Judgment Forms of P4 Parser Execution}
\label{fig:judgexec}
\end{figure}

\begin{figure}[h!]
\ottdefnspFourXXparserXXbstmtXXred
\caption{P4 Statement Execution Semantics}
\label{fig:semstmtexec}
\end{figure}

\begin{figure}[h!]
\ottdefnspFourXXparserXXstrXXstmtXXred
\caption{P4 Structural Statement Execution Semantics}
\label{fig:semstmtexec}
\end{figure}

\begin{figure}[h!]
\ottdefnspFourXXparserXXblockXXred
\caption{P4 Parser State Execution Semantics}
\label{fig:semblockexec}
\end{figure}

\begin{figure}[h!]
\ottdefnspFourXXparserXXnblockXXred
\caption{P4 $n$-Parser State Execution Semantics}
\label{fig:semnblockexec}
\end{figure}

\printbibliography
\end{document}


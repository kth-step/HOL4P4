% generated by Ott 0.31 from: ott/p4.ott
\newcommand{\ottdrule}[4][]{{\displaystyle\frac{\begin{array}{l}#2\end{array}}{#3}\quad\ottdrulename{#4}}}
\newcommand{\ottusedrule}[1]{\[#1\]}
\newcommand{\ottpremise}[1]{ #1 \\}
\newenvironment{ottdefnblock}[3][]{ \framebox{\mbox{#2}} \quad #3 \\[0pt]}{}
\newenvironment{ottfundefnblock}[3][]{ \framebox{\mbox{#2}} \quad #3 \\[0pt]\begin{displaymath}\begin{array}{l}}{\end{array}\end{displaymath}}
\newcommand{\ottfunclause}[2]{ #1 \equiv #2 \\}
\newcommand{\ottnt}[1]{\mathit{#1}}
\newcommand{\ottmv}[1]{\mathit{#1}}
\newcommand{\ottkw}[1]{\mathbf{#1}}
\newcommand{\ottsym}[1]{#1}
\newcommand{\ottcom}[1]{\text{#1}}
\newcommand{\ottdrulename}[1]{\textsc{#1}}
\newcommand{\ottcomplu}[5]{\overline{#1}^{\,#2\in #3 #4 #5}}
\newcommand{\ottcompu}[3]{\overline{#1}^{\,#2<#3}}
\newcommand{\ottcomp}[2]{\overline{#1}^{\,#2}}
\newcommand{\ottgrammartabular}[1]{\begin{supertabular}{llcllllll}#1\end{supertabular}}
\newcommand{\ottmetavartabular}[1]{\begin{supertabular}{ll}#1\end{supertabular}}
\newcommand{\ottrulehead}[3]{$#1$ & & $#2$ & & & \multicolumn{2}{l}{#3}}
\newcommand{\ottprodline}[6]{& & $#1$ & $#2$ & $#3 #4$ & $#5$ & $#6$}
\newcommand{\ottfirstprodline}[6]{\ottprodline{#1}{#2}{#3}{#4}{#5}{#6}}
\newcommand{\ottlongprodline}[2]{& & $#1$ & \multicolumn{4}{l}{$#2$}}
\newcommand{\ottfirstlongprodline}[2]{\ottlongprodline{#1}{#2}}
\newcommand{\ottbindspecprodline}[6]{\ottprodline{#1}{#2}{#3}{#4}{#5}{#6}}
\newcommand{\ottprodnewline}{\\}
\newcommand{\ottinterrule}{\\[5.0mm]}
\newcommand{\ottafterlastrule}{\\}
\newcommand{\ottmetavars}{
\ottmetavartabular{
 $ x ,\, f ,\, a ,\, table\_name $ & \ottcom{string} \\
 $ b $ & \ottcom{boolean} \\
 $ bl $ & \ottcom{bit-string} \\
 $ i $ & \ottcom{natural number} \\
 $ \ottmv{m} ,\, \ottmv{n} ,\, \ottmv{o} $ & \ottcom{indices} \\
}}

\newcommand{\ottboolv}{
\ottrulehead{\ottnt{boolv}}{::=}{\ottcom{boolean}}\ottprodnewline
\ottfirstprodline{|}{\ottkw{true}} {\textsf{M}}{}{}{}\ottprodnewline
\ottprodline{|}{\ottkw{false}} {\textsf{M}}{}{}{}\ottprodnewline
\ottprodline{|}{b} {\textsf{M}}{}{}{}}

\newcommand{\ottbitv}{
\ottrulehead{\ottnt{bitv}}{::=}{\ottcom{bit-string}}\ottprodnewline
\ottfirstprodline{|}{bl \, \ottmv{n}} {\textsf{M}}{}{}{}}

\newcommand{\ottpacketXXin}{
\ottrulehead{\ottnt{packet\_in}}{::=}{\ottcom{input packet}}\ottprodnewline
\ottfirstprodline{|}{\ottsym{[}  \ottnt{boolv_{{\mathrm{1}}}}  \ottsym{,} \, .. \, \ottsym{,}  \ottnt{boolv_{\ottmv{n}}}  \ottsym{]}} {\textsf{M}}{}{}{}}

\newcommand{\ottpacketXXout}{
\ottrulehead{\ottnt{packet\_out}}{::=}{\ottcom{output packet}}\ottprodnewline
\ottfirstprodline{|}{\ottsym{[}  \ottnt{boolv_{{\mathrm{1}}}}  \ottsym{,} \, .. \, \ottsym{,}  \ottnt{boolv_{\ottmv{n}}}  \ottsym{]}} {\textsf{M}}{}{}{}}

\newcommand{\ottipvFourXXchecksum}{
\ottrulehead{\ottnt{ipv4\_checksum}}{::=}{\ottcom{ipv4 header checksum}}}

\newcommand{\ottextXXobj}{
\ottrulehead{\ottnt{ext\_obj}}{::=}{\ottcom{extern object}}\ottprodnewline
\ottfirstprodline{|}{\ottnt{packet\_in}}{}{}{}{\ottcom{input packet}}\ottprodnewline
\ottprodline{|}{\ottnt{packet\_out}}{}{}{}{\ottcom{input packet}}\ottprodnewline
\ottprodline{|}{\ottnt{ipv4\_checksum}}{}{}{}{\ottcom{ipv4 header checksum}}}

\newcommand{\ottv}{
\ottrulehead{\ottnt{v}}{::=}{\ottcom{constant}}\ottprodnewline
\ottfirstprodline{|}{\ottnt{boolv}}{}{}{}{\ottcom{boolean value}}\ottprodnewline
\ottprodline{|}{\ottnt{bitv}}{}{}{}{\ottcom{bit-string}}\ottprodnewline
\ottprodline{|}{x}{}{}{}{\ottcom{string literal}}\ottprodnewline
\ottprodline{|}{\ottkw{struct} \, \ottsym{\{}  x_{{\mathrm{1}}}  \ottsym{=}  \ottnt{v_{{\mathrm{1}}}}  \ottsym{;} \, ... \, \ottsym{;}  x_{\ottmv{n}}  \ottsym{=}  \ottnt{v_{\ottmv{n}}}  \ottsym{\}}}{}{}{}{\ottcom{struct}}\ottprodnewline
\ottprodline{|}{\ottkw{header} \, \ottnt{boolv}  \ottsym{\{}  x_{{\mathrm{1}}}  \ottsym{=}  \ottnt{v_{{\mathrm{1}}}}  \ottsym{;} \, ... \, \ottsym{;}  x_{\ottmv{n}}  \ottsym{=}  \ottnt{v_{\ottmv{n}}}  \ottsym{\}}}{}{}{}{\ottcom{header}}\ottprodnewline
\ottprodline{|}{\ottnt{ext\_obj}}{}{}{}{\ottcom{extern object}}\ottprodnewline
\ottprodline{|}{\ottkw{errmsg} \, x}{}{}{}{\ottcom{error message}}\ottprodnewline
\ottprodline{|}{ ? }{}{}{}{\ottcom{uninitialized value}}\ottprodnewline
\ottprodline{|}{\ottkw{bot}}{}{}{}{\ottcom{no value}}}

\newcommand{\ottlval}{
\ottrulehead{\ottnt{lval}}{::=}{}\ottprodnewline
\ottfirstprodline{|}{x}{}{}{}{\ottcom{variable name}}\ottprodnewline
\ottprodline{|}{\ottkw{null}}{}{}{}{\ottcom{null variable}}\ottprodnewline
\ottprodline{|}{\ottnt{lval}  \ottsym{.}  f}{}{}{}{\ottcom{field access}}\ottprodnewline
\ottprodline{|}{\ottsym{(}  \ottnt{lval}  \ottsym{)}}{}{}{}{}}

\newcommand{\ottparsXXfin}{
\ottrulehead{p_{ \mathrm{fin} }}{::=}{\ottcom{final parser states}}\ottprodnewline
\ottfirstprodline{|}{\ottkw{Accept}}{}{}{}{\ottcom{accepted state}}\ottprodnewline
\ottprodline{|}{\ottkw{Reject}}{}{}{}{\ottcom{rejected state}}}

\newcommand{\ottparsXXnext}{
\ottrulehead{p}{::=}{\ottcom{parser next state}}\ottprodnewline
\ottfirstprodline{|}{\ottkw{Trans} \, x}{}{}{}{\ottcom{transition to named state}}\ottprodnewline
\ottprodline{|}{p_{ \mathrm{fin} }}{}{}{}{\ottcom{final state}}}

\newcommand{\ottstatus}{
\ottrulehead{t}{::=}{\ottcom{execution status}}\ottprodnewline
\ottfirstprodline{|}{ { \mathbf{R} } }{}{}{}{}\ottprodnewline
\ottprodline{|}{p}{}{}{}{}\ottprodnewline
\ottprodline{|}{ { \bot } }{}{}{}{}}

\newcommand{\ottscope}{
\ottrulehead{\gamma}{::=}{\ottcom{frame/variable environment of current scope}}\ottprodnewline
\ottfirstprodline{|}{ {\gamma}_{ \emptyset } } {\textsf{M}}{}{}{\ottcom{empty stack frame}}\ottprodnewline
\ottprodline{|}{ ( x  \mapsto   \ottnt{v} )  \gamma } {\textsf{M}}{}{}{\ottcom{update variable mapping}}\ottprodnewline
\ottprodline{|}{ \forall i \leq n. \,\, (x_i \mapsto  \mathit{v}_i) \,\,  \gamma } {\textsf{M}}{}{}{\ottcom{update variable mapping}}\ottprodnewline
\ottprodline{|}{\ottsym{(}  \gamma  \ottsym{)}} {\textsf{S}}{}{}{}\ottprodnewline
\ottprodline{|}{ { \gamma }_G } {\textsf{M}}{}{}{\ottcom{global scope}}}

\newcommand{\ottcurrXXstackXXframe}{
\ottrulehead{\varepsilon}{::=}{\ottcom{current stack frame - stack of block scopes}}\ottprodnewline
\ottfirstprodline{|}{ {\emptyset}_{\varepsilon} } {\textsf{M}}{}{}{}\ottprodnewline
\ottprodline{|}{\ottsym{[}  \gamma_{{\mathrm{1}}}  \ottsym{,} \, .. \, \ottsym{,}  \gamma_{\ottmv{n}}  \ottsym{]}} {\textsf{M}}{}{}{}\ottprodnewline
\ottprodline{|}{ \mathrm{tl} ( \varepsilon ) } {\textsf{M}}{}{}{}\ottprodnewline
\ottprodline{|}{ \gamma  ::  \varepsilon' } {\textsf{M}}{}{}{}\ottprodnewline
\ottprodline{|}{ \varepsilon  \mathrel{\mathop+}+  \varepsilon' } {\textsf{M}}{}{}{}\ottprodnewline
\ottprodline{|}{ \mathrm{rev} ( \varepsilon ) } {\textsf{M}}{}{}{}\ottprodnewline
\ottprodline{|}{ ( i  \mapsto  \gamma )  \varepsilon } {\textsf{M}}{}{}{\ottcom{update a scope in the stack frame}}\ottprodnewline
\ottprodline{|}{\ottsym{(}  \varepsilon  \ottsym{)}} {\textsf{S}}{}{}{}}

\newcommand{\ottcalledXXfunctionXXname}{
\ottrulehead{F_n}{::=}{\ottcom{called function name}}\ottprodnewline
\ottfirstprodline{|}{ \bot }{}{}{}{}\ottprodnewline
\ottprodline{|}{ f }{}{}{}{}}

\newcommand{\ottcallXXstack}{
\ottrulehead{E}{::=}{\ottcom{stack of caller stack frames}}\ottprodnewline
\ottfirstprodline{|}{ {\emptyset}_{E} } {\textsf{M}}{}{}{}\ottprodnewline
\ottprodline{|}{\ottsym{[}  \ottsym{(}  \varepsilon_{{\mathrm{1}}}  \ottsym{,}  F_n_{{\mathrm{1}}}  \ottsym{)}  \ottsym{,} \, .. \, \ottsym{,}  \ottsym{(}  \varepsilon_{\ottmv{n}}  \ottsym{,}  F_n_{\ottmv{n}}  \ottsym{)}  \ottsym{]}} {\textsf{M}}{}{}{}\ottprodnewline
\ottprodline{|}{ ( \varepsilon ,  F_n ) ::  E } {\textsf{M}}{}{}{}\ottprodnewline
\ottprodline{|}{\ottsym{(}  E  \ottsym{)}} {\textsf{S}}{}{}{}}

\newcommand{\ottstacks}{
\ottrulehead{\sigma}{::=}{\ottcom{stacks in execution state}}\ottprodnewline
\ottfirstprodline{|}{\ottsym{(}  \varepsilon  \ottsym{,}  E  \ottsym{)}}{}{}{}{}}

\newcommand{\ottstate}{
\ottrulehead{s}{::=}{\ottcom{execution state}}\ottprodnewline
\ottfirstprodline{|}{\ottsym{(}  \sigma  \ottsym{,}  t  \ottsym{)}}{}{}{}{}}

\newcommand{\ottunop}{
\ottrulehead{\ominus}{::=}{}\ottprodnewline
\ottfirstprodline{|}{ ! }{}{}{}{\ottcom{negation}}\ottprodnewline
\ottprodline{|}{ \neg }{}{}{}{\ottcom{bitwise complement}}\ottprodnewline
\ottprodline{|}{\ottsym{-}}{}{}{}{\ottcom{signed negation}}\ottprodnewline
\ottprodline{|}{\ottsym{+}}{}{}{}{\ottcom{unary plus}}}

\newcommand{\ottbinop}{
\ottrulehead{\oplus}{::=}{}\ottprodnewline
\ottfirstprodline{|}{ \times }{}{}{}{\ottcom{multiplication}}\ottprodnewline
\ottprodline{|}{\ottsym{/}}{}{}{}{\ottcom{division}}\ottprodnewline
\ottprodline{|}{ \bmod }{}{}{}{\ottcom{modulo}}\ottprodnewline
\ottprodline{|}{\ottsym{+}}{}{}{}{\ottcom{addition}}\ottprodnewline
\ottprodline{|}{\ottsym{-}}{}{}{}{\ottcom{subtraction}}\ottprodnewline
\ottprodline{|}{ \ll }{}{}{}{\ottcom{logical left-shift}}\ottprodnewline
\ottprodline{|}{ \gg }{}{}{}{\ottcom{logical right-shift}}\ottprodnewline
\ottprodline{|}{ \leq }{}{}{}{\ottcom{less or equal}}\ottprodnewline
\ottprodline{|}{ \geq }{}{}{}{\ottcom{greater or equal}}\ottprodnewline
\ottprodline{|}{ < }{}{}{}{\ottcom{less}}\ottprodnewline
\ottprodline{|}{ > }{}{}{}{\ottcom{greater}}\ottprodnewline
\ottprodline{|}{ \neq }{}{}{}{\ottcom{not equal}}\ottprodnewline
\ottprodline{|}{ = }{}{}{}{\ottcom{equal}}\ottprodnewline
\ottprodline{|}{\ottsym{\&}}{}{}{}{\ottcom{bitwise and}}\ottprodnewline
\ottprodline{|}{ \underline{\vee} }{}{}{}{\ottcom{bitwise xor}}\ottprodnewline
\ottprodline{|}{ \mid }{}{}{}{\ottcom{bitwise or}}\ottprodnewline
\ottprodline{|}{ \land }{}{}{}{\ottcom{binary and}}\ottprodnewline
\ottprodline{|}{ \lor }{}{}{}{\ottcom{binary or}}}

\newcommand{\ottext}{
\ottrulehead{{ \mathit{ext} }}{::=}{}}

\newcommand{\otte}{
\ottrulehead{\ottnt{e}}{::=}{\ottcom{expression}}\ottprodnewline
\ottfirstprodline{|}{\ottnt{v}}{}{}{}{\ottcom{constant value}}\ottprodnewline
\ottprodline{|}{\ottkw{var} \, x}{}{}{}{\ottcom{variable or extern object}}\ottprodnewline
\ottprodline{|}{\ottsym{\{}  \ottnt{e_{{\mathrm{1}}}}  \ottsym{,} \, .. \, \ottsym{,}  \ottnt{e_{\ottmv{n}}}  \ottsym{\}}}{}{}{}{\ottcom{expression list}}\ottprodnewline
\ottprodline{|}{\ottnt{e}  \ottsym{.}  \ottnt{e'}}{}{}{}{\ottcom{field access}}\ottprodnewline
\ottprodline{|}{ \ominus   \ottnt{e} }{}{}{}{\ottcom{unary operation}}\ottprodnewline
\ottprodline{|}{ \ottnt{e_{{\mathrm{1}}}}   \oplus   \ottnt{e_{{\mathrm{2}}}} }{}{}{}{\ottcom{binary operation}}\ottprodnewline
\ottprodline{|}{\ottnt{e_{{\mathrm{1}}}}  \ottsym{++}  \ottnt{e_{{\mathrm{2}}}}}{}{}{}{\ottcom{concatenation of bit-strings}}\ottprodnewline
\ottprodline{|}{\ottnt{e_{{\mathrm{1}}}}  \ottsym{[}  \ottnt{e_{{\mathrm{2}}}}  \ottsym{:}  \ottnt{e_{{\mathrm{3}}}}  \ottsym{]}}{}{}{}{\ottcom{bit-slice}}\ottprodnewline
\ottprodline{|}{\ottkw{call} \, f  \ottsym{(}  \ottnt{e_{{\mathrm{1}}}}  \ottsym{,} \, .. \, \ottsym{,}  \ottnt{e_{\ottmv{n}}}  \ottsym{)}}{}{}{}{\ottcom{function call}}\ottprodnewline
\ottprodline{|}{\ottkw{exec} \, \ottnt{stmt}}{}{}{}{\ottcom{function execution}}\ottprodnewline
\ottprodline{|}{\ottkw{call} \, x \, f  \ottsym{(}  \ottnt{e_{{\mathrm{1}}}}  \ottsym{,} \, .. \, \ottsym{,}  \ottnt{e_{\ottmv{n}}}  \ottsym{)}}{}{}{}{\ottcom{extern method call}}\ottprodnewline
\ottprodline{|}{\ottkw{select} \, \ottnt{e}  \ottsym{\{}  \ottnt{v_{{\mathrm{1}}}}  \ottsym{:}  x_{{\mathrm{1}}}  \ottsym{;} \, ... \, \ottsym{;}  \ottnt{v_{\ottmv{n}}}  \ottsym{:}  x_{\ottmv{n}}  \ottsym{\}}  x}{}{}{}{\ottcom{select}}\ottprodnewline
\ottprodline{|}{\ottsym{(}  \ottnt{e}  \ottsym{)}} {\textsf{S}}{}{}{}}

\newcommand{\otteXXlist}{
\ottrulehead{\ottnt{e\_list}}{::=}{\ottcom{list of expressions}}\ottprodnewline
\ottfirstprodline{|}{\ottkw{empty\_el}} {\textsf{M}}{}{}{\ottcom{empty expression list}}\ottprodnewline
\ottprodline{|}{\ottnt{e_{{\mathrm{1}}}}  \ottsym{,} \, .. \, \ottsym{,}  \ottnt{e_{\ottmv{n}}}} {\textsf{M}}{}{}{\ottcom{list of expressions}}\ottprodnewline
\ottprodline{|}{\ottnt{e}  \ottsym{::}  \ottnt{e\_list}} {\textsf{M}}{}{}{\ottcom{cons}}\ottprodnewline
\ottprodline{|}{\ottkw{tl} \, \ottnt{e\_list}} {\textsf{M}}{}{}{\ottcom{tail}}\ottprodnewline
\ottprodline{|}{\ottsym{[}  \ottnt{e_{{\mathrm{1}}}}  \ottsym{,} \, .. \, \ottsym{,}  \ottnt{e_{\ottmv{n}}}  \ottsym{]}} {\textsf{M}}{}{}{\ottcom{bracketed list of expressions}}\ottprodnewline
\ottprodline{|}{\ottnt{e\_list}  \ottsym{++}  \ottnt{e\_list'}} {\textsf{M}}{}{}{\ottcom{append two expression lists}}\ottprodnewline
\ottprodline{|}{ ( i  \mapsto   \ottnt{e} )  \ottnt{e\_list} } {\textsf{M}}{}{}{\ottcom{update entry of expression list}}\ottprodnewline
\ottprodline{|}{\ottsym{(}  \ottnt{e\_list}  \ottsym{)}} {\textsf{S}}{}{}{}}

\newcommand{\ottmatchXXkind}{
\ottrulehead{\mathit{match\_kind}}{::=}{\ottcom{matching kinds}}\ottprodnewline
\ottfirstprodline{|}{ exact }{}{}{}{}\ottprodnewline
\ottprodline{|}{ ternary }{}{}{}{}\ottprodnewline
\ottprodline{|}{ lpm }{}{}{}{}}

\newcommand{\ottbt}{
\ottrulehead{bt}{::=}{\ottcom{base types}}\ottprodnewline
\ottfirstprodline{|}{ { \mathrm{bool}_{ \mathrm{t} } } }{}{}{}{}\ottprodnewline
\ottprodline{|}{ { \mathrm{bit}_{ \mathrm{t} } } }{}{}{}{}}

\newcommand{\ottt}{
\ottrulehead{t}{::=}{\ottcom{types}}\ottprodnewline
\ottfirstprodline{|}{bt}{}{}{}{}\ottprodnewline
\ottprodline{|}{ { \mathrm{struct}_{ \mathrm{t} }\,\, t_1 , \ldots , t_n } }{}{}{}{}\ottprodnewline
\ottprodline{|}{ { \mathrm{header}_{ \mathrm{t} }\,\, t_1 , \ldots , t_n } }{}{}{}{}}

\newcommand{\ottstmt}{
\ottrulehead{\ottnt{stmt}}{::=}{\ottcom{statement}}\ottprodnewline
\ottfirstprodline{|}{ \emptyset_{ \mathrm{stmt} } }{}{}{}{\ottcom{empty statement}}\ottprodnewline
\ottprodline{|}{ \ottnt{lval}  \mathrel{\mathop:}=  \ottnt{e} }{}{}{}{\ottcom{assignment}}\ottprodnewline
\ottprodline{|}{\ottkw{if} \, \ottnt{e} \, \ottkw{then} \, \ottnt{stmt_{{\mathrm{1}}}} \, \ottkw{else} \, \ottnt{stmt_{{\mathrm{2}}}}}{}{}{}{\ottcom{conditional}}\ottprodnewline
\ottprodline{|}{\ottkw{decl} \, x \, t}{}{}{}{\ottcom{declaration}}\ottprodnewline
\ottprodline{|}{ \{  \ottnt{stmt}  \} }{}{}{}{\ottcom{block}}\ottprodnewline
\ottprodline{|}{ [  \ottnt{stmt}  ] }{}{}{}{\ottcom{block in progress}}\ottprodnewline
\ottprodline{|}{\ottkw{return} \, \ottnt{e}}{}{}{}{\ottcom{return}}\ottprodnewline
\ottprodline{|}{\ottnt{stmt_{{\mathrm{1}}}}  \ottsym{;}  \ottnt{stmt_{{\mathrm{2}}}}}{}{}{}{\ottcom{sequence}}\ottprodnewline
\ottprodline{|}{\ottkw{verify} \, \ottnt{e} \, \ottnt{e'}}{}{}{}{\ottcom{verify}}\ottprodnewline
\ottprodline{|}{ \mathbf{transition}\,  \ottnt{e} }{}{}{}{\ottcom{transition}}\ottprodnewline
\ottprodline{|}{ \mathbf{apply} \,  table\_name  \,  \ottnt{e} }{}{}{}{\ottcom{apply}}}

\newcommand{\ottd}{
\ottrulehead{d}{::=}{\ottcom{parameter direction}}\ottprodnewline
\ottfirstprodline{|}{ \downarrow }{}{}{}{}\ottprodnewline
\ottprodline{|}{ \uparrow }{}{}{}{}\ottprodnewline
\ottprodline{|}{ \updownarrow }{}{}{}{}\ottprodnewline
\ottprodline{|}{ \circ }{}{}{}{}}

\newcommand{\ottdXXlist}{
\ottrulehead{\ottnt{d\_list}}{::=}{\ottcom{list of directions}}\ottprodnewline
\ottfirstprodline{|}{\ottkw{empty\_el}} {\textsf{M}}{}{}{\ottcom{empty direction list}}\ottprodnewline
\ottprodline{|}{\ottsym{[}  d_{{\mathrm{1}}}  \ottsym{,} \, .. \, \ottsym{,}  d_{\ottmv{n}}  \ottsym{]}} {\textsf{M}}{}{}{\ottcom{list of directions}}\ottprodnewline
\ottprodline{|}{\ottsym{(}  \ottnt{d\_list}  \ottsym{)}} {\textsf{S}}{}{}{}\ottprodnewline
\ottprodline{|}{\ottnt{d\_list}  \ottsym{++}  \ottnt{d\_list'}} {\textsf{M}}{}{}{\ottcom{append two e_lists}}}

\newcommand{\ottfuncXXmap}{
\ottrulehead{F}{::=}{\ottcom{function map}}\ottprodnewline
\ottfirstprodline{|}{\ottkw{empty}} {\textsf{M}}{}{}{\ottcom{empty function map}}\ottprodnewline
\ottprodline{|}{F  \ottsym{+}  \ottsym{[}  x  \ottsym{\mbox{$\mid$}->}  \ottnt{stmt}  \ottsym{]}} {\textsf{M}}{}{}{\ottcom{update variable mapping}}}

\newcommand{\ottextXXmap}{
\ottrulehead{X}{::=}{\ottcom{extern method map}}}

\newcommand{\ottctrl}{
\ottrulehead{{ \mathrm{ctrl} }}{::=}{\ottcom{control plane}}\ottprodnewline
\ottfirstprodline{|}{\ottkw{empty}} {\textsf{M}}{}{}{\ottcom{empty table map}}}

\newcommand{\otttXXmap}{
\ottrulehead{{ \mathit{Tb} }}{::=}{\ottcom{table map}}\ottprodnewline
\ottfirstprodline{|}{\ottkw{empty}} {\textsf{M}}{}{}{\ottcom{empty table map}}}

\newcommand{\ottparsXXmap}{
\ottrulehead{P}{::=}{\ottcom{parser state map}}\ottprodnewline
\ottfirstprodline{|}{\ottkw{empty}} {\textsf{M}}{}{}{\ottcom{empty parser state map}}}

\newcommand{\otttypeXXmap}{
\ottrulehead{T}{::=}{\ottcom{type environment}}\ottprodnewline
\ottfirstprodline{|}{\ottkw{empty}} {\textsf{M}}{}{}{\ottcom{empty type environment}}}

\newcommand{\ottctx}{
\ottrulehead{\mathit{ctx}}{::=}{\ottcom{context}}\ottprodnewline
\ottfirstprodline{|}{\ottkw{empty}} {\textsf{M}}{}{}{\ottcom{empty context}}\ottprodnewline
\ottprodline{|}{\ottsym{(}  T  \ottsym{,}  X  \ottsym{,}  F  \ottsym{,}  P  \ottsym{,}  { \mathit{Tb} }  \ottsym{,}  { \mathrm{ctrl} }  \ottsym{)}} {\textsf{M}}{}{}{\ottcom{tuple}}}

\newcommand{\ottterminals}{
\ottrulehead{\ottnt{terminals}}{::=}{}\ottprodnewline
\ottfirstprodline{|}{ \rightarrow }{}{}{}{}\ottprodnewline
\ottprodline{|}{ \rightsquigarrow }{}{}{}{}\ottprodnewline
\ottprodline{|}{ \longrightarrow }{}{}{}{}}

\newcommand{\ottformula}{
\ottrulehead{\ottnt{formula}}{::=}{}\ottprodnewline
\ottfirstprodline{|}{\ottnt{judgement}}{}{}{}{\ottcom{judgement}}\ottprodnewline
\ottprodline{|}{\ottsym{!}  b  \ottsym{=}  b'} {\textsf{M}}{}{}{}\ottprodnewline
\ottprodline{|}{\ottsym{~}  \ottnt{bitv}  \ottsym{=}  \ottnt{bitv'}} {\textsf{M}}{}{}{}\ottprodnewline
\ottprodline{|}{\ottsym{-}  \ottnt{bitv}  \ottsym{=}  \ottnt{bitv'}} {\textsf{M}}{}{}{}\ottprodnewline
\ottprodline{|}{\ottsym{+}  \ottnt{bitv}  \ottsym{=}  \ottnt{bitv'}} {\textsf{M}}{}{}{}\ottprodnewline
\ottprodline{|}{\ottnt{bitv}  \ottsym{*}  \ottnt{bitv'}  \ottsym{=}  \ottnt{bitv''}} {\textsf{M}}{}{}{}\ottprodnewline
\ottprodline{|}{\ottnt{bitv}  \ottsym{/}  \ottnt{bitv'}  \ottsym{=}  \ottnt{bitv''}} {\textsf{M}}{}{}{}\ottprodnewline
\ottprodline{|}{\ottnt{bitv} \, \ottkw{mod} \, \ottnt{bitv'}  \ottsym{=}  \ottnt{bitv''}} {\textsf{M}}{}{}{}\ottprodnewline
\ottprodline{|}{\ottnt{bitv}  \ottsym{+}  \ottnt{bitv'}  \ottsym{=}  \ottnt{bitv''}} {\textsf{M}}{}{}{}\ottprodnewline
\ottprodline{|}{\ottnt{bitv}  \ottsym{-}  \ottnt{bitv'}  \ottsym{=}  \ottnt{bitv''}} {\textsf{M}}{}{}{}\ottprodnewline
\ottprodline{|}{\ottnt{bitv} \, \ottkw{EQ} \, \ottnt{bitv'}  \ottsym{=}  b} {\textsf{M}}{}{}{}\ottprodnewline
\ottprodline{|}{b \, \ottkw{EQ} \, b'  \ottsym{=}  b''} {\textsf{M}}{}{}{}\ottprodnewline
\ottprodline{|}{ ( x  =  x' ) =  b } {\textsf{M}}{}{}{\ottcom{equality over strings - used for errors}}\ottprodnewline
\ottprodline{|}{\ottnt{bitv} \, \ottkw{SHL} \, \ottnt{bitv'}  \ottsym{=}  \ottnt{bitv''}} {\textsf{M}}{}{}{}\ottprodnewline
\ottprodline{|}{\ottnt{bitv} \, \ottkw{SHR} \, \ottnt{bitv'}  \ottsym{=}  \ottnt{bitv''}} {\textsf{M}}{}{}{}\ottprodnewline
\ottprodline{|}{\ottnt{bitv} \, \ottkw{LE} \, \ottnt{bitv'}  \ottsym{=}  b} {\textsf{M}}{}{}{}\ottprodnewline
\ottprodline{|}{\ottnt{bitv} \, \ottkw{GE} \, \ottnt{bitv'}  \ottsym{=}  b} {\textsf{M}}{}{}{}\ottprodnewline
\ottprodline{|}{\ottnt{bitv}  \ottsym{<}  \ottnt{bitv'}  \ottsym{=}  b} {\textsf{M}}{}{}{}\ottprodnewline
\ottprodline{|}{\ottnt{bitv}  \ottsym{>}  \ottnt{bitv'}  \ottsym{=}  b} {\textsf{M}}{}{}{}\ottprodnewline
\ottprodline{|}{\ottnt{bitv} \, \ottkw{NE} \, \ottnt{bitv'}  \ottsym{=}  b} {\textsf{M}}{}{}{}\ottprodnewline
\ottprodline{|}{ ( x  \neq  x' ) =  b } {\textsf{M}}{}{}{\ottcom{inequality over strings - used for errors}}\ottprodnewline
\ottprodline{|}{b \, \ottkw{NE} \, b'  \ottsym{=}  b''} {\textsf{M}}{}{}{}\ottprodnewline
\ottprodline{|}{\ottnt{bitv}  \ottsym{\&}  \ottnt{bitv'}  \ottsym{=}  \ottnt{bitv''}} {\textsf{M}}{}{}{}\ottprodnewline
\ottprodline{|}{\ottnt{bitv}  \ottsym{\mbox{$\uparrow$}}  \ottnt{bitv'}  \ottsym{=}  \ottnt{bitv''}} {\textsf{M}}{}{}{}\ottprodnewline
\ottprodline{|}{\ottnt{bitv}  \ottsym{\mbox{$\mid$}}  \ottnt{bitv'}  \ottsym{=}  \ottnt{bitv''}} {\textsf{M}}{}{}{}\ottprodnewline
\ottprodline{|}{b \, \ottkw{AND} \, b'  \ottsym{=}  b''} {\textsf{M}}{}{}{}\ottprodnewline
\ottprodline{|}{b \, \ottkw{OR} \, b'  \ottsym{=}  b''} {\textsf{M}}{}{}{}\ottprodnewline
\ottprodline{|}{ \varepsilon  = \mathrm{hd}  E } {\textsf{M}}{}{}{}\ottprodnewline
\ottprodline{|}{\gamma  \ottsym{=}  \varepsilon  \ottsym{[}  i  \ottsym{]}} {\textsf{M}}{}{}{}\ottprodnewline
\ottprodline{|}{\ottsym{(}  \ottnt{stmt}  \ottsym{,}  \ottsym{(}  x_{{\mathrm{1}}}  \ottsym{,}  d_{{\mathrm{1}}}  \ottsym{)}  \ottsym{,} \, .. \, \ottsym{,}  \ottsym{(}  x_{\ottmv{n}}  \ottsym{,}  d_{\ottmv{n}}  \ottsym{)}  \ottsym{)}  \ottsym{=}  F  \ottsym{(}  f  \ottsym{)}} {\textsf{M}}{}{}{\ottcom{function signature lookup}}\ottprodnewline
\ottprodline{|}{ i = \mathrm{max} \, \{ j . \,\,  x   \in \mathrm{dom} (  \varepsilon  [j] )   \} } {\textsf{M}}{}{}{\ottcom{find max index of variable's scope}}\ottprodnewline
\ottprodline{|}{ i  = length ( \varepsilon ) } {\textsf{M}}{}{}{\ottcom{find the current stack frame length}}\ottprodnewline
\ottprodline{|}{ i  = length ( \varepsilon ) - 1 } {\textsf{M}}{}{}{\ottcom{find the current stack frame length minus 1}}\ottprodnewline
\ottprodline{|}{\ottnt{v}  \ottsym{=}  \gamma  \ottsym{(}  x  \ottsym{)}} {\textsf{M}}{}{}{\ottcom{look-up of variable in scope}}\ottprodnewline
\ottprodline{|}{\ottnt{v}  \ottsym{=} \, \ottkw{struct} \, \ottsym{\{}  x_{{\mathrm{1}}}  \ottsym{=}  \ottnt{v_{{\mathrm{1}}}}  \ottsym{;} \, ... \, \ottsym{;}  x_{\ottmv{n}}  \ottsym{=}  \ottnt{v_{\ottmv{n}}}  \ottsym{\}}  \ottsym{(}  x  \ottsym{)}} {\textsf{M}}{}{}{\ottcom{access of field in struct}}\ottprodnewline
\ottprodline{|}{\ottnt{v}  \ottsym{=} \, \ottkw{header} \, \ottnt{boolv}  \ottsym{\{}  x_{{\mathrm{1}}}  \ottsym{=}  \ottnt{v_{{\mathrm{1}}}}  \ottsym{;} \, ... \, \ottsym{;}  x_{\ottmv{n}}  \ottsym{=}  \ottnt{v_{\ottmv{n}}}  \ottsym{\}}  \ottsym{(}  x  \ottsym{)}} {\textsf{M}}{}{}{\ottcom{access of field in header}}\ottprodnewline
\ottprodline{|}{\ottnt{e}  \ottsym{=}  \ottnt{e\_list}  \ottsym{[}  i  \ottsym{]}} {\textsf{M}}{}{}{}\ottprodnewline
\ottprodline{|}{ \ottnt{e}  = \mathrm{hd} \,\,  \ottnt{e\_list} } {\textsf{M}}{}{}{}\ottprodnewline
\ottprodline{|}{ \ottnt{v}  = \mathrm{lookup_v} ( \varepsilon ,  x ) }{}{}{}{}\ottprodnewline
\ottprodline{|}{ ( \ottnt{v}  ,  a ) = \mathrm{lookup_tup} ( \varepsilon ,  x ) }{}{}{}{}\ottprodnewline
\ottprodline{|}{ x'  = \{ v_1 : x_1 ; ... ; v_n : x_n ; \_ : x \} (v) } {\textsf{M}}{}{}{\ottcom{access of string in select key-value list}}\ottprodnewline
\ottprodline{|}{ \ottnt{v}  \notin \mathrm{dom}(\{ v_1 : x_1 ; ... ; v_n : x_n \}) } {\textsf{M}}{}{}{\ottcom{default string in select key-value list}}\ottprodnewline
\ottprodline{|}{ \forall d ,\, e ,\, i \leqslant n. \, d =  \ottnt{d\_list}  [i] \, \land \, e =  \ottnt{e\_list}  [i] \, \implies  
         ((d \in \{\circ , \downarrow\} \implies \mathrm{is\_const} \, e ) \land (d \in \{\updownarrow , \uparrow\} \implies \mathrm{is\_var} \, e)) } {\textsf{M}}{}{}{\ottcom{check if arguments are isvar or isconst}}\ottprodnewline
\ottprodline{|}{ \forall d ,\, e ,\, i \leqslant n. \, d =  \ottnt{d\_list}  [i] \, \land \, e =  \ottnt{e\_list}  [i] \, \implies  
         \neg ((d \in \{\circ , \downarrow\} \implies \mathrm{is\_const} \, e ) \land (d \in \{\updownarrow , \uparrow\} \implies \mathrm{is\_var} \, e)) } {\textsf{M}}{}{}{\ottcom{check if arguments are not isvar or isconst}}\ottprodnewline
\ottprodline{|}{ d  =  \ottnt{d\_list}   i } {\textsf{M}}{}{}{}\ottprodnewline
\ottprodline{|}{ d  = \mathrm{hd} \,\,  \ottnt{d\_list} } {\textsf{M}}{}{}{}\ottprodnewline
\ottprodline{|}{ i = \mathrm{min} \, \{ j . \,\,  \ottnt{d\_list}  [j]  \in \{\circ , \downarrow\} \wedge \neg ( \mathrm{is\_const} \,  \ottnt{e\_list}  [j] ) \} } {\textsf{M}}{}{}{}\ottprodnewline
\ottprodline{|}{\gamma  \ottsym{=}  \gamma'} {\textsf{M}}{}{}{\ottcom{scope equality}}\ottprodnewline
\ottprodline{|}{\varepsilon  \ottsym{=}  \varepsilon'} {\textsf{M}}{}{}{\ottcom{curr_stack_frame equality}}\ottprodnewline
\ottprodline{|}{E  \ottsym{=}  E'} {\textsf{M}}{}{}{\ottcom{call_stack equality}}\ottprodnewline
\ottprodline{|}{ \ottnt{e\_list}  =  \ottnt{e\_list'} } {\textsf{M}}{}{}{\ottcom{args equality}}\ottprodnewline
\ottprodline{|}{ \mathrm{t\_map}\,  table\_name \, =\, (  \ottnt{e}  \, ,  \mathit{match\_kind}  ) }{}{}{}{\ottcom{find keys and the matching kind in the table map}}\ottprodnewline
\ottprodline{|}{ \mathrm{ctrl}\, (  table\_name  , \,  \ottnt{v} , \,  \mathit{match\_kind} \, ) = \,(  f  ,  \ottnt{e\_list}  ) }{}{}{}{\ottcom{fetch the function name and parameters from the ctrl plane}}\ottprodnewline
\ottprodline{|}{ i'  =  i  + 1 } {\textsf{M}}{}{}{\ottcom{numeral increment}}\ottprodnewline
\ottprodline{|}{ i  = \mathrm{len} \,\,  \ottnt{e\_list} } {\textsf{M}}{}{}{\ottcom{length of list}}\ottprodnewline
\ottprodline{|}{ i  < \mathrm{len}(\mathit{e}) } {\textsf{M}}{}{}{\ottcom{numeral in range}}\ottprodnewline
\ottprodline{|}{ \mathrm{is\_consts} \,\,  \ottnt{e\_list} } {\textsf{M}}{}{}{\ottcom{function arguments constant}}\ottprodnewline
\ottprodline{|}{\ottnt{stmt}  \ottsym{=}  P  \ottsym{(}  x  \ottsym{)}} {\textsf{M}}{}{}{\ottcom{parser state map lookup}}\ottprodnewline
\ottprodline{|}{ x  = ``\mathit{parseError}" } {\textsf{M}}{}{}{\ottcom{parser error literal}}\ottprodnewline
\ottprodline{|}{ \ottnt{v}  = { \mathrm{lookup} }_{ \mathrm{lval} } ( \varepsilon ,  \ottnt{lval} ) } {\textsf{M}}{}{}{\ottcom{instantaneous lookup of lvals}}\ottprodnewline
\ottprodline{|}{\ottnt{v''}  \ottsym{=}  \ottsym{(} \, \ottkw{struct} \, \ottsym{\{}  x_{{\mathrm{1}}}  \ottsym{=}  \ottnt{v_{{\mathrm{1}}}}  \ottsym{;} \, ... \, \ottsym{;}  x_{\ottmv{n}}  \ottsym{=}  \ottnt{v_{\ottmv{n}}}  \ottsym{\}} \, \ottkw{with} \, x  \ottsym{:=}  \ottnt{v}  \ottsym{)}} {\textsf{M}}{}{}{\ottcom{update of struct field}}\ottprodnewline
\ottprodline{|}{\ottnt{v''}  \ottsym{=}  \ottsym{(} \, \ottkw{header} \, \ottnt{boolv}  \ottsym{\{}  x_{{\mathrm{1}}}  \ottsym{=}  \ottnt{v_{{\mathrm{1}}}}  \ottsym{;} \, ... \, \ottsym{;}  x_{\ottmv{n}}  \ottsym{=}  \ottnt{v_{\ottmv{n}}}  \ottsym{\}} \, \ottkw{with} \, x  \ottsym{:=}  \ottnt{v}  \ottsym{)}} {\textsf{M}}{}{}{\ottcom{update of struct field}}\ottprodnewline
\ottprodline{|}{\ottkw{not\_final\_state} \, \ottsym{(}  x  \ottsym{)}} {\textsf{M}}{}{}{\ottcom{x is not name of final state}}\ottprodnewline
\ottprodline{|}{ x  = ``\mathit{accept}" } {\textsf{M}}{}{}{\ottcom{x is accept}}\ottprodnewline
\ottprodline{|}{ x  = ``\mathit{reject}" } {\textsf{M}}{}{}{\ottcom{x is reject}}\ottprodnewline
\ottprodline{|}{ \forall d,\, e,\, x,\, i \leqslant n . \, x = [x_1 , ... , x_n] [i] \land 
         \, e = [e_1 , ... , e_n] [i] \land 
         \, d = [d_1 , ... , d_n] [i] 
         \implies  \gamma (x) = 
	   \begin{cases}
	     (\mathrm{lookup_v}( \varepsilon , e), e) & \mathrm{if} \; d \in \{ \uparrow , \updownarrow \} \\
             (e, \bot) & \mathrm{if} \; d \in \{ \downarrow , \circ \}
	   \end{cases} } {\textsf{M}}{}{}{\ottcom{build new scope}}\ottprodnewline
\ottprodline{|}{ \ottnt{v}  = \mathrm{arb\_from\_t}  t } {\textsf{M}}{}{}{\ottcom{create new varaible in declaration}}\ottprodnewline
\ottprodline{|}{{ \mathit{ext} } \, x  \ottsym{(}  \ottnt{e_{{\mathrm{1}}}}  \ottsym{,} \, .. \, \ottsym{,}  \ottnt{e_{\ottmv{n}}}  \ottsym{)}  \ottsym{(}  \sigma  \ottsym{,} \, \ottkw{Running} \, \ottsym{)}  \ottsym{=}  \ottsym{(}  \ottnt{v}  \ottsym{,}  \ottsym{(}  \sigma'  \ottsym{,}  t  \ottsym{)}  \ottsym{)}} {\textsf{M}}{}{}{\ottcom{execute extern method}}\ottprodnewline
\ottprodline{|}{\ottsym{(}  { \mathit{ext} }  \ottsym{,}  \ottsym{(}  x_{{\mathrm{1}}}  \ottsym{,}  d_{{\mathrm{1}}}  \ottsym{)}  \ottsym{,} \, .. \, \ottsym{,}  \ottsym{(}  x_{\ottmv{n}}  \ottsym{,}  d_{\ottmv{n}}  \ottsym{)}  \ottsym{)}  \ottsym{=}  X  \ottsym{(}  f  \ottsym{)}} {\textsf{M}}{}{}{\ottcom{ext lookup}}\ottprodnewline
\ottprodline{|}{ \varepsilon'  =  \varepsilon  [  \ottnt{lval}  \longmapsto  \ottnt{v}  ] } {\textsf{M}}{}{}{\ottcom{assign v to lval in the frame}}\ottprodnewline
\ottprodline{|}{ \varepsilon''  = \mathrm{FOLD} (\lambda \, \overline{\varepsilon} \, i . \,
	                  \mathrm{if}   \ottnt{d\_list}  [i] \in \{ \downarrow , \circ \} \, \mathrm{then} \, \overline{\varepsilon} \\
                          \mathrm{else} \, \overline{\varepsilon} \, [a \longmapsto v] \mathit{where} \; (\mathit{v}, a) = \mathrm{lookup_t}(  \varepsilon  , [x_1 , ... , x_n] [i]) ) (  \varepsilon'  ) [1 ... n] } {\textsf{M}}{}{}{\ottcom{update caller's stack frame upon function return}}}

\newcommand{\otteXXstmtXXsem}{
\ottrulehead{\ottnt{e\_stmt\_sem}}{::=}{}\ottprodnewline
\ottfirstprodline{|}{ \mathit{ctx}  \vdash [  \ottnt{e}  ] ( \sigma ,  t ) \rightsquigarrow [  \ottnt{e'}  ] ( \sigma' ,  t' ) }{}{}{}{\ottcom{expression semantics}}\ottprodnewline
\ottprodline{|}{ \mathit{ctx}  \vdash [  \ottnt{stmt}  ] ( s ) \rightarrow [  \ottnt{stmt'}  ] ( s' ) }{}{}{}{\ottcom{statement semantics}}}

\newcommand{\ottparsXXsem}{
\ottrulehead{\ottnt{pars\_sem}}{::=}{}\ottprodnewline
\ottfirstprodline{|}{ \mathit{ctx}  \vdash [  \ottnt{stmt}  ] ( s ) \longrightarrow [  \ottnt{stmt'}  ] ( s' ) }{}{}{}{\ottcom{parser semantics}}}

\newcommand{\ottparsXXtXXsem}{
\ottrulehead{\ottnt{pars\_t\_sem}}{::=}{}\ottprodnewline
\ottfirstprodline{|}{ \mathit{ctx}  \vdash [  \ottnt{stmt}  ] ( s ) \longrightarrow  s' }{}{}{}{\ottcom{parser semantics, final step}}}

\newcommand{\ottjudgement}{
\ottrulehead{\ottnt{judgement}}{::=}{}\ottprodnewline
\ottfirstprodline{|}{\ottnt{e\_stmt\_sem}}{}{}{}{}\ottprodnewline
\ottprodline{|}{\ottnt{pars\_sem}}{}{}{}{}\ottprodnewline
\ottprodline{|}{\ottnt{pars\_t\_sem}}{}{}{}{}}

\newcommand{\ottuserXXsyntax}{
\ottrulehead{\ottnt{user\_syntax}}{::=}{}\ottprodnewline
\ottfirstprodline{|}{x}{}{}{}{}\ottprodnewline
\ottprodline{|}{b}{}{}{}{}\ottprodnewline
\ottprodline{|}{bl}{}{}{}{}\ottprodnewline
\ottprodline{|}{i}{}{}{}{}\ottprodnewline
\ottprodline{|}{\ottmv{m}}{}{}{}{}\ottprodnewline
\ottprodline{|}{\ottnt{boolv}}{}{}{}{}\ottprodnewline
\ottprodline{|}{\ottnt{bitv}}{}{}{}{}\ottprodnewline
\ottprodline{|}{\ottnt{packet\_in}}{}{}{}{}\ottprodnewline
\ottprodline{|}{\ottnt{packet\_out}}{}{}{}{}\ottprodnewline
\ottprodline{|}{\ottnt{ipv4\_checksum}}{}{}{}{}\ottprodnewline
\ottprodline{|}{\ottnt{ext\_obj}}{}{}{}{}\ottprodnewline
\ottprodline{|}{\ottnt{v}}{}{}{}{}\ottprodnewline
\ottprodline{|}{\ottnt{lval}}{}{}{}{}\ottprodnewline
\ottprodline{|}{p_{ \mathrm{fin} }}{}{}{}{}\ottprodnewline
\ottprodline{|}{p}{}{}{}{}\ottprodnewline
\ottprodline{|}{t}{}{}{}{}\ottprodnewline
\ottprodline{|}{\gamma}{}{}{}{}\ottprodnewline
\ottprodline{|}{\varepsilon}{}{}{}{}\ottprodnewline
\ottprodline{|}{F_n}{}{}{}{}\ottprodnewline
\ottprodline{|}{E}{}{}{}{}\ottprodnewline
\ottprodline{|}{\sigma}{}{}{}{}\ottprodnewline
\ottprodline{|}{s}{}{}{}{}\ottprodnewline
\ottprodline{|}{\ominus}{}{}{}{}\ottprodnewline
\ottprodline{|}{\oplus}{}{}{}{}\ottprodnewline
\ottprodline{|}{{ \mathit{ext} }}{}{}{}{}\ottprodnewline
\ottprodline{|}{\ottnt{e}}{}{}{}{}\ottprodnewline
\ottprodline{|}{\ottnt{e\_list}}{}{}{}{}\ottprodnewline
\ottprodline{|}{\mathit{match\_kind}}{}{}{}{}\ottprodnewline
\ottprodline{|}{bt}{}{}{}{}\ottprodnewline
\ottprodline{|}{t}{}{}{}{}\ottprodnewline
\ottprodline{|}{\ottnt{stmt}}{}{}{}{}\ottprodnewline
\ottprodline{|}{d}{}{}{}{}\ottprodnewline
\ottprodline{|}{\ottnt{d\_list}}{}{}{}{}\ottprodnewline
\ottprodline{|}{F}{}{}{}{}\ottprodnewline
\ottprodline{|}{X}{}{}{}{}\ottprodnewline
\ottprodline{|}{{ \mathrm{ctrl} }}{}{}{}{}\ottprodnewline
\ottprodline{|}{{ \mathit{Tb} }}{}{}{}{}\ottprodnewline
\ottprodline{|}{P}{}{}{}{}\ottprodnewline
\ottprodline{|}{T}{}{}{}{}\ottprodnewline
\ottprodline{|}{\mathit{ctx}}{}{}{}{}\ottprodnewline
\ottprodline{|}{\ottnt{terminals}}{}{}{}{}\ottprodnewline
\ottprodline{|}{\ottnt{formula}}{}{}{}{}}

\newcommand{\ottgrammar}{\ottgrammartabular{
\ottboolv\ottinterrule
\ottbitv\ottinterrule
\ottpacketXXin\ottinterrule
\ottpacketXXout\ottinterrule
\ottipvFourXXchecksum\ottinterrule
\ottextXXobj\ottinterrule
\ottv\ottinterrule
\ottlval\ottinterrule
\ottparsXXfin\ottinterrule
\ottparsXXnext\ottinterrule
\ottstatus\ottinterrule
\ottscope\ottinterrule
\ottcurrXXstackXXframe\ottinterrule
\ottcalledXXfunctionXXname\ottinterrule
\ottcallXXstack\ottinterrule
\ottstacks\ottinterrule
\ottstate\ottinterrule
\ottunop\ottinterrule
\ottbinop\ottinterrule
\ottext\ottinterrule
\otte\ottinterrule
\otteXXlist\ottinterrule
\ottmatchXXkind\ottinterrule
\ottbt\ottinterrule
\ottt\ottinterrule
\ottstmt\ottinterrule
\ottd\ottinterrule
\ottdXXlist\ottinterrule
\ottfuncXXmap\ottinterrule
\ottextXXmap\ottinterrule
\ottctrl\ottinterrule
\otttXXmap\ottinterrule
\ottparsXXmap\ottinterrule
\otttypeXXmap\ottinterrule
\ottctx\ottinterrule
\ottterminals\ottinterrule
\ottformula\ottinterrule
\otteXXstmtXXsem\ottinterrule
\ottparsXXsem\ottinterrule
\ottparsXXtXXsem\ottinterrule
\ottjudgement\ottinterrule
\ottuserXXsyntax\ottafterlastrule
}}

% defnss
% defns e_stmt_sem
%% defn e_red
\newcommand{\ottdruleeXXlookup}[1]{\ottdrule[#1]{%
\ottpremise{ \ottnt{v}  = \mathrm{lookup_v} ( \varepsilon ,  x ) }%
}{
 \mathit{ctx}  \vdash [  \ottkw{var} \, x  ] ( \ottsym{(}  \varepsilon  \ottsym{,}  E  \ottsym{)} ,   { \mathbf{R} }  ) \rightsquigarrow [  \ottnt{v}  ] ( \ottsym{(}  \varepsilon  \ottsym{,}  E  \ottsym{)} ,   { \mathbf{R} }  ) }{%
{\ottdrulename{e\_lookup}}{}%
}}


\newcommand{\ottdruleeXXfuncXXcallXXnewframe}[1]{\ottdrule[#1]{%
\ottpremise{\ottsym{(}  \ottnt{stmt}  \ottsym{,}  \ottsym{(}  x_{{\mathrm{1}}}  \ottsym{,}  d_{{\mathrm{1}}}  \ottsym{)}  \ottsym{,} \, .. \, \ottsym{,}  \ottsym{(}  x_{\ottmv{n}}  \ottsym{,}  d_{\ottmv{n}}  \ottsym{)}  \ottsym{)}  \ottsym{=}  F  \ottsym{(}  f  \ottsym{)}}%
\ottpremise{ \forall d ,\, e ,\, i \leqslant n. \, d =  \ottsym{[}  d_{{\mathrm{1}}}  \ottsym{,} \, .. \, \ottsym{,}  d_{\ottmv{n}}  \ottsym{]}  [i] \, \land \, e =  \ottsym{[}  \ottnt{e_{{\mathrm{1}}}}  \ottsym{,} \, .. \, \ottsym{,}  \ottnt{e_{\ottmv{n}}}  \ottsym{]}  [i] \, \implies  
         ((d \in \{\circ , \downarrow\} \implies \mathrm{is\_const} \, e ) \land (d \in \{\updownarrow , \uparrow\} \implies \mathrm{is\_var} \, e)) }%
\ottpremise{ \forall d,\, e,\, x,\, i \leqslant n . \, x = [x_1 , ... , x_n] [i] \land 
         \, e = [e_1 , ... , e_n] [i] \land 
         \, d = [d_1 , ... , d_n] [i] 
         \implies  \gamma' (x) = 
	   \begin{cases}
	     (\mathrm{lookup_v}( \varepsilon , e), e) & \mathrm{if} \; d \in \{ \uparrow , \updownarrow \} \\
             (e, \bot) & \mathrm{if} \; d \in \{ \downarrow , \circ \}
	   \end{cases} }%
\ottpremise{ { \gamma }_G   \ottsym{=}  \varepsilon  \ottsym{[}  0  \ottsym{]}}%
\ottpremise{\varepsilon'  \ottsym{=}   \ottsym{[}   { \gamma }_G   \ottsym{]}  \mathrel{\mathop+}+  \ottsym{[}  \gamma'  \ottsym{]} }%
\ottpremise{\varepsilon''  \ottsym{=}   \mathrm{tl} ( \varepsilon ) }%
\ottpremise{E'  \ottsym{=}   ( \varepsilon'' ,   f  ) ::  E }%
}{
 \ottsym{(}  T  \ottsym{,}  X  \ottsym{,}  F  \ottsym{,}  P  \ottsym{,}  { \mathit{Tb} }  \ottsym{,}  { \mathrm{ctrl} }  \ottsym{)}  \vdash [  \ottkw{call} \, f  \ottsym{(}  \ottnt{e_{{\mathrm{1}}}}  \ottsym{,} \, .. \, \ottsym{,}  \ottnt{e_{\ottmv{n}}}  \ottsym{)}  ] ( \ottsym{(}  \varepsilon  \ottsym{,}  E  \ottsym{)} ,   { \mathbf{R} }  ) \rightsquigarrow [  \ottkw{exec} \, \ottnt{stmt}  ] ( \ottsym{(}  \varepsilon'  \ottsym{,}  E'  \ottsym{)} ,   { \mathbf{R} }  ) }{%
{\ottdrulename{e\_func\_call\_newframe}}{}%
}}


\newcommand{\ottdruleeXXfuncXXexec}[1]{\ottdrule[#1]{%
\ottpremise{ \mathit{ctx}  \vdash [  \ottnt{stmt}  ] ( \ottsym{(}  \sigma  \ottsym{,}   { \mathbf{R} }   \ottsym{)} ) \rightarrow [  \ottnt{stmt'}  ] ( \ottsym{(}  \sigma'  \ottsym{,}  t  \ottsym{)} ) }%
}{
 \mathit{ctx}  \vdash [  \ottkw{exec} \, \ottnt{stmt}  ] ( \sigma ,   { \mathbf{R} }  ) \rightsquigarrow [  \ottkw{exec} \, \ottnt{stmt'}  ] ( \sigma' ,  t ) }{%
{\ottdrulename{e\_func\_exec}}{}%
}}


\newcommand{\ottdruleeXXfuncXXret}[1]{\ottdrule[#1]{%
\ottpremise{ ( \varepsilon' ,   f  ) ::  E'   \ottsym{=}  E}%
\ottpremise{\ottsym{(}  \ottnt{stmt}  \ottsym{,}  \ottsym{(}  x_{{\mathrm{1}}}  \ottsym{,}  d_{{\mathrm{1}}}  \ottsym{)}  \ottsym{,} \, .. \, \ottsym{,}  \ottsym{(}  x_{\ottmv{n}}  \ottsym{,}  d_{\ottmv{n}}  \ottsym{)}  \ottsym{)}  \ottsym{=}  F  \ottsym{(}  f  \ottsym{)}}%
\ottpremise{ { \gamma }_G   \ottsym{=}  \varepsilon  \ottsym{[}  0  \ottsym{]}}%
\ottpremise{\varepsilon''  \ottsym{=}   \ottsym{(}   { \gamma }_G   \ottsym{)}  ::  \varepsilon' }%
\ottpremise{ \varepsilon'''  = \mathrm{FOLD} (\lambda \, \overline{\varepsilon} \, i . \,
	                  \mathrm{if}   \ottsym{[}  d_{{\mathrm{1}}}  \ottsym{,} \, .. \, \ottsym{,}  d_{\ottmv{n}}  \ottsym{]}  [i] \in \{ \downarrow , \circ \} \, \mathrm{then} \, \overline{\varepsilon} \\
                          \mathrm{else} \, \overline{\varepsilon} \, [a \longmapsto v] \mathit{where} \; (\mathit{v}, a) = \mathrm{lookup_t}(  \varepsilon  , [x_1 , ... , x_n] [i]) ) (  \varepsilon''  ) [1 ... n] }%
}{
 \ottsym{(}  T  \ottsym{,}  X  \ottsym{,}  F  \ottsym{,}  P  \ottsym{,}  { \mathit{Tb} }  \ottsym{,}  { \mathrm{ctrl} }  \ottsym{)}  \vdash [  \ottkw{exec} \, \ottkw{return} \, \ottnt{v}  ] ( \ottsym{(}  \varepsilon  \ottsym{,}  E  \ottsym{)} ,   { \mathbf{R} }  ) \rightsquigarrow [  \ottnt{v}  ] ( \ottsym{(}  \varepsilon'''  \ottsym{,}  E'  \ottsym{)} ,   { \mathbf{R} }  ) }{%
{\ottdrulename{e\_func\_ret}}{}%
}}


\newcommand{\ottdruleeXXfuncXXretXXseq}[1]{\ottdrule[#1]{%
\ottpremise{ ( \varepsilon' ,   f  ) ::  E'   \ottsym{=}  E}%
\ottpremise{\ottsym{(}  \ottnt{stmt}  \ottsym{,}  \ottsym{(}  x_{{\mathrm{1}}}  \ottsym{,}  d_{{\mathrm{1}}}  \ottsym{)}  \ottsym{,} \, .. \, \ottsym{,}  \ottsym{(}  x_{\ottmv{n}}  \ottsym{,}  d_{\ottmv{n}}  \ottsym{)}  \ottsym{)}  \ottsym{=}  F  \ottsym{(}  f  \ottsym{)}}%
\ottpremise{ { \gamma }_G   \ottsym{=}  \varepsilon  \ottsym{[}  0  \ottsym{]}}%
\ottpremise{\varepsilon''  \ottsym{=}   \ottsym{(}   { \gamma }_G   \ottsym{)}  ::  \varepsilon' }%
\ottpremise{ \varepsilon'''  = \mathrm{FOLD} (\lambda \, \overline{\varepsilon} \, i . \,
	                  \mathrm{if}   \ottsym{[}  d_{{\mathrm{1}}}  \ottsym{,} \, .. \, \ottsym{,}  d_{\ottmv{n}}  \ottsym{]}  [i] \in \{ \downarrow , \circ \} \, \mathrm{then} \, \overline{\varepsilon} \\
                          \mathrm{else} \, \overline{\varepsilon} \, [a \longmapsto v] \mathit{where} \; (\mathit{v}, a) = \mathrm{lookup_t}(  \varepsilon  , [x_1 , ... , x_n] [i]) ) (  \varepsilon''  ) [1 ... n] }%
}{
 \ottsym{(}  T  \ottsym{,}  X  \ottsym{,}  F  \ottsym{,}  P  \ottsym{,}  { \mathit{Tb} }  \ottsym{,}  { \mathrm{ctrl} }  \ottsym{)}  \vdash [  \ottkw{exec} \, \ottkw{return} \, \ottnt{v}  \ottsym{;}  \ottnt{stmt'}  ] ( \ottsym{(}  \varepsilon  \ottsym{,}  E  \ottsym{)} ,   { \mathbf{R} }  ) \rightsquigarrow [  \ottnt{v}  ] ( \ottsym{(}  \varepsilon'''  \ottsym{,}  E'  \ottsym{)} ,   { \mathbf{R} }  ) }{%
{\ottdrulename{e\_func\_ret\_seq}}{}%
}}


\newcommand{\ottdruleeXXextXXexec}[1]{\ottdrule[#1]{%
\ottpremise{\ottsym{(}  { \mathit{ext} }  \ottsym{,}  \ottsym{(}  x_{{\mathrm{1}}}  \ottsym{,}  d_{{\mathrm{1}}}  \ottsym{)}  \ottsym{,} \, .. \, \ottsym{,}  \ottsym{(}  x_{\ottmv{n}}  \ottsym{,}  d_{\ottmv{n}}  \ottsym{)}  \ottsym{)}  \ottsym{=}  X  \ottsym{(}  f  \ottsym{)}}%
\ottpremise{ \forall d ,\, e ,\, i \leqslant n. \, d =  \ottsym{[}  d_{{\mathrm{1}}}  \ottsym{,} \, .. \, \ottsym{,}  d_{\ottmv{n}}  \ottsym{]}  [i] \, \land \, e =  \ottsym{[}  \ottnt{e_{{\mathrm{1}}}}  \ottsym{,} \, .. \, \ottsym{,}  \ottnt{e_{\ottmv{n}}}  \ottsym{]}  [i] \, \implies  
         ((d \in \{\circ , \downarrow\} \implies \mathrm{is\_const} \, e ) \land (d \in \{\updownarrow , \uparrow\} \implies \mathrm{is\_var} \, e)) }%
\ottpremise{{ \mathit{ext} } \, x  \ottsym{(}  \ottnt{e_{{\mathrm{1}}}}  \ottsym{,} \, .. \, \ottsym{,}  \ottnt{e_{\ottmv{n}}}  \ottsym{)}  \ottsym{(}  \sigma  \ottsym{,} \, \ottkw{Running} \, \ottsym{)}  \ottsym{=}  \ottsym{(}  \ottnt{v}  \ottsym{,}  \ottsym{(}  \sigma'  \ottsym{,}  t  \ottsym{)}  \ottsym{)}}%
}{
 \mathit{ctx}  \vdash [  \ottkw{call} \, x \, f  \ottsym{(}  \ottnt{e_{{\mathrm{1}}}}  \ottsym{,} \, .. \, \ottsym{,}  \ottnt{e_{\ottmv{n}}}  \ottsym{)}  ] ( \sigma ,   { \mathbf{R} }  ) \rightsquigarrow [  \ottnt{v}  ] ( \sigma' ,  t ) }{%
{\ottdrulename{e\_ext\_exec}}{}%
}}


\newcommand{\ottdruleeXXsXXacc}[1]{\ottdrule[#1]{%
\ottpremise{\ottnt{v}  \ottsym{=} \, \ottkw{struct} \, \ottsym{\{}  f_{{\mathrm{1}}}  \ottsym{=}  \ottnt{v_{{\mathrm{1}}}}  \ottsym{;} \, ... \, \ottsym{;}  f_{\ottmv{n}}  \ottsym{=}  \ottnt{v_{\ottmv{n}}}  \ottsym{\}}  \ottsym{(}  f  \ottsym{)}}%
}{
 \mathit{ctx}  \vdash [  \ottkw{struct} \, \ottsym{\{}  f_{{\mathrm{1}}}  \ottsym{=}  \ottnt{v_{{\mathrm{1}}}}  \ottsym{;} \, ... \, \ottsym{;}  f_{\ottmv{n}}  \ottsym{=}  \ottnt{v_{\ottmv{n}}}  \ottsym{\}}  \ottsym{.}  f  ] ( \sigma ,   { \mathbf{R} }  ) \rightsquigarrow [  \ottnt{v}  ] ( \sigma ,   { \mathbf{R} }  ) }{%
{\ottdrulename{e\_s\_acc}}{}%
}}


\newcommand{\ottdruleeXXhXXacc}[1]{\ottdrule[#1]{%
\ottpremise{\ottnt{v}  \ottsym{=} \, \ottkw{header} \, \ottnt{boolv}  \ottsym{\{}  f_{{\mathrm{1}}}  \ottsym{=}  \ottnt{v_{{\mathrm{1}}}}  \ottsym{;} \, ... \, \ottsym{;}  f_{\ottmv{n}}  \ottsym{=}  \ottnt{v_{\ottmv{n}}}  \ottsym{\}}  \ottsym{(}  f  \ottsym{)}}%
}{
 \mathit{ctx}  \vdash [  \ottkw{header} \, \ottnt{boolv}  \ottsym{\{}  f_{{\mathrm{1}}}  \ottsym{=}  \ottnt{v_{{\mathrm{1}}}}  \ottsym{;} \, ... \, \ottsym{;}  f_{\ottmv{n}}  \ottsym{=}  \ottnt{v_{\ottmv{n}}}  \ottsym{\}}  \ottsym{.}  f  ] ( \sigma ,   { \mathbf{R} }  ) \rightsquigarrow [  \ottnt{v}  ] ( \sigma ,   { \mathbf{R} }  ) }{%
{\ottdrulename{e\_h\_acc}}{}%
}}


\newcommand{\ottdruleeXXselXXacc}[1]{\ottdrule[#1]{%
\ottpremise{ x'  = \{ v_1 : x_1 ; ... ; v_n : x_n ; \_ : x \} (v) }%
}{
 \mathit{ctx}  \vdash [  \ottkw{select} \, \ottnt{v}  \ottsym{\{}  \ottnt{v_{{\mathrm{1}}}}  \ottsym{:}  x_{{\mathrm{1}}}  \ottsym{;} \, ... \, \ottsym{;}  \ottnt{v_{\ottmv{n}}}  \ottsym{:}  x_{\ottmv{n}}  \ottsym{\}}  x  ] ( \sigma ,   { \mathbf{R} }  ) \rightsquigarrow [  x'  ] ( \sigma ,   { \mathbf{R} }  ) }{%
{\ottdrulename{e\_sel\_acc}}{}%
}}


\newcommand{\ottdruleeXXselXXdef}[1]{\ottdrule[#1]{%
\ottpremise{ \ottnt{v}  \notin \mathrm{dom}(\{ v_1 : x_1 ; ... ; v_n : x_n \}) }%
}{
 \mathit{ctx}  \vdash [  \ottkw{select} \, \ottnt{v}  \ottsym{\{}  \ottnt{v_{{\mathrm{1}}}}  \ottsym{:}  x_{{\mathrm{1}}}  \ottsym{;} \, ... \, \ottsym{;}  \ottnt{v_{\ottmv{n}}}  \ottsym{:}  x_{\ottmv{n}}  \ottsym{\}}  x  ] ( \sigma ,   { \mathbf{R} }  ) \rightsquigarrow [  x  ] ( \sigma ,   { \mathbf{R} }  ) }{%
{\ottdrulename{e\_sel\_def}}{}%
}}


\newcommand{\ottdruleeXXfuncXXcallXXargs}[1]{\ottdrule[#1]{%
\ottpremise{\ottsym{(}  \ottnt{stmt}  \ottsym{,}  \ottsym{(}  x_{{\mathrm{1}}}  \ottsym{,}  d_{{\mathrm{1}}}  \ottsym{)}  \ottsym{,} \, .. \, \ottsym{,}  \ottsym{(}  x_{\ottmv{n}}  \ottsym{,}  d_{\ottmv{n}}  \ottsym{)}  \ottsym{)}  \ottsym{=}  F  \ottsym{(}  f  \ottsym{)}}%
\ottpremise{ i = \mathrm{min} \, \{ j . \,\,  \ottsym{[}  d_{{\mathrm{1}}}  \ottsym{,} \, .. \, \ottsym{,}  d_{\ottmv{n}}  \ottsym{]}  [j]  \in \{\circ , \downarrow\} \wedge \neg ( \mathrm{is\_const} \,  \ottsym{[}  \ottnt{e_{{\mathrm{1}}}}  \ottsym{,} \, .. \, \ottsym{,}  \ottnt{e_{\ottmv{n}}}  \ottsym{]}  [j] ) \} }%
\ottpremise{\ottnt{e}  \ottsym{=}  \ottsym{[}  \ottnt{e_{{\mathrm{1}}}}  \ottsym{,} \, .. \, \ottsym{,}  \ottnt{e_{\ottmv{n}}}  \ottsym{]}  \ottsym{[}  i  \ottsym{]}}%
\ottpremise{ \ottsym{(}  T  \ottsym{,}  X  \ottsym{,}  F  \ottsym{,}  P  \ottsym{,}  { \mathit{Tb} }  \ottsym{,}  { \mathrm{ctrl} }  \ottsym{)}  \vdash [  \ottnt{e}  ] ( \sigma ,  t ) \rightsquigarrow [  \ottnt{e'}  ] ( \sigma' ,  t' ) }%
\ottpremise{ \ottsym{[}  \ottnt{e'_{{\mathrm{1}}}}  \ottsym{,} \, .. \, \ottsym{,}  \ottnt{e'_{\ottmv{n}}}  \ottsym{]}  =   ( i  \mapsto   \ottnt{e'} )  \ottsym{[}  \ottnt{e_{{\mathrm{1}}}}  \ottsym{,} \, .. \, \ottsym{,}  \ottnt{e_{\ottmv{n}}}  \ottsym{]}  }%
}{
 \ottsym{(}  T  \ottsym{,}  X  \ottsym{,}  F  \ottsym{,}  P  \ottsym{,}  { \mathit{Tb} }  \ottsym{,}  { \mathrm{ctrl} }  \ottsym{)}  \vdash [  \ottkw{call} \, f  \ottsym{(}  \ottnt{e_{{\mathrm{1}}}}  \ottsym{,} \, .. \, \ottsym{,}  \ottnt{e_{\ottmv{n}}}  \ottsym{)}  ] ( \sigma ,  t ) \rightsquigarrow [  \ottkw{call} \, f  \ottsym{(}  \ottnt{e'_{{\mathrm{1}}}}  \ottsym{,} \, .. \, \ottsym{,}  \ottnt{e'_{\ottmv{n}}}  \ottsym{)}  ] ( \sigma' ,  t' ) }{%
{\ottdrulename{e\_func\_call\_args}}{}%
}}


\newcommand{\ottdruleeXXextXXcallXXargs}[1]{\ottdrule[#1]{%
\ottpremise{\ottsym{(}   \emptyset_{ \mathrm{stmt} }   \ottsym{,}  \ottsym{(}  x_{{\mathrm{1}}}  \ottsym{,}  d_{{\mathrm{1}}}  \ottsym{)}  \ottsym{,} \, .. \, \ottsym{,}  \ottsym{(}  x_{\ottmv{n}}  \ottsym{,}  d_{\ottmv{n}}  \ottsym{)}  \ottsym{)}  \ottsym{=}  F  \ottsym{(}  f  \ottsym{)}}%
\ottpremise{ i = \mathrm{min} \, \{ j . \,\,  \ottsym{[}  d_{{\mathrm{1}}}  \ottsym{,} \, .. \, \ottsym{,}  d_{\ottmv{n}}  \ottsym{]}  [j]  \in \{\circ , \downarrow\} \wedge \neg ( \mathrm{is\_const} \,  \ottsym{[}  \ottnt{e_{{\mathrm{1}}}}  \ottsym{,} \, .. \, \ottsym{,}  \ottnt{e_{\ottmv{n}}}  \ottsym{]}  [j] ) \} }%
\ottpremise{\ottnt{e}  \ottsym{=}  \ottsym{[}  \ottnt{e_{{\mathrm{1}}}}  \ottsym{,} \, .. \, \ottsym{,}  \ottnt{e_{\ottmv{n}}}  \ottsym{]}  \ottsym{[}  i  \ottsym{]}}%
\ottpremise{ \ottsym{(}  T  \ottsym{,}  X  \ottsym{,}  F  \ottsym{,}  P  \ottsym{,}  { \mathit{Tb} }  \ottsym{,}  { \mathrm{ctrl} }  \ottsym{)}  \vdash [  \ottnt{e}  ] ( \sigma ,   { \mathbf{R} }  ) \rightsquigarrow [  \ottnt{e'}  ] ( \sigma' ,   { \mathbf{R} }  ) }%
\ottpremise{ \ottsym{[}  \ottnt{e'_{{\mathrm{1}}}}  \ottsym{,} \, .. \, \ottsym{,}  \ottnt{e'_{\ottmv{n}}}  \ottsym{]}  =   ( i  \mapsto   \ottnt{e'} )  \ottsym{[}  \ottnt{e_{{\mathrm{1}}}}  \ottsym{,} \, .. \, \ottsym{,}  \ottnt{e_{\ottmv{n}}}  \ottsym{]}  }%
}{
 \ottsym{(}  T  \ottsym{,}  X  \ottsym{,}  F  \ottsym{,}  P  \ottsym{,}  { \mathit{Tb} }  \ottsym{,}  { \mathrm{ctrl} }  \ottsym{)}  \vdash [  \ottkw{call} \, x \, f  \ottsym{(}  \ottnt{e_{{\mathrm{1}}}}  \ottsym{,} \, .. \, \ottsym{,}  \ottnt{e_{\ottmv{n}}}  \ottsym{)}  ] ( \sigma ,   { \mathbf{R} }  ) \rightsquigarrow [  \ottkw{call} \, x \, f  \ottsym{(}  \ottnt{e'_{{\mathrm{1}}}}  \ottsym{,} \, .. \, \ottsym{,}  \ottnt{e'_{\ottmv{n}}}  \ottsym{)}  ] ( \sigma' ,   { \mathbf{R} }  ) }{%
{\ottdrulename{e\_ext\_call\_args}}{}%
}}


\newcommand{\ottdruleeXXaccXXargOne}[1]{\ottdrule[#1]{%
\ottpremise{ \mathit{ctx}  \vdash [  \ottnt{e}  ] ( \sigma ,  t ) \rightsquigarrow [  \ottnt{e'}  ] ( \sigma' ,  t' ) }%
}{
 \mathit{ctx}  \vdash [  \ottnt{e}  \ottsym{.}  x  ] ( \sigma ,  t ) \rightsquigarrow [  \ottnt{e'}  \ottsym{.}  x  ] ( \sigma' ,  t' ) }{%
{\ottdrulename{e\_acc\_arg1}}{}%
}}


\newcommand{\ottdruleeXXaccXXargTwo}[1]{\ottdrule[#1]{%
\ottpremise{ \mathit{ctx}  \vdash [  \ottnt{e'}  ] ( \sigma ,  t ) \rightsquigarrow [  \ottnt{e''}  ] ( \sigma' ,  t' ) }%
}{
 \mathit{ctx}  \vdash [  \ottnt{e}  \ottsym{.}  \ottnt{e'}  ] ( \sigma ,  t ) \rightsquigarrow [  \ottnt{e}  \ottsym{.}  \ottnt{e''}  ] ( \sigma' ,  t' ) }{%
{\ottdrulename{e\_acc\_arg2}}{}%
}}


\newcommand{\ottdruleeXXselXXarg}[1]{\ottdrule[#1]{%
\ottpremise{ \mathit{ctx}  \vdash [  \ottnt{e}  ] ( \sigma ,  t ) \rightsquigarrow [  \ottnt{e'}  ] ( \sigma' ,  t' ) }%
}{
 \mathit{ctx}  \vdash [  \ottkw{select} \, \ottnt{e}  \ottsym{\{}  \ottnt{v_{{\mathrm{1}}}}  \ottsym{:}  x_{{\mathrm{1}}}  \ottsym{;} \, ... \, \ottsym{;}  \ottnt{v_{\ottmv{n}}}  \ottsym{:}  x_{\ottmv{n}}  \ottsym{\}}  x  ] ( \sigma ,  t ) \rightsquigarrow [  \ottkw{select} \, \ottnt{e'}  \ottsym{\{}  \ottnt{v_{{\mathrm{1}}}}  \ottsym{:}  x_{{\mathrm{1}}}  \ottsym{;} \, ... \, \ottsym{;}  \ottnt{v_{\ottmv{n}}}  \ottsym{:}  x_{\ottmv{n}}  \ottsym{\}}  x  ] ( \sigma' ,  t' ) }{%
{\ottdrulename{e\_sel\_arg}}{}%
}}


\newcommand{\ottdruleeXXunopXXarg}[1]{\ottdrule[#1]{%
\ottpremise{ \mathit{ctx}  \vdash [  \ottnt{e}  ] ( \sigma ,  t ) \rightsquigarrow [  \ottnt{e'}  ] ( \sigma' ,  t' ) }%
}{
 \mathit{ctx}  \vdash [   \ominus   \ottnt{e}   ] ( \sigma ,  t ) \rightsquigarrow [   \ominus   \ottnt{e'}   ] ( \sigma' ,  t' ) }{%
{\ottdrulename{e\_unop\_arg}}{}%
}}


\newcommand{\ottdruleeXXbinopXXargOne}[1]{\ottdrule[#1]{%
\ottpremise{ \mathit{ctx}  \vdash [  \ottnt{e}  ] ( \sigma ,  t ) \rightsquigarrow [  \ottnt{e''}  ] ( \sigma' ,  t' ) }%
}{
 \mathit{ctx}  \vdash [   \ottnt{e}   \oplus   \ottnt{e'}   ] ( \sigma ,  t ) \rightsquigarrow [   \ottnt{e''}   \oplus   \ottnt{e'}   ] ( \sigma' ,  t' ) }{%
{\ottdrulename{e\_binop\_arg1}}{}%
}}


\newcommand{\ottdruleeXXbinopXXargTwo}[1]{\ottdrule[#1]{%
\ottpremise{ \mathit{ctx}  \vdash [  \ottnt{e}  ] ( \sigma ,  t ) \rightsquigarrow [  \ottnt{e'}  ] ( \sigma' ,  t' ) }%
}{
 \mathit{ctx}  \vdash [   \ottnt{v}   \oplus   \ottnt{e}   ] ( \sigma ,  t ) \rightsquigarrow [   \ottnt{v}   \oplus   \ottnt{e'}   ] ( \sigma' ,  t' ) }{%
{\ottdrulename{e\_binop\_arg2}}{}%
}}


\newcommand{\ottdruleeXXnegXXbool}[1]{\ottdrule[#1]{%
\ottpremise{\ottsym{!}  b  \ottsym{=}  b'}%
}{
 \mathit{ctx}  \vdash [    !    b   ] ( \sigma ,   { \mathbf{R} }  ) \rightsquigarrow [  b'  ] ( \sigma ,   { \mathbf{R} }  ) }{%
{\ottdrulename{e\_neg\_bool}}{}%
}}


\newcommand{\ottdruleeXXcompl}[1]{\ottdrule[#1]{%
\ottpremise{\ottsym{~}  \ottnt{bitv}  \ottsym{=}  \ottnt{bitv'}}%
}{
 \mathit{ctx}  \vdash [    \neg    \ottnt{bitv}   ] ( \sigma ,   { \mathbf{R} }  ) \rightsquigarrow [  \ottnt{bitv'}  ] ( \sigma ,   { \mathbf{R} }  ) }{%
{\ottdrulename{e\_compl}}{}%
}}


\newcommand{\ottdruleeXXnegXXsigned}[1]{\ottdrule[#1]{%
\ottpremise{\ottsym{-}  \ottnt{bitv}  \ottsym{=}  \ottnt{bitv'}}%
}{
 \mathit{ctx}  \vdash [   \ottsym{-}   \ottnt{bitv}   ] ( \sigma ,   { \mathbf{R} }  ) \rightsquigarrow [  \ottnt{bitv'}  ] ( \sigma ,   { \mathbf{R} }  ) }{%
{\ottdrulename{e\_neg\_signed}}{}%
}}


\newcommand{\ottdruleeXXunXXplus}[1]{\ottdrule[#1]{%
\ottpremise{\ottsym{+}  \ottnt{bitv}  \ottsym{=}  \ottnt{bitv'}}%
}{
 \mathit{ctx}  \vdash [   \ottsym{+}   \ottnt{bitv}   ] ( \sigma ,   { \mathbf{R} }  ) \rightsquigarrow [  \ottnt{bitv'}  ] ( \sigma ,   { \mathbf{R} }  ) }{%
{\ottdrulename{e\_un\_plus}}{}%
}}


\newcommand{\ottdruleeXXmul}[1]{\ottdrule[#1]{%
\ottpremise{\ottnt{bitv}  \ottsym{*}  \ottnt{bitv'}  \ottsym{=}  \ottnt{bitv''}}%
}{
 \mathit{ctx}  \vdash [   \ottnt{bitv}    \times    \ottnt{bitv'}   ] ( \sigma ,   { \mathbf{R} }  ) \rightsquigarrow [  \ottnt{bitv''}  ] ( \sigma ,   { \mathbf{R} }  ) }{%
{\ottdrulename{e\_mul}}{}%
}}


\newcommand{\ottdruleeXXdiv}[1]{\ottdrule[#1]{%
\ottpremise{\ottnt{bitv}  \ottsym{/}  \ottnt{bitv'}  \ottsym{=}  \ottnt{bitv''}}%
}{
 \mathit{ctx}  \vdash [   \ottnt{bitv}   \ottsym{/}   \ottnt{bitv'}   ] ( \sigma ,   { \mathbf{R} }  ) \rightsquigarrow [  \ottnt{bitv''}  ] ( \sigma ,   { \mathbf{R} }  ) }{%
{\ottdrulename{e\_div}}{}%
}}


\newcommand{\ottdruleeXXmod}[1]{\ottdrule[#1]{%
\ottpremise{\ottnt{bitv} \, \ottkw{mod} \, \ottnt{bitv'}  \ottsym{=}  \ottnt{bitv''}}%
}{
 \mathit{ctx}  \vdash [   \ottnt{bitv}    \bmod    \ottnt{bitv'}   ] ( \sigma ,   { \mathbf{R} }  ) \rightsquigarrow [  \ottnt{bitv''}  ] ( \sigma ,   { \mathbf{R} }  ) }{%
{\ottdrulename{e\_mod}}{}%
}}


\newcommand{\ottdruleeXXadd}[1]{\ottdrule[#1]{%
\ottpremise{\ottnt{bitv}  \ottsym{+}  \ottnt{bitv'}  \ottsym{=}  \ottnt{bitv''}}%
}{
 \mathit{ctx}  \vdash [   \ottnt{bitv}   \ottsym{+}   \ottnt{bitv'}   ] ( \sigma ,   { \mathbf{R} }  ) \rightsquigarrow [  \ottnt{bitv''}  ] ( \sigma ,   { \mathbf{R} }  ) }{%
{\ottdrulename{e\_add}}{}%
}}


\newcommand{\ottdruleeXXsub}[1]{\ottdrule[#1]{%
\ottpremise{\ottnt{bitv}  \ottsym{-}  \ottnt{bitv'}  \ottsym{=}  \ottnt{bitv''}}%
}{
 \mathit{ctx}  \vdash [   \ottnt{bitv}   \ottsym{-}   \ottnt{bitv'}   ] ( \sigma ,   { \mathbf{R} }  ) \rightsquigarrow [  \ottnt{bitv''}  ] ( \sigma ,   { \mathbf{R} }  ) }{%
{\ottdrulename{e\_sub}}{}%
}}


\newcommand{\ottdruleeXXshl}[1]{\ottdrule[#1]{%
\ottpremise{\ottnt{bitv} \, \ottkw{SHL} \, \ottnt{bitv'}  \ottsym{=}  \ottnt{bitv''}}%
}{
 \mathit{ctx}  \vdash [   \ottnt{bitv}    \ll    \ottnt{bitv'}   ] ( \sigma ,   { \mathbf{R} }  ) \rightsquigarrow [  \ottnt{bitv''}  ] ( \sigma ,   { \mathbf{R} }  ) }{%
{\ottdrulename{e\_shl}}{}%
}}


\newcommand{\ottdruleeXXshr}[1]{\ottdrule[#1]{%
\ottpremise{\ottnt{bitv} \, \ottkw{SHR} \, \ottnt{bitv'}  \ottsym{=}  \ottnt{bitv''}}%
}{
 \mathit{ctx}  \vdash [   \ottnt{bitv}    \gg    \ottnt{bitv'}   ] ( \sigma ,   { \mathbf{R} }  ) \rightsquigarrow [  \ottnt{bitv''}  ] ( \sigma ,   { \mathbf{R} }  ) }{%
{\ottdrulename{e\_shr}}{}%
}}


\newcommand{\ottdruleeXXle}[1]{\ottdrule[#1]{%
\ottpremise{\ottnt{bitv} \, \ottkw{LE} \, \ottnt{bitv'}  \ottsym{=}  b}%
}{
 \mathit{ctx}  \vdash [   \ottnt{bitv}    \leq    \ottnt{bitv'}   ] ( \sigma ,   { \mathbf{R} }  ) \rightsquigarrow [  b  ] ( \sigma ,   { \mathbf{R} }  ) }{%
{\ottdrulename{e\_le}}{}%
}}


\newcommand{\ottdruleeXXge}[1]{\ottdrule[#1]{%
\ottpremise{\ottnt{bitv} \, \ottkw{GE} \, \ottnt{bitv'}  \ottsym{=}  b}%
}{
 \mathit{ctx}  \vdash [   \ottnt{bitv}    \geq    \ottnt{bitv'}   ] ( \sigma ,   { \mathbf{R} }  ) \rightsquigarrow [  b  ] ( \sigma ,   { \mathbf{R} }  ) }{%
{\ottdrulename{e\_ge}}{}%
}}


\newcommand{\ottdruleeXXlt}[1]{\ottdrule[#1]{%
\ottpremise{\ottnt{bitv}  \ottsym{<}  \ottnt{bitv'}  \ottsym{=}  b}%
}{
 \mathit{ctx}  \vdash [   \ottnt{bitv}    <    \ottnt{bitv'}   ] ( \sigma ,   { \mathbf{R} }  ) \rightsquigarrow [  b  ] ( \sigma ,   { \mathbf{R} }  ) }{%
{\ottdrulename{e\_lt}}{}%
}}


\newcommand{\ottdruleeXXgt}[1]{\ottdrule[#1]{%
\ottpremise{\ottnt{bitv}  \ottsym{>}  \ottnt{bitv'}  \ottsym{=}  b}%
}{
 \mathit{ctx}  \vdash [   \ottnt{bitv}    >    \ottnt{bitv'}   ] ( \sigma ,   { \mathbf{R} }  ) \rightsquigarrow [  b  ] ( \sigma ,   { \mathbf{R} }  ) }{%
{\ottdrulename{e\_gt}}{}%
}}


\newcommand{\ottdruleeXXneq}[1]{\ottdrule[#1]{%
\ottpremise{\ottnt{bitv} \, \ottkw{NE} \, \ottnt{bitv'}  \ottsym{=}  b}%
}{
 \mathit{ctx}  \vdash [   \ottnt{bitv}    \neq    \ottnt{bitv'}   ] ( \sigma ,   { \mathbf{R} }  ) \rightsquigarrow [  b  ] ( \sigma ,   { \mathbf{R} }  ) }{%
{\ottdrulename{e\_neq}}{}%
}}


\newcommand{\ottdruleeXXneqXXerror}[1]{\ottdrule[#1]{%
\ottpremise{ ( x  \neq  x' ) =  b }%
}{
 \mathit{ctx}  \vdash [   \ottsym{(}  \ottkw{errmsg} \, x  \ottsym{)}    \neq    \ottsym{(}  \ottkw{errmsg} \, x'  \ottsym{)}   ] ( \sigma ,   { \mathbf{R} }  ) \rightsquigarrow [  b  ] ( \sigma ,   { \mathbf{R} }  ) }{%
{\ottdrulename{e\_neq\_error}}{}%
}}


\newcommand{\ottdruleeXXneqXXbool}[1]{\ottdrule[#1]{%
\ottpremise{b \, \ottkw{NE} \, b'  \ottsym{=}  b''}%
}{
 \mathit{ctx}  \vdash [   b    \neq    b'   ] ( \sigma ,   { \mathbf{R} }  ) \rightsquigarrow [  b''  ] ( \sigma ,   { \mathbf{R} }  ) }{%
{\ottdrulename{e\_neq\_bool}}{}%
}}


\newcommand{\ottdruleeXXeq}[1]{\ottdrule[#1]{%
\ottpremise{\ottnt{bitv} \, \ottkw{EQ} \, \ottnt{bitv'}  \ottsym{=}  b}%
}{
 \mathit{ctx}  \vdash [   \ottnt{bitv}    =    \ottnt{bitv'}   ] ( \sigma ,   { \mathbf{R} }  ) \rightsquigarrow [  b  ] ( \sigma ,   { \mathbf{R} }  ) }{%
{\ottdrulename{e\_eq}}{}%
}}


\newcommand{\ottdruleeXXeqXXerror}[1]{\ottdrule[#1]{%
\ottpremise{ ( x  =  x' ) =  b }%
}{
 \mathit{ctx}  \vdash [   \ottsym{(}  \ottkw{errmsg} \, x  \ottsym{)}    =    \ottsym{(}  \ottkw{errmsg} \, x'  \ottsym{)}   ] ( \sigma ,   { \mathbf{R} }  ) \rightsquigarrow [  b  ] ( \sigma ,   { \mathbf{R} }  ) }{%
{\ottdrulename{e\_eq\_error}}{}%
}}


\newcommand{\ottdruleeXXeqXXbool}[1]{\ottdrule[#1]{%
\ottpremise{b \, \ottkw{EQ} \, b'  \ottsym{=}  b''}%
}{
 \mathit{ctx}  \vdash [   b    =    b'   ] ( \sigma ,   { \mathbf{R} }  ) \rightsquigarrow [  b''  ] ( \sigma ,   { \mathbf{R} }  ) }{%
{\ottdrulename{e\_eq\_bool}}{}%
}}


\newcommand{\ottdruleeXXand}[1]{\ottdrule[#1]{%
\ottpremise{\ottnt{bitv}  \ottsym{\&}  \ottnt{bitv'}  \ottsym{=}  \ottnt{bitv''}}%
}{
 \mathit{ctx}  \vdash [   \ottnt{bitv}   \ottsym{\&}   \ottnt{bitv'}   ] ( \sigma ,   { \mathbf{R} }  ) \rightsquigarrow [  \ottnt{bitv''}  ] ( \sigma ,   { \mathbf{R} }  ) }{%
{\ottdrulename{e\_and}}{}%
}}


\newcommand{\ottdruleeXXxor}[1]{\ottdrule[#1]{%
\ottpremise{\ottnt{bitv}  \ottsym{\mbox{$\uparrow$}}  \ottnt{bitv'}  \ottsym{=}  \ottnt{bitv''}}%
}{
 \mathit{ctx}  \vdash [   \ottnt{bitv}    \underline{\vee}    \ottnt{bitv'}   ] ( \sigma ,   { \mathbf{R} }  ) \rightsquigarrow [  \ottnt{bitv''}  ] ( \sigma ,   { \mathbf{R} }  ) }{%
{\ottdrulename{e\_xor}}{}%
}}


\newcommand{\ottdruleeXXor}[1]{\ottdrule[#1]{%
\ottpremise{\ottnt{bitv}  \ottsym{\mbox{$\mid$}}  \ottnt{bitv'}  \ottsym{=}  \ottnt{bitv''}}%
}{
 \mathit{ctx}  \vdash [   \ottnt{bitv}    \mid    \ottnt{bitv'}   ] ( \sigma ,   { \mathbf{R} }  ) \rightsquigarrow [  \ottnt{bitv''}  ] ( \sigma ,   { \mathbf{R} }  ) }{%
{\ottdrulename{e\_or}}{}%
}}


\newcommand{\ottdruleeXXbinXXandOne}[1]{\ottdrule[#1]{%
}{
 \mathit{ctx}  \vdash [   \ottkw{false}    \land    b   ] ( \sigma ,   { \mathbf{R} }  ) \rightsquigarrow [  \ottkw{false}  ] ( \sigma ,   { \mathbf{R} }  ) }{%
{\ottdrulename{e\_bin\_and1}}{}%
}}


\newcommand{\ottdruleeXXbinXXandTwo}[1]{\ottdrule[#1]{%
}{
 \mathit{ctx}  \vdash [   \ottkw{true}    \land    b   ] ( \sigma ,   { \mathbf{R} }  ) \rightsquigarrow [  b  ] ( \sigma ,   { \mathbf{R} }  ) }{%
{\ottdrulename{e\_bin\_and2}}{}%
}}


\newcommand{\ottdruleeXXbinXXorOne}[1]{\ottdrule[#1]{%
}{
 \mathit{ctx}  \vdash [   \ottkw{true}    \lor    b   ] ( \sigma ,   { \mathbf{R} }  ) \rightsquigarrow [  \ottkw{true}  ] ( \sigma ,   { \mathbf{R} }  ) }{%
{\ottdrulename{e\_bin\_or1}}{}%
}}


\newcommand{\ottdruleeXXbinXXorTwo}[1]{\ottdrule[#1]{%
}{
 \mathit{ctx}  \vdash [   \ottkw{false}    \lor    b   ] ( \sigma ,   { \mathbf{R} }  ) \rightsquigarrow [  b  ] ( \sigma ,   { \mathbf{R} }  ) }{%
{\ottdrulename{e\_bin\_or2}}{}%
}}

\newcommand{\ottdefneXXred}[1]{\begin{ottdefnblock}[#1]{$ \mathit{ctx}  \vdash [  \ottnt{e}  ] ( \sigma ,  t ) \rightsquigarrow [  \ottnt{e'}  ] ( \sigma' ,  t' ) $}{\ottcom{expression semantics}}
\ottusedrule{\ottdruleeXXlookup{}}
\ottusedrule{\ottdruleeXXfuncXXcallXXnewframe{}}
\ottusedrule{\ottdruleeXXfuncXXexec{}}
\ottusedrule{\ottdruleeXXfuncXXret{}}
\ottusedrule{\ottdruleeXXfuncXXretXXseq{}}
\ottusedrule{\ottdruleeXXextXXexec{}}
\ottusedrule{\ottdruleeXXsXXacc{}}
\ottusedrule{\ottdruleeXXhXXacc{}}
\ottusedrule{\ottdruleeXXselXXacc{}}
\ottusedrule{\ottdruleeXXselXXdef{}}
\ottusedrule{\ottdruleeXXfuncXXcallXXargs{}}
\ottusedrule{\ottdruleeXXextXXcallXXargs{}}
\ottusedrule{\ottdruleeXXaccXXargOne{}}
\ottusedrule{\ottdruleeXXaccXXargTwo{}}
\ottusedrule{\ottdruleeXXselXXarg{}}
\ottusedrule{\ottdruleeXXunopXXarg{}}
\ottusedrule{\ottdruleeXXbinopXXargOne{}}
\ottusedrule{\ottdruleeXXbinopXXargTwo{}}
\ottusedrule{\ottdruleeXXnegXXbool{}}
\ottusedrule{\ottdruleeXXcompl{}}
\ottusedrule{\ottdruleeXXnegXXsigned{}}
\ottusedrule{\ottdruleeXXunXXplus{}}
\ottusedrule{\ottdruleeXXmul{}}
\ottusedrule{\ottdruleeXXdiv{}}
\ottusedrule{\ottdruleeXXmod{}}
\ottusedrule{\ottdruleeXXadd{}}
\ottusedrule{\ottdruleeXXsub{}}
\ottusedrule{\ottdruleeXXshl{}}
\ottusedrule{\ottdruleeXXshr{}}
\ottusedrule{\ottdruleeXXle{}}
\ottusedrule{\ottdruleeXXge{}}
\ottusedrule{\ottdruleeXXlt{}}
\ottusedrule{\ottdruleeXXgt{}}
\ottusedrule{\ottdruleeXXneq{}}
\ottusedrule{\ottdruleeXXneqXXerror{}}
\ottusedrule{\ottdruleeXXneqXXbool{}}
\ottusedrule{\ottdruleeXXeq{}}
\ottusedrule{\ottdruleeXXeqXXerror{}}
\ottusedrule{\ottdruleeXXeqXXbool{}}
\ottusedrule{\ottdruleeXXand{}}
\ottusedrule{\ottdruleeXXxor{}}
\ottusedrule{\ottdruleeXXor{}}
\ottusedrule{\ottdruleeXXbinXXandOne{}}
\ottusedrule{\ottdruleeXXbinXXandTwo{}}
\ottusedrule{\ottdruleeXXbinXXorOne{}}
\ottusedrule{\ottdruleeXXbinXXorTwo{}}
\end{ottdefnblock}}

%% defn stmt_red
\newcommand{\ottdrulestmtXXassXXv}[1]{\ottdrule[#1]{%
\ottpremise{ \varepsilon'  =  \varepsilon  [  \ottnt{lval}  \longmapsto  \ottnt{v}  ] }%
}{
 \mathit{ctx}  \vdash [   \ottnt{lval}  \mathrel{\mathop:}=  \ottnt{v}   ] ( \ottsym{(}  \ottsym{(}  \varepsilon  \ottsym{,}  E  \ottsym{)}  \ottsym{,}   { \mathbf{R} }   \ottsym{)} ) \rightarrow [   \emptyset_{ \mathrm{stmt} }   ] ( \ottsym{(}  \ottsym{(}  \varepsilon'  \ottsym{,}  E  \ottsym{)}  \ottsym{,}   { \mathbf{R} }   \ottsym{)} ) }{%
{\ottdrulename{stmt\_ass\_v}}{}%
}}


\newcommand{\ottdrulestmtXXassXXnull}[1]{\ottdrule[#1]{%
}{
 \mathit{ctx}  \vdash [   \ottkw{null}  \mathrel{\mathop:}=  \ottnt{v}   ] ( \ottsym{(}  \ottsym{(}  \varepsilon  \ottsym{,}  E  \ottsym{)}  \ottsym{,}   { \mathbf{R} }   \ottsym{)} ) \rightarrow [   \emptyset_{ \mathrm{stmt} }   ] ( \ottsym{(}  \ottsym{(}  \varepsilon  \ottsym{,}  E  \ottsym{)}  \ottsym{,}   { \mathbf{R} }   \ottsym{)} ) }{%
{\ottdrulename{stmt\_ass\_null}}{}%
}}


\newcommand{\ottdrulestmtXXseqOne}[1]{\ottdrule[#1]{%
\ottpremise{ \mathit{ctx}  \vdash [  \ottnt{stmt_{{\mathrm{1}}}}  ] ( \ottsym{(}  \sigma  \ottsym{,}   { \mathbf{R} }   \ottsym{)} ) \rightarrow [  \ottnt{stmt'_{{\mathrm{1}}}}  ] ( \ottsym{(}  \sigma'  \ottsym{,}   { \mathbf{R} }   \ottsym{)} ) }%
}{
 \mathit{ctx}  \vdash [  \ottnt{stmt_{{\mathrm{1}}}}  \ottsym{;}  \ottnt{stmt_{{\mathrm{2}}}}  ] ( \ottsym{(}  \sigma  \ottsym{,}   { \mathbf{R} }   \ottsym{)} ) \rightarrow [  \ottnt{stmt'_{{\mathrm{1}}}}  \ottsym{;}  \ottnt{stmt_{{\mathrm{2}}}}  ] ( \ottsym{(}  \sigma'  \ottsym{,}   { \mathbf{R} }   \ottsym{)} ) }{%
{\ottdrulename{stmt\_seq1}}{}%
}}


\newcommand{\ottdrulestmtXXseqTwo}[1]{\ottdrule[#1]{%
}{
 \mathit{ctx}  \vdash [   \emptyset_{ \mathrm{stmt} }   \ottsym{;}  \ottnt{stmt}  ] ( \ottsym{(}  \sigma  \ottsym{,}   { \mathbf{R} }   \ottsym{)} ) \rightarrow [  \ottnt{stmt}  ] ( \ottsym{(}  \sigma  \ottsym{,}   { \mathbf{R} }   \ottsym{)} ) }{%
{\ottdrulename{stmt\_seq2}}{}%
}}


\newcommand{\ottdrulestmtXXcondTwo}[1]{\ottdrule[#1]{%
}{
 \mathit{ctx}  \vdash [  \ottkw{if} \, \ottkw{true} \, \ottkw{then} \, \ottnt{stmt_{{\mathrm{1}}}} \, \ottkw{else} \, \ottnt{stmt_{{\mathrm{2}}}}  ] ( \ottsym{(}  \sigma  \ottsym{,}   { \mathbf{R} }   \ottsym{)} ) \rightarrow [  \ottnt{stmt_{{\mathrm{1}}}}  ] ( \ottsym{(}  \sigma  \ottsym{,}   { \mathbf{R} }   \ottsym{)} ) }{%
{\ottdrulename{stmt\_cond2}}{}%
}}


\newcommand{\ottdrulestmtXXcondThree}[1]{\ottdrule[#1]{%
}{
 \mathit{ctx}  \vdash [  \ottkw{if} \, \ottkw{false} \, \ottkw{then} \, \ottnt{stmt_{{\mathrm{1}}}} \, \ottkw{else} \, \ottnt{stmt_{{\mathrm{2}}}}  ] ( \ottsym{(}  \sigma  \ottsym{,}   { \mathbf{R} }   \ottsym{)} ) \rightarrow [  \ottnt{stmt_{{\mathrm{2}}}}  ] ( \ottsym{(}  \sigma  \ottsym{,}   { \mathbf{R} }   \ottsym{)} ) }{%
{\ottdrulename{stmt\_cond3}}{}%
}}


\newcommand{\ottdrulestmtXXdecl}[1]{\ottdrule[#1]{%
\ottpremise{ i  = length ( \varepsilon ) - 1 }%
\ottpremise{\gamma  \ottsym{=}  \varepsilon  \ottsym{[}  i  \ottsym{]}}%
\ottpremise{ \ottnt{v}  = \mathrm{arb\_from\_t}  t }%
\ottpremise{\varepsilon'  \ottsym{=}   ( i  \mapsto   ( x  \mapsto   \ottnt{v} )  \gamma  )  \varepsilon }%
}{
 \mathit{ctx}  \vdash [  \ottkw{decl} \, x \, t  ] ( \ottsym{(}  \ottsym{(}  \varepsilon  \ottsym{,}  E  \ottsym{)}  \ottsym{,}   { \mathbf{R} }   \ottsym{)} ) \rightarrow [   \emptyset_{ \mathrm{stmt} }   ] ( \ottsym{(}  \ottsym{(}  \varepsilon'  \ottsym{,}  E  \ottsym{)}  \ottsym{,}   { \mathbf{R} }   \ottsym{)} ) }{%
{\ottdrulename{stmt\_decl}}{}%
}}


\newcommand{\ottdrulestmtXXblockXXenter}[1]{\ottdrule[#1]{%
\ottpremise{\varepsilon'  \ottsym{=}   \varepsilon  \mathrel{\mathop+}+  \ottsym{[}   {\gamma}_{ \emptyset }   \ottsym{]} }%
}{
 \mathit{ctx}  \vdash [   \{  \ottnt{stmt}  \}   ] ( \ottsym{(}  \ottsym{(}  \varepsilon  \ottsym{,}  E  \ottsym{)}  \ottsym{,}   { \mathbf{R} }   \ottsym{)} ) \rightarrow [   [  \ottnt{stmt}  ]   ] ( \ottsym{(}  \ottsym{(}  \varepsilon'  \ottsym{,}  E  \ottsym{)}  \ottsym{,}   { \mathbf{R} }   \ottsym{)} ) }{%
{\ottdrulename{stmt\_block\_enter}}{}%
}}


\newcommand{\ottdrulestmtXXblockXXexec}[1]{\ottdrule[#1]{%
\ottpremise{ \mathit{ctx}  \vdash [  \ottnt{stmt}  ] ( \ottsym{(}  \sigma  \ottsym{,}  t  \ottsym{)} ) \rightarrow [  \ottnt{stmt'}  ] ( \ottsym{(}  \sigma'  \ottsym{,}  t'  \ottsym{)} ) }%
}{
 \mathit{ctx}  \vdash [   [  \ottnt{stmt}  ]   ] ( \ottsym{(}  \sigma  \ottsym{,}  t  \ottsym{)} ) \rightarrow [   [  \ottnt{stmt'}  ]   ] ( \ottsym{(}  \sigma'  \ottsym{,}  t'  \ottsym{)} ) }{%
{\ottdrulename{stmt\_block\_exec}}{}%
}}


\newcommand{\ottdrulestmtXXblockXXexit}[1]{\ottdrule[#1]{%
\ottpremise{\varepsilon'  \ottsym{=}   \mathrm{rev} ( \ottsym{(}   \mathrm{tl} ( \ottsym{(}   \mathrm{rev} ( \varepsilon )   \ottsym{)} )   \ottsym{)} ) }%
}{
 \mathit{ctx}  \vdash [   [   \emptyset_{ \mathrm{stmt} }   ]   ] ( \ottsym{(}  \ottsym{(}  \varepsilon  \ottsym{,}  E  \ottsym{)}  \ottsym{,}   { \mathbf{R} }   \ottsym{)} ) \rightarrow [   \emptyset_{ \mathrm{stmt} }   ] ( \ottsym{(}  \ottsym{(}  \varepsilon'  \ottsym{,}  E  \ottsym{)}  \ottsym{,}   { \mathbf{R} }   \ottsym{)} ) }{%
{\ottdrulename{stmt\_block\_exit}}{}%
}}


\newcommand{\ottdrulestmtXXverifyXXThree}[1]{\ottdrule[#1]{%
}{
 \mathit{ctx}  \vdash [  \ottkw{verify} \, \ottkw{true} \, \ottsym{(}  \ottkw{errmsg} \, x  \ottsym{)}  ] ( \ottsym{(}  \sigma  \ottsym{,}   { \mathbf{R} }   \ottsym{)} ) \rightarrow [   \emptyset_{ \mathrm{stmt} }   ] ( \ottsym{(}  \sigma'  \ottsym{,}   { \mathbf{R} }   \ottsym{)} ) }{%
{\ottdrulename{stmt\_verify\_3}}{}%
}}


\newcommand{\ottdrulestmtXXverifyXXFour}[1]{\ottdrule[#1]{%
\ottpremise{ x'  = ``\mathit{parseError}" }%
\ottpremise{ x''  = ``\mathit{reject}" }%
}{
 \mathit{ctx}  \vdash [  \ottkw{verify} \, \ottkw{false} \, \ottsym{(}  \ottkw{errmsg} \, x  \ottsym{)}  ] ( \ottsym{(}  \sigma  \ottsym{,}   { \mathbf{R} }   \ottsym{)} ) \rightarrow [   x'  \mathrel{\mathop:}=  \ottsym{(}  \ottkw{errmsg} \, x  \ottsym{)}   \ottsym{;}   \mathbf{transition}\,  x''   ] ( \ottsym{(}  \sigma  \ottsym{,}   { \mathbf{R} }   \ottsym{)} ) }{%
{\ottdrulename{stmt\_verify\_4}}{}%
}}


\newcommand{\ottdrulestmtXXtransXXOne}[1]{\ottdrule[#1]{%
\ottpremise{\ottkw{not\_final\_state} \, \ottsym{(}  x  \ottsym{)}}%
}{
 \mathit{ctx}  \vdash [   \mathbf{transition}\,  x   ] ( \ottsym{(}  \sigma  \ottsym{,}   { \mathbf{R} }   \ottsym{)} ) \rightarrow [   \emptyset_{ \mathrm{stmt} }   ] ( \ottsym{(}  \sigma  \ottsym{,}  \ottkw{Trans} \, x  \ottsym{)} ) }{%
{\ottdrulename{stmt\_trans\_1}}{}%
}}


\newcommand{\ottdrulestmtXXtransXXTwo}[1]{\ottdrule[#1]{%
\ottpremise{ x  = ``\mathit{accept}" }%
}{
 \mathit{ctx}  \vdash [   \mathbf{transition}\,  x   ] ( \ottsym{(}  \sigma  \ottsym{,}   { \mathbf{R} }   \ottsym{)} ) \rightarrow [   \emptyset_{ \mathrm{stmt} }   ] ( \ottsym{(}  \sigma  \ottsym{,}  \ottkw{Accept}  \ottsym{)} ) }{%
{\ottdrulename{stmt\_trans\_2}}{}%
}}


\newcommand{\ottdrulestmtXXtransXXThree}[1]{\ottdrule[#1]{%
\ottpremise{ x  = ``\mathit{reject}" }%
}{
 \mathit{ctx}  \vdash [   \mathbf{transition}\,  x   ] ( \ottsym{(}  \sigma  \ottsym{,}   { \mathbf{R} }   \ottsym{)} ) \rightarrow [   \emptyset_{ \mathrm{stmt} }   ] ( \ottsym{(}  \sigma  \ottsym{,}  \ottkw{Reject}  \ottsym{)} ) }{%
{\ottdrulename{stmt\_trans\_3}}{}%
}}


\newcommand{\ottdrulestmtXXapplyXXtableXXv}[1]{\ottdrule[#1]{%
\ottpremise{ \mathrm{t\_map}\,  table\_name \, =\, (  \ottnt{e'}  \, ,  \mathit{match\_kind}  ) }%
\ottpremise{ \mathrm{ctrl}\, (  table\_name  , \,  \ottnt{v} , \,  \mathit{match\_kind} \, ) = \,(  f  ,  \ottsym{(}  \ottnt{v_{{\mathrm{1}}}}  \ottsym{,} \, .. \, \ottsym{,}  \ottnt{v_{\ottmv{n}}}  \ottsym{)}  ) }%
}{
 \ottsym{(}  T  \ottsym{,}  X  \ottsym{,}  F  \ottsym{,}  P  \ottsym{,}  { \mathit{Tb} }  \ottsym{,}  { \mathrm{ctrl} }  \ottsym{)}  \vdash [   \mathbf{apply} \,  table\_name  \,  \ottnt{v}   ] ( \ottsym{(}  \sigma  \ottsym{,}   { \mathbf{R} }   \ottsym{)} ) \rightarrow [   \ottkw{null}  \mathrel{\mathop:}=  \ottsym{(}  \ottkw{call} \, f  \ottsym{(}  \ottnt{v_{{\mathrm{1}}}}  \ottsym{,} \, .. \, \ottsym{,}  \ottnt{v_{\ottmv{n}}}  \ottsym{)}  \ottsym{)}   ] ( \ottsym{(}  \sigma'  \ottsym{,}   { \mathbf{R} }   \ottsym{)} ) }{%
{\ottdrulename{stmt\_apply\_table\_v}}{}%
}}


\newcommand{\ottdrulestmtXXretXXe}[1]{\ottdrule[#1]{%
\ottpremise{ \mathit{ctx}  \vdash [  \ottnt{e}  ] ( \sigma ,  t ) \rightsquigarrow [  \ottnt{e'}  ] ( \sigma' ,  t' ) }%
}{
 \mathit{ctx}  \vdash [  \ottkw{return} \, \ottnt{e}  ] ( \ottsym{(}  \sigma  \ottsym{,}  t  \ottsym{)} ) \rightarrow [  \ottkw{return} \, \ottnt{e'}  ] ( \ottsym{(}  \sigma'  \ottsym{,}  t'  \ottsym{)} ) }{%
{\ottdrulename{stmt\_ret\_e}}{}%
}}


\newcommand{\ottdrulestmtXXassXXe}[1]{\ottdrule[#1]{%
\ottpremise{ \mathit{ctx}  \vdash [  \ottnt{e}  ] ( \sigma ,  t ) \rightsquigarrow [  \ottnt{e'}  ] ( \sigma' ,  t' ) }%
}{
 \mathit{ctx}  \vdash [   \ottnt{lval}  \mathrel{\mathop:}=  \ottnt{e}   ] ( \ottsym{(}  \sigma  \ottsym{,}  t  \ottsym{)} ) \rightarrow [   \ottnt{lval}  \mathrel{\mathop:}=  \ottnt{e'}   ] ( \ottsym{(}  \sigma'  \ottsym{,}  t'  \ottsym{)} ) }{%
{\ottdrulename{stmt\_ass\_e}}{}%
}}


\newcommand{\ottdrulestmtXXcondXXe}[1]{\ottdrule[#1]{%
\ottpremise{ \mathit{ctx}  \vdash [  \ottnt{e}  ] ( \sigma ,  t ) \rightsquigarrow [  \ottnt{e'}  ] ( \sigma' ,  t' ) }%
}{
 \mathit{ctx}  \vdash [  \ottkw{if} \, \ottnt{e} \, \ottkw{then} \, \ottnt{stmt_{{\mathrm{1}}}} \, \ottkw{else} \, \ottnt{stmt_{{\mathrm{2}}}}  ] ( \ottsym{(}  \sigma  \ottsym{,}  t  \ottsym{)} ) \rightarrow [  \ottkw{if} \, \ottnt{e'} \, \ottkw{then} \, \ottnt{stmt_{{\mathrm{1}}}} \, \ottkw{else} \, \ottnt{stmt_{{\mathrm{2}}}}  ] ( \ottsym{(}  \sigma'  \ottsym{,}  t'  \ottsym{)} ) }{%
{\ottdrulename{stmt\_cond\_e}}{}%
}}


\newcommand{\ottdrulestmtXXverifyXXeOne}[1]{\ottdrule[#1]{%
\ottpremise{ \mathit{ctx}  \vdash [  \ottnt{e}  ] ( \sigma ,  t ) \rightsquigarrow [  \ottnt{e''}  ] ( \sigma' ,  t' ) }%
}{
 \mathit{ctx}  \vdash [  \ottkw{verify} \, \ottnt{e} \, \ottnt{e'}  ] ( \ottsym{(}  \sigma  \ottsym{,}  t  \ottsym{)} ) \rightarrow [  \ottkw{verify} \, \ottnt{e''} \, \ottnt{e'}  ] ( \ottsym{(}  \sigma'  \ottsym{,}  t'  \ottsym{)} ) }{%
{\ottdrulename{stmt\_verify\_e1}}{}%
}}


\newcommand{\ottdrulestmtXXverifyXXeTwo}[1]{\ottdrule[#1]{%
\ottpremise{ \mathit{ctx}  \vdash [  \ottnt{e}  ] ( \sigma ,  t ) \rightsquigarrow [  \ottnt{e'}  ] ( \sigma' ,  t' ) }%
}{
 \mathit{ctx}  \vdash [  \ottkw{verify} \, b \, \ottnt{e}  ] ( \ottsym{(}  \sigma  \ottsym{,}  t  \ottsym{)} ) \rightarrow [  \ottkw{verify} \, b \, \ottnt{e'}  ] ( \ottsym{(}  \sigma'  \ottsym{,}  t'  \ottsym{)} ) }{%
{\ottdrulename{stmt\_verify\_e2}}{}%
}}


\newcommand{\ottdrulestmtXXtransXXe}[1]{\ottdrule[#1]{%
\ottpremise{ \mathit{ctx}  \vdash [  \ottnt{e}  ] ( \sigma ,  t ) \rightsquigarrow [  \ottnt{e'}  ] ( \sigma' ,  t' ) }%
}{
 \mathit{ctx}  \vdash [   \mathbf{transition}\,  \ottnt{e}   ] ( \ottsym{(}  \sigma  \ottsym{,}  t  \ottsym{)} ) \rightarrow [   \mathbf{transition}\,  \ottnt{e'}   ] ( \ottsym{(}  \sigma'  \ottsym{,}  t'  \ottsym{)} ) }{%
{\ottdrulename{stmt\_trans\_e}}{}%
}}


\newcommand{\ottdrulestmtXXapplyXXtableXXe}[1]{\ottdrule[#1]{%
\ottpremise{ \mathit{ctx}  \vdash [  \ottnt{e}  ] ( \sigma ,  t ) \rightsquigarrow [  \ottnt{e'}  ] ( \sigma' ,  t' ) }%
}{
 \mathit{ctx}  \vdash [   \mathbf{apply} \,  table\_name  \,  \ottnt{e}   ] ( \ottsym{(}  \sigma  \ottsym{,}  t  \ottsym{)} ) \rightarrow [   \mathbf{apply} \,  table\_name  \,  \ottnt{e'}   ] ( \ottsym{(}  \sigma'  \ottsym{,}  t'  \ottsym{)} ) }{%
{\ottdrulename{stmt\_apply\_table\_e}}{}%
}}

\newcommand{\ottdefnstmtXXred}[1]{\begin{ottdefnblock}[#1]{$ \mathit{ctx}  \vdash [  \ottnt{stmt}  ] ( s ) \rightarrow [  \ottnt{stmt'}  ] ( s' ) $}{\ottcom{statement semantics}}
\ottusedrule{\ottdrulestmtXXassXXv{}}
\ottusedrule{\ottdrulestmtXXassXXnull{}}
\ottusedrule{\ottdrulestmtXXseqOne{}}
\ottusedrule{\ottdrulestmtXXseqTwo{}}
\ottusedrule{\ottdrulestmtXXcondTwo{}}
\ottusedrule{\ottdrulestmtXXcondThree{}}
\ottusedrule{\ottdrulestmtXXdecl{}}
\ottusedrule{\ottdrulestmtXXblockXXenter{}}
\ottusedrule{\ottdrulestmtXXblockXXexec{}}
\ottusedrule{\ottdrulestmtXXblockXXexit{}}
\ottusedrule{\ottdrulestmtXXverifyXXThree{}}
\ottusedrule{\ottdrulestmtXXverifyXXFour{}}
\ottusedrule{\ottdrulestmtXXtransXXOne{}}
\ottusedrule{\ottdrulestmtXXtransXXTwo{}}
\ottusedrule{\ottdrulestmtXXtransXXThree{}}
\ottusedrule{\ottdrulestmtXXapplyXXtableXXv{}}
\ottusedrule{\ottdrulestmtXXretXXe{}}
\ottusedrule{\ottdrulestmtXXassXXe{}}
\ottusedrule{\ottdrulestmtXXcondXXe{}}
\ottusedrule{\ottdrulestmtXXverifyXXeOne{}}
\ottusedrule{\ottdrulestmtXXverifyXXeTwo{}}
\ottusedrule{\ottdrulestmtXXtransXXe{}}
\ottusedrule{\ottdrulestmtXXapplyXXtableXXe{}}
\end{ottdefnblock}}


\newcommand{\ottdefnseXXstmtXXsem}{
\ottdefneXXred{}\ottdefnstmtXXred{}}

% defns pars_sem
%% defn pars_red
\newcommand{\ottdruleparsXXstmt}[1]{\ottdrule[#1]{%
\ottpremise{ \mathit{ctx}  \vdash [  \ottnt{stmt}  ] ( \ottsym{(}  \sigma  \ottsym{,}  t  \ottsym{)} ) \rightarrow [  \ottnt{stmt'}  ] ( \ottsym{(}  \sigma'  \ottsym{,}  t'  \ottsym{)} ) }%
}{
 \mathit{ctx}  \vdash [  \ottnt{stmt}  ] ( \ottsym{(}  \sigma  \ottsym{,}  t  \ottsym{)} ) \longrightarrow [  \ottnt{stmt'}  ] ( \ottsym{(}  \sigma'  \ottsym{,}  t'  \ottsym{)} ) }{%
{\ottdrulename{pars\_stmt}}{}%
}}


\newcommand{\ottdruleparsXXstate}[1]{\ottdrule[#1]{%
\ottpremise{ \ottsym{(}  T  \ottsym{,}  X  \ottsym{,}  F  \ottsym{,}  P  \ottsym{,}  { \mathit{Tb} }  \ottsym{,}  { \mathrm{ctrl} }  \ottsym{)}  \vdash [  \ottnt{stmt}  ] ( \ottsym{(}  \sigma  \ottsym{,}   { \mathbf{R} }   \ottsym{)} ) \rightarrow [  \ottnt{stmt'}  ] ( \ottsym{(}  \sigma'  \ottsym{,}  \ottkw{Trans} \, x  \ottsym{)} ) }%
\ottpremise{\ottnt{stmt''}  \ottsym{=}  P  \ottsym{(}  x  \ottsym{)}}%
}{
 \ottsym{(}  T  \ottsym{,}  X  \ottsym{,}  F  \ottsym{,}  P  \ottsym{,}  { \mathit{Tb} }  \ottsym{,}  { \mathrm{ctrl} }  \ottsym{)}  \vdash [  \ottnt{stmt}  ] ( \ottsym{(}  \sigma  \ottsym{,}   { \mathbf{R} }   \ottsym{)} ) \longrightarrow [  \ottnt{stmt''}  ] ( \ottsym{(}  \sigma'  \ottsym{,}   { \mathbf{R} }   \ottsym{)} ) }{%
{\ottdrulename{pars\_state}}{}%
}}


\newcommand{\ottdruleparsXXempty}[1]{\ottdrule[#1]{%
\ottpremise{ \mathit{ctx}  \vdash [  \ottnt{stmt}  ] ( \ottsym{(}  \sigma  \ottsym{,}   { \mathbf{R} }   \ottsym{)} ) \rightarrow [   \emptyset_{ \mathrm{stmt} }   ] ( \ottsym{(}  \sigma'  \ottsym{,}   { \mathbf{R} }   \ottsym{)} ) }%
\ottpremise{ x  = ``\mathit{reject}" }%
}{
 \mathit{ctx}  \vdash [  \ottnt{stmt}  ] ( \ottsym{(}  \sigma  \ottsym{,}   { \mathbf{R} }   \ottsym{)} ) \longrightarrow [   \mathbf{transition}\,  x   ] ( \ottsym{(}  \sigma'  \ottsym{,}   { \mathbf{R} }   \ottsym{)} ) }{%
{\ottdrulename{pars\_empty}}{}%
}}

\newcommand{\ottdefnparsXXred}[1]{\begin{ottdefnblock}[#1]{$ \mathit{ctx}  \vdash [  \ottnt{stmt}  ] ( s ) \longrightarrow [  \ottnt{stmt'}  ] ( s' ) $}{\ottcom{parser semantics}}
\ottusedrule{\ottdruleparsXXstmt{}}
\ottusedrule{\ottdruleparsXXstate{}}
\ottusedrule{\ottdruleparsXXempty{}}
\end{ottdefnblock}}


\newcommand{\ottdefnsparsXXsem}{
\ottdefnparsXXred{}}

% defns pars_t_sem
%% defn pars_t_red
\newcommand{\ottdruleparsXXtXXfin}[1]{\ottdrule[#1]{%
\ottpremise{ \mathit{ctx}  \vdash [  \ottnt{stmt}  ] ( \ottsym{(}  \sigma  \ottsym{,}   { \mathbf{R} }   \ottsym{)} ) \rightarrow [  \ottnt{stmt'}  ] ( \ottsym{(}  \sigma  \ottsym{,}  p_{ \mathrm{fin} }  \ottsym{)} ) }%
}{
 \mathit{ctx}  \vdash [  \ottnt{stmt}  ] ( \ottsym{(}  \sigma  \ottsym{,}   { \mathbf{R} }   \ottsym{)} ) \longrightarrow  \ottsym{(}  \sigma  \ottsym{,}  p_{ \mathrm{fin} }  \ottsym{)} }{%
{\ottdrulename{pars\_t\_fin}}{}%
}}

\newcommand{\ottdefnparsXXtXXred}[1]{\begin{ottdefnblock}[#1]{$ \mathit{ctx}  \vdash [  \ottnt{stmt}  ] ( s ) \longrightarrow  s' $}{\ottcom{parser semantics, final step}}
\ottusedrule{\ottdruleparsXXtXXfin{}}
\end{ottdefnblock}}


\newcommand{\ottdefnsparsXXtXXsem}{
\ottdefnparsXXtXXred{}}

\newcommand{\ottdefnss}{
\ottdefnseXXstmtXXsem
\ottdefnsparsXXsem
\ottdefnsparsXXtXXsem
}

\newcommand{\ottall}{\ottmetavars\\[0pt]
\ottgrammar\\[5.0mm]
\ottdefnss}


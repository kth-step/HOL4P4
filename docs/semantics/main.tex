\documentclass[UTF8]{article}
%\documentclass[a4paper,11pt,reqno]{amsart}

\pagestyle{headings}
\usepackage{graphicx}
\usepackage[english]{babel}
\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}
\usepackage{verbatim}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{pstricks}
\usepackage{mathrsfs}
\usepackage{textcomp}
\usepackage{tikz}
\usepackage{subfig}
\usepackage{fancyvrb}
\usepackage{enumitem}

\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=cyan,
}

\usepackage{csquotes}
\usepackage[backend=bibtex]{biblatex}
\addbibresource{p4.bib}
\usepackage{todonotes}

\usepackage{supertabular}
\usepackage{geometry}
\usepackage{ifthen}
\usepackage{alltt}%hack


\newcommand*{\inference}[3][t]{%
   \begingroup
   \def\and{\\}%
   \begin{tabular}[#1]{@{\enspace}c@{\enspace}}
   #2 \\
   \hline
   #3
   \end{tabular}%
   \endgroup
}

\include{p4_defs}
\newtheorem{thm}{Theorem}
\newtheorem{lemma}{Lemma}

\title{%
The \texttt{p4ott} P4 Formalization}
\author{Anoud Alshnakat\\
Didrik Lundberg
}
\date{\today}
\begin{document}
\maketitle

\newcommand{\pfott}{\texttt{p4ott}}

\begingroup\lccode`?=`# \lowercase{\endgroup
\newcommand{\specsec}[1]{%
    ?#1%
}
}
\newcommand{\pfourspec}[2]{%
\href{https://p4lang.github.io/p4-spec/docs/P4-16-v1.2.2.html\specsec{#1}}{#2\kern-0.5ex} %Removes weird whitespace???
}

\noindent
This is a description of the \pfott{} formalization of P4, which includes a syntax and a strictly small-step style semantics. It is based on \pfourspec{}{the official P4 specification} and inspired by Core P4~\cite{doenges2021petr4}.

\pfott{} is constructed using the \texttt{ott} tool. \texttt{ott} files can then be exported to \LaTeX{} commands (used in this document) as well as to the HOL4, Isabelle/HOL and Coq interactive theorem provers (of which only the first is currently supported).

%\newpage
\section{Syntax}
\subsection{Types}
\newcommand{\num}{\ensuremath{i}}
\newcommand{\vn}{\ensuremath{x}}
\newcommand{\msg}{\ensuremath{\mathit{msg}}}
\newcommand{\tn}{\ensuremath{\mathit{tbl}}}
\newcommand{\fn}{\ensuremath{f}}
\newcommand{\inte}{\ensuremath{bl}}
%
%TODO Base types (integers, booleans, bit strings, errors, headers...), function types (superset of base types also including tables, functions and constructors) and directions (in, out, inout), ...
%
\begin{figure}[h!]
\centering
\ottmetavars
\caption{Variables}
\label{fig:vars}
\end{figure}

The variables shown in Figure~\ref{fig:vars} are standard designations for variables of \pfourspec{sec-base-types}{P4 base types} included in \pfott{}, plus the numerals \num{} and the indices $m, n, o$ which are not part of the P4 syntax, but used on a meta-level throughout this formalization. Depending on the context, strings are denoted with \vn{} (variable or parser state name), \tn{} (match-action table name) or \fn{} (function or field name). \inte{} is a list of Boolean values, used to represent bit-strings of fixed width.

P4 types are sometimes explicitly referenced in the syntax, e.g. in declaration statements. The notation for this is shown in Figure~\ref{fig:types}.

\begin{figure}[h!]
\centering\ottgrammartabular{
\otttau\ottafterlastrule
}
\caption{Types}
\label{fig:types}
\end{figure}

%\newpage
\subsection{Expressions}
\newcommand{\fmap}{\textit{F}}

\pfott{} includes a subset of the full set of P4 expressions found in {\pfourspec{sec-exprs}{Section 8}} of the P4 specification, shown in Figure~\ref{fig:exp}.

\begin{figure}[h!]
\centering\ottgrammartabular{
\ottv\ottafterlastrule
}
\caption{P4 Values}
\label{fig:val}
\end{figure}

\begin{figure}[h!]
\centering\ottgrammartabular{
\otte\ottafterlastrule
}
\caption{P4 Expressions}
\label{fig:exp}
\end{figure}
\newcommand{\stmt}{\textit{stmt}}
\newcommand{\cval}{\ensuremath{v}}
\newcommand{\fexec}[1]{\textbf{exec}\,\,#1}

First, an expression can be a value $v$, the types of which are shown in Figure~\ref{fig:val}. Lists of expressions can be used in initialisation of variables of struct types. The fields of these structs may be accessed, which is denoted in the usual manner. There exist unary and binary arithmetic operations, where the semantics of the individual operations are defined on some subset of the constants\footnote{The concrete syntax of the many unary and binary operations is found in Appendix~\ref{app:op}}. Bitstrings can be concatenated and sliced. The function call is built from the function name \fn{}, and a list of arguments (expressions).

The \textbf{select} expression is similar to a switch statement in C or Java. The expression $e$ is evaluated, and then matched against $v_1 , \ldots , v_n$. If some match is successful, the \textbf{select} expression evaluates to the string at the corresponding index. If no match occurs, then it instead evaluates to the default string $x$.

Furthermore, structs and headers can also have expression values assigned to their keys, and so be expressions (separate from the struct and header values).

\newpage
\newcommand{\accept}{``accept''}
\newcommand{\reject}{`reject''}
\subsection{Statements} \label{ssec:stmt}

\begin{figure}[h!]
\centering\ottgrammartabular{
\ottstmt\ottafterlastrule
}
\caption{P4 Statements}
\label{fig:stmt}
\end{figure}

\pfott{} includes a subset of the full set of P4 statements found in \pfourspec{sec-stmts}{Section 11} of the P4 specification, shown in Figure~\ref{fig:stmt}. The statements in Figure~\ref{fig:stmt} can be found in the specification, with the following exceptions: the block, verify, apply and extern statements. The block statement features an additional list of declarations (note the absence of declarations from this syntax, in contrast to the P4 specification), the apply statement features the list of arguments that are to be matched (which is possible to resolve at compile time), and the extern captures the semantics of an extern function or method. The \textbf{verify} statement (modeled as a statement and not as an extern function as in \pfourspec{sec-verify}{Section 12.7} of the P4 specification) can be found uniquely in a parser block. It asserts the expression $e$ and if it holds, does nothing. If $e$ does not hold, it jumps to the \reject{} parser state with the error message being the result of evaluating $e'$.

\begin{figure}[h!]
\centering\ottgrammartabular{
\ottlval\ottafterlastrule
}
\caption{P4 l-values}
\label{fig:lval}
\end{figure}

$lval$s are shown in Figure~\ref{fig:lval} and include variables identified by their names, a null variable (used to model method calls) and struct fields, which are identified by the struct and field names, similar to the field access expression.

\newpage
\newcommand{\exstate}{\ensuremath{s}}
\newcommand{\astate}{\ensuremath{{\gamma}_A}}
\newcommand{\currsf}{\ensuremath{\varepsilon}}
\newcommand{\gscope}{\ensuremath{{\gamma}_G}}
\newcommand{\gscopel}{\ensuremath{\overline{\gamma_G}}}
\newcommand{\escope}{\ensuremath{{\gamma}_{\emptyset}}}
\newcommand{\cstack}{E}
\newcommand{\status}{\ensuremath{t}}
\newcommand{\running}{\textbf{run}}
\newcommand{\returnst}[1]{\ensuremath{\textbf{ret}\;#1}}
\newcommand{\trans}[1]{\ensuremath{\textbf{tra}\;#1}}
\newcommand{\sterr}{\ensuremath{\bot}}
\newcommand{\pfin}{\ensuremath{p_{\mathrm{fin}}}}
\newcommand{\expr}{\ensuremath{e}}
\newcommand{\varstar}{\mathbf{var} ( \mathbf{star} , funn )}
\newcommand{\scope}{\gamma}
\newcommand{\scopeL}{\overline{\gamma}}
\newcommand{\stmtL}{\overline{stmt}}
\newcommand{\cons}{, ... \, ,}
\newcommand{\concat}{{+}\mspace{-8mu}{+}}
\newcommand{\funn}{\ensuremath{funn}}
\newcommand{\bitv}{\ensuremath{bitv}}
\newcommand{\estmt}{\emptyset_{ \mathrm{stmt} }}
\newcommand{\frameL}{\overline{\Phi}}
\newcommand{\declL}{\overline{decl}}

\subsection{Execution State}

\begin{figure}[h!]
\centering\ottgrammartabular{
\ottstatus\ottinterrule
\ottstate\ottafterlastrule
}
\caption{P4 Execution State}  %TODO: update this section
\label{fig:status}
\end{figure}

The P4 execution state is shown in Figure~\ref{fig:status}. Note that a ``P4 execution state'' is not defined in the P4 specification, so it is entirely an artifice of the \pfott{} implementation. In short, the execution state \exstate{} is a tuple of the architectural state \astate{}, the global scope list $\scopeL_G$, a frame list $\frameL$, and the state status \status{}. 

\subsubsection*{Single scope}
More formally, a scope $\gamma : X \hookrightarrow V * (X \cup \{ \bot \} )$ is a partial function from variable names $\vn{} \in X$ to constant values $\cval{} \in V$. The following operations can be performed on $\scope$:
%TODO Notation for the below
\begin{itemize}
\item $\mathrm{dom} ( \gamma )$: Gets the domain of $\gamma$: obtains the set of variable names $\vn{} \in X$ which are mapped to values in $\gamma$.
\item $(\vn \mapsto  \cval) \,\, \gamma$: Updates a variable mapping in $\gamma$: yields the scope $\gamma'$, which is just $\gamma$ where \vn{} instead maps to \cval{}. By writing $\forall i \leq n. \,\, ({\vn}_i \mapsto  {\cval}_i) \,\, \gamma$ we extend this to lists of mappings from variable names to values.
\end{itemize}

\subsubsection*{Scope list}
$\scopeL$ is a list of scopes $\scope_1 \cons \scope_n$ where the index 1 is the most recent scope, and $n$ is the oldest.

\subsubsection*{Global scope list}
The global scope list \gscopel{} contains two elements; index 0 represents the programmable block local scope, while index 1 represents the global scope of the architecture. Initially, for each function declared globally in the architecture or locally in a programmable block there must exist a return value in the proper index of \gscopel that adheres with the location of the function declaration.

%The current scope - that which was most recently entered by execution - is stored on the top of \currsf{}  (note that this indexing is the reverse of what you would expect from a list). Whenever a new block (delineated by $\{ \}$) is entered, a new fresh scope \escope{} is pushed onto the frame $\currsf$. %TODO New notation for pushing?

%
% TODO update operations here and in the scope.
%

%The following operations can be performed on a list of scopes $\scopeL$:
%\begin{itemize}
%\item $ \gamma :: \scopeL $: Add a scope $\gamma$ to the list $\scopeL$ (i.e. cons).
%TODO Append (++)
%\item Concatenating two $\gamma$ frames together.
%TODO Tail tl
%\item $(\num \mapsto  \gamma) \,\, \currsf$: Updates the scope located at index \num{} of \currsf{} by setting it to $\gamma$.
%\end{itemize}

%The call stack $\cstack$ is a stack of frames used whenever a function call occurs. When a function call is executed, the frame \currsf{} (minus the global scope \gscope{}) of the caller will be pushed onto $\cstack$. When the callee function finishes execution and returns, \currsf{} will be popped from $\cstack$ and pushed onto a frame containing only \gscope{}. Note that this means that the same \gscope{} is kept throughout function calls, and updates to it are passed along accordingly. The following operations can be performed on $\cstack$: 
%\begin{itemize}
%\item $ \currsf :: \cstack$: Pushes a frame $\currsf$ onto the call stack $\cstack$.
%\end{itemize}

\subsubsection*{List of statements}
The list of statement $\stmtL$ is simply a list of $stmt_1 \cons stmt_n$ where $stmt_1$ is the most recent block we have enetered, and $stmt_n$ is the oldest one.

How do we use the list of statement notion? Whenever a block $\{ \declL \ stmt \} ; stmt_{old}$ is encountered, the block's statement $stmt$ will be appended to the old statement $stmt_{old}$ and leaves an empty statement in it's original place. So the next transition will become $stmt::(\emptyset_{stmt}; stmt_{old} $ 


\subsubsection*{Function name}
Function name $funn$ identifies the function name or the extern object instantiation. In P4, functions can be declared globally, or locally in the programmable block (actions). We model the actions exactly as the functions, and to distinguish between them we store their signatures and bodies in two different locations. The (programmable block locally declared functions) signature and body in the mapping $F_b$. The (globally declared functions and actions) signatures and bodies are stored in the mapping $F_g$. Both function block mapping $F_b$ and global block mapping $F_g$ are stored in the context $ctx$ which will be discussed later.


\subsubsection*{Frame}
The frame $\Phi$ is a tuple of three members: a statement list $\stmtL$, a function name $funn$, and a local to the frame scope list $\scopeL$. Overall, a frame $\Phi$ is represented as $ \stmtL^{funn}_{\scopeL{}} $ .Whever a function call occurs, the callee function will be appeneded to the caller as $\Phi_{callee} :: \frameL $.


\subsubsection*{Control plane configuration}
It is a function that takes a table name $tbl$, the key list expressions $e_1 \cons e_n$, and a list of matching kinds $mk_1 \cons mk_n$ then returns the actions and their arguments. This ill be explained further in the statements semantics.

\subsubsection*{Status}
Represented in the state with $t$. The status \running{} represents that the program is executing under regular circumstances. \returnst{v} is used when the \textbf{return} statement returns a constant \cval{} at the end of a function call. The status \trans{\vn{}} signifies transition to a new parser state. The new parser state can be a final state in the case of \trans{\vn{accpet}} or \trans{\vn{reject}}, or otherwise a state defined by the programmer. \sterr{} represents a crash or undefined behaviour, for example caused by some badly-typed part of the program. 


\subsubsection*{Context}
 The $ctx$ is a tuple of the following: 
\begin{enumerate}
   \item $X$ external object map. It maps extern object names to tuples of constructors and their respective function maps.
   \item $F_g$ globally declared function map. It maps global function and actions names to tuples of their bodies, argument names and directions. 
   \item $F_b$ programmable block locally declared functions.  It maps local function names to tuples of their bodies, argument names and directions. 
   \item $P$ parser states map. It maps the name of the parser state to the body of that state name.
   \item $Tb$ the table match-kind map. It maps the table name to its list of matching kinds.
\end{enumerate}

The context $ctx$ assumed to be static, therefore not part of the execution state.




%%%%%%%%%%%%%%%%% CALLING CONVENTION
\newpage
\subsection{Calling convention}   
The calling conventions can be directioned or directionless. The direction can be either IN, OUT or INOUT. 
IN direction summary:
\begin{enumerate}
    \setlength{\itemsep}{1pt}
    \setlength{\parskip}{0pt}
    \setlength{\parsep}{0pt}
\item Should not be used on the left hand of assignment
\item Shouldn't be passed to a function without using the proper calling convention IN
\item Initialized by copying the value of the corresponding argument when the invocation is executed.
\end{enumerate}
OUT summary:
\begin{enumerate}
    \setlength{\itemsep}{1pt}
    \setlength{\parskip}{0pt}
    \setlength{\parsep}{0pt}
\item usually uninitialized, and treated as l-values. after the execution of the call, the value of the OUT parameters copied to the corresponding location of the l-value. OUT parameters are initialized in the following cases
\begin{enumerate}[label=(\alph*)]
\item if the types are header or header\_union, OUT parameter is set to "invalid"
\item if the type is a header stack, then all elements of the header stack set to "invalid" and the next index is initialized to 0.
\item if the type is compound (e.g. struct or tuple) apply the rules recursively to its members.
\item if any any other type than listed above (e.g. bit <W>), then it doesn't need any predictable value.
\end{enumerate}
\end{enumerate}

INOUT summary:
\begin{enumerate}
    \setlength{\itemsep}{1pt}
    \setlength{\parskip}{0pt}
    \setlength{\parsep}{0pt}
\item this type of parameters are both IN and OUT.
\item it must be an l-value, which means it can be assigned to a value.
\end{enumerate}
NO direction summary:
\begin{enumerate}
    \setlength{\itemsep}{1pt}
    \setlength{\parskip}{0pt}
    \setlength{\parsep}{0pt}
\item those parameters are known at compile time.
\item it also can be an action parameter, can be set by the control plane.
\item it also can be an action parameter that set directly by an other action, then the behaviour will be like IN parameter.
\end{enumerate}

The direction d can be $\downarrow$ denotes IN, $\uparrow$ denotes OUT, $\updownarrow$ denotes INOUT, $\circ$ denotes directionless. 

Thus,
d ::= $\downarrow$ | $\uparrow$ | $\updownarrow$ | $\circ$

Due to the calling conventions, the scope has the type; $ \scope : X \hookrightarrow V * (X \cup \{ \bot \})  $ .

The list of scopes is identified with an arrow following $\scopeL$.
The local $\scopeL$ is meant to be a local list of scopes to the frame. The global $\scopeL_G$ is a list with a length of 2. The first index determines the external architecture scope (can not be defined by a P4 program), while the second index determines the architecture local variables (defined in the architecture level).
Opeations on list of scopes:
\begin{enumerate}
    \setlength{\itemsep}{1pt}
    \setlength{\parskip}{0pt}
    \setlength{\parsep}{0pt}
\item Operation $\scope [\vn \longmapsto v]$ to update a variable name \vn{} with value \cval{} in the scope $\scope$. 
\item Operation $\scopeL [\vn \longmapsto v]$ to update a variable name \vn{} with value \cval{} in the most recent scope that contains the variable name \vn{}.   
\item Operation $lookup_v(\scopeL, \scopeL_G, \vn)$ to return the value \cval{} of the tuple $(y, x \cup {\bot})$, which is whatever variable x is mapped to in the most recent scope it is defined in after concatenating $\scopeL_G \concat \scopeL$. 
\end{enumerate}







\newpage

\section{Semantics}

\subsection{Expressions}\label{sec:expsem}
Expression semantics and reductions are layed out in this section. Overall, the reductions can never alter or have any side effects on the state. The only thing it can perform is a reduction on the expressions -standard small step structural semantics- and also produce a new frame -which occurs only in the function call reduction-.  


\subsubsection*{variable lookup}
In the \textsc{e\_lookup} rule, the lookup function ensures that the variable name \vn{} is evaluated in the uppermost (i.e. most recently scope $\scope$ that \vn{} exists in). The evaluation will occur using the function $\mathrm{lookup}_v$. It will sweep the list of scopes $\scopeL \concat \scopeL_G$ and finds the most recent scopes -most left- that contains variable $x$ and this is because the scopes grows from right to left in the list. This agrees with the description in Sections \pfourspec{sec-name-resolution}{6.8} and \pfourspec{sec-variables}{10.2} of the P4 specification. The constant value of this variable is then returned to the expression rediction.

\begin{figure}[ht!]
    \ottusedrule{\ottdruleeXXlookup{}} 
\end{figure}



\subsubsection*{function call}
Note that function calls also include actions as well as extern function calls.

The \textsc{e\_call\_args} is used whenever there is a function call expression with unreduced (in and none directioned arguments). We fetch the function name's argument names and directions using $\mathbf{lookup\_funn\_sig}$, then each function's argument will be checked against the function's direction in the same position. If the direction is in or none, then it will be reduced until it becomes a constant, otherwise if the argument has the direction out or inout then do not reduce it.

The \textsc{e\_call\_newframe} rule is used when all of the function arguments have been reduced to constants (for non-out directions) or variables (directions with out). The function call reduction will produce a placeholder we call $\varstar$ and a new frame. The new frame will be later added on top of the state's frames in the statements reduction rules. 
The way that this new frame is constructed is as follows: The function name \funn{} will be the same as the call in the expression. The function name \funn{} will be looked up in both the function maps and extern maps to retrieve the function body \stmt{}  and the signature of the parameters represented as a list of tupels: variable names and their directions $ [(\vn{}_1, d_1) \cons (\vn{}_n, d_n) ] $. Each argument will be checked against the boolean formula to ensure that the arguments were reduced properly: (if $d_i$ in-none then the expression in the same position should be a constant, otherwise a variable name). The new frame's scope $\scope'$ is a new fresh empty scope that contains the copied in arguments using the function $\mathbf{copyin}$.

\begin{figure}[ht!]
    \ottusedrule{\ottdruleeXXcallXXargs{}} \\
    \ottusedrule{\ottdruleeXXcallXXnewframe{}}
\end{figure}


\subsubsection*{headers and structs}
The struct can be an expression, thus we need reductions for it. The rule \textsc{e\_eStruct} rule will reduce the expression feilds one at a time from left to right. One all the expressions become constants then we can transform the expression struct to a value struct via \textsc{e\_eStruct\_to\_v} which will be used mostly in header access. Same extact operations are applied on the headers.

\begin{figure}[ht!]
    \ottusedrule{\ottdruleeXXeStruct{}} \\
    \ottusedrule{\ottdruleeXXeStructXXtoXXv{}} \\
    \ottusedrule{\ottdruleeXXeHeader{}} \\
    \ottusedrule{\ottdruleeXXeHeaderXXtoXXv{}}
\end{figure}


\subsubsection*{access headers and structs}
The \textsc{e\_s\_acc} rule is used to access the values of fields in structs, and the \textsc{e\_h\_acc} rule is similarly used for headers.

\begin{figure}[ht!]
    \ottusedrule{\ottdruleeXXsXXacc{}} \\
    \ottusedrule{\ottdruleeXXhXXacc{}} 
\end{figure}


\subsubsection*{select label}
The \textsc{e\_sel\_acc} rule is used to match the given value $\cval$ against the label-value list, in the case a match exists. If the match doesn't exist, then return the default label \vn.

\begin{figure}[ht!]
    \ottusedrule{\ottdruleeXXselXXacc{}}
\end{figure}



\subsubsection*{bit slicing}
This reduction gives a bitvector $\bitv'''$ that is reduced from the slicing operation. It extracts a contiguous list from the opriginal $\bitv$ from the lsb \bitv'' till the msb \bitv'.

\begin{figure}[ht!]
    \ottusedrule{\ottdruleeXXsliceXXv{}}
\end{figure}




\subsubsection*{concatenation}
The reduction produces one bit string $\bitv''$ that is the result of concatenating two bit strings $\bitv$ and $\bitv'$.

\begin{figure}[ht!]
    \ottusedrule{\ottdruleeXXconcatXXv{}}
\end{figure}




\subsubsection*{unary and binary}
Unary and binary operations are basically standard operations on bit vectors, therefore are removed from this section.  



%%%%%%%%%%%%%%%%% statement semantics   
\subsection{Statement (single frame) semantics}
The semantics of the statements are presented in this section. \footnote{Rules for reducing expressions in all contexts are found in Appendix~\ref{app:exp}}.


\subsubsection*{assignment}
The assignment can assign to $lval$s (shown in Figure~\ref{fig:lval}), they can be either variable identified by their names, a null variable (used to model method calls) or struct fields, which are identified by the struct and field names, similar to the field access expression. Whenever an expression is assigned to an $lval$, that expression shall be reduced until it becomes a constant value. Then the appropriate scope in the current frame of execution will be updated with the mapping  $\vn \mapsto v$. With appropriate we mean that the topmost (most recent) scope that the $lval$ is declared in. The reduction results in the empty statement and an updated local or global scope lists. Note that this doesn't apply on $\mathbf{null}$ since it is used for method and action calls with no return values in mind.

\begin{figure}[ht!]
    \ottusedrule{\ottdrulestmtXXassXXv{}}
\end{figure}

\subsubsection*{if then else}
The \textsc{stmt\_cond2} and \textsc{stmt\_cond3} rules are the standard ones for conditional statements.

\begin{figure}[ht!]
    \ottusedrule{\ottdrulestmtXXcondTwo{}} \\
    \ottusedrule{\ottdrulestmtXXcondThree{}} 
\end{figure}


\subsubsection*{block}
Once a block statement is encountered $ \{ \declL \ stmt \}$ the \textsc{stmt\_block\_enter} reduction will be used, it entails the $\declL{}$ being transformed and replicated into a scope that will be appended to the local $\scopeL{}$ of the frame, and then the body $stmt$ of the block will be appended to the empty statement. 


The \textsc{stmt\_block\_exit} rule is used in the case where the end of a block is reached, i.e. whenever a block contains only an empty statement: it pops the scope corresponding to the block (the most recent one) from the scope list $\scopeL$. The block will be exited and reduced to an empty statement $\estmt{}$ .


The \textsc{stmt\_block\_exec} rule simply describes small-step reduction of the block contents. We also check if the previous list $\stmtL$ is empty or not, if it is empty, then directly apply the other single block statement rules. It is also important to check that the head of the list $stmt::\stmtL$ is not empty statement $\estmt{}$  otherwise it is non-deterministic with the block exit rule. 

\begin{figure}[ht!]
    \ottusedrule{\ottdrulestmtXXblockXXenter{}} \\
    \ottusedrule{\ottdrulestmtXXblockXXexec{}} \\
    \ottusedrule{\ottdrulestmtXXblockXXexit{}} 
\end{figure}


\subsubsection*{apply} 
The \textsc{stmt\_apply\_v} describes the apply table statement. Each apply statement has a table name $tbl$ with the a list of key expressions $\expr_1 \cons \expr_n$ to match on. This list have been previously reduced to constants one at a time in the rule \textsc{stmt\_apply\_e}. The Tb will return a list of match kind $mk_1 \cons mk_n$. The ctrl is a function that maps table names $tbl$, expressions, and the match kinds to action that should be implemented as a method call, with a list of the arguments $\cval_1 \cons \cval_m $ .


\begin{figure}[ht!]
    \ottusedrule{\ottdrulestmtXXapplyXXtableXXe{}} \\
    \ottusedrule{\ottdrulestmtXXapplyXXtableXXv{}} 
\end{figure}

\subsubsection*{return}
Once return's expression is reduced to a constant value, the status is changed to a \returnst{} \cval, and the statement becomes $\estmt{}$. The rest of the return operatoin will be handeled in the sequence and composition rules.

\begin{figure}[ht!]
    \ottusedrule{\ottdrulestmtXXretXXv{}} 
\end{figure}

\subsubsection*{sequential statements}
The sequential statements rules \textsc{stmt\_seq1} and \textsc{stmt\_seq2} are standard. The status \status{} must be \running{} to start with. The part that is different is that if any new frame being created by any function call or a statement added to the statement list, it will be added on top of the frame list. \\

Otherwise, the \textsc{stmt\_seq3}  rule is used whenever the status is \returnst{}, or \trans{} to indicate either a a transition to a parser state or a return from a function call. The rest of the sequential composition statements are not considered, this will give flexibility to the return or transition statements in the body rather than only at the end.
\textsc{stmt\_seq1} and \textsc{stmt\_seq3} are able to change the tables that are populated by the control plane.

\begin{figure}[h!]
    \ottusedrule{\ottdrulestmtXXseqOne{}} \\
    \ottusedrule{\ottdrulestmtXXseqTwo{}} \\
    \ottusedrule{\ottdrulestmtXXseqThree{}}
\end{figure}


\subsubsection*{extern}
The symbol $\blacksquare$ represents a statement capturing the semantics of an extern function other than copy-in copy-out and return behaviour. $\blacksquare$ is able to modify the global scope list $\gscopel$, the local scope list $\scopeL$ and the control plane configuration $C$. The exact behaviour is determined by looking up the entry of the name $\mathit{funn}$ associated with the current frame in the extern function map $X$: since $\blacksquare$ is used in extern function call bodies, $\mathit{funn}$ is the name of the extern function.

Note that calling an extern function works the same as calling any other function, as described in the function call subsection of Section~\ref{sec:expsem}. However, by convention the body of the extern function consists only of $\blacksquare$, possibly followed by a \textbf{return} statement if the extern function in question has any return value.

\begin{figure}[ht!]
    \ottusedrule{\ottdrulestmtXXext{}}
\end{figure}

\subsubsection*{transition}
The transition statement $\mathbf{transition} \; \vn $, whose semantics is captured by the \textsc{stmt\_trans} rule, makes a change to the state's status \status{} based on the state name \vn{}.

\begin{figure}[ht!]
    \ottusedrule{\ottdrulestmtXXtrans{}} 
\end{figure}



\subsubsection*{verify}
The $\mathbf{verify} \, \expr \, \expr'$ statement is used to check the whether the boolean expression $\expr$ holds; if it does, then nothing happens, as in the \textsc{stmt\_verify\_3} rule. Otherwise, it assigns the error in $\expr'$ to $"parseError"$ and reduces the statement to a $\mathbf{transition}$ statement to the state \reject{}.
 
\begin{figure}[ht!]
    \ottusedrule{\ottdrulestmtXXverifyXXThree{}} \\
    \ottusedrule{\ottdrulestmtXXverifyXXFour{}} 
\end{figure}



\subsection{list of frames semantics}
The previous semantics operate on a single frame for a list of statements, however when a function being called, then it means that the state will contain two frames. The top frame that will be executed as can be seen in \textsc{frames\_comp1} reduction, where the previous frame $\Phi$ is not empty (otherwise, we can use the previous rules above). 

The rule \textsc{frames\_comp2} is used specifically whenever there is a return occuring in a frame in that is being reduced. Here the the global scope list $\scopeL_G$ must contain a $\varstar$ declared for every function $funn$. This variable should be updated with the value $v$ that is found in the state's status $\returnst{v}$. The copy out function takes the callee function signature, the "possibly updated" global scope list (index 0 or 1 from depends on the location of $\varstar{}$), the top most scope in the $\scopeL''$ and the callee's current scope list $\scopeL$. It returns a new updated scopes list for both the global and caller's frame.

In the copyout function, each parameter with (out or inout directions) should be copied out to the variable name it is mapping to. i.e. the mapping of a single scope looks as  $ \vn \mapsto (v , y) $ so for each variable name $\vn$ that is part of the current argument list in the signature we will check the direction of it, if the direction is (none or in) then we do not copy them out. However, if the direction is (out or inout) we will look into the mapping of it, and retrive a tuple $(v,y)$ which is the value and the original argument of the function to be copied out in the poroper scope (top most one it is defined in).


\begin{figure}[ht!]
    \ottusedrule{\ottdruleframesXXcompOne{}} \\
    \ottusedrule{\ottdruleframesXXcompTwo{}}
\end{figure}


We define scopes\_to\_pass $ ( funn, F_g , F_b , \overrightarrow{\gamma_G}) $ as : \vspace{10pt}

 $  \overrightarrow{\gamma_G}' =\begin{cases}
            \mathrm{if} \; funn \in dom(F_g)    \hspace{6pt} ,
            \mathrm{then} \; [ \emptyset_{\gamma} ; \overrightarrow{\gamma_G}[1] ] \\
            \mathrm{otherwise}    \hspace{48pt}     , 
            \mathrm{then} \; \overrightarrow{\gamma_G} 
        \end{cases}$     \vspace{10pt}

Where $\overrightarrow{\gamma_G}$ is a list of two elements, index 1 is the global scope, and index 0 is the programmable block global scope, it is fetched from the frame reduction rule and considered to be the initial global scope list. $\overrightarrow{\gamma_G}'$ is the scope that will be used to implement one frame at a time (statement reduction) in \textsc{frames\_comp1}.

We define scopes\_to\_retrieve $( funn, F_g , F_b , \overrightarrow{\gamma_G}, \overrightarrow{\gamma_G}')$ as : \vspace{10pt}

 $  \overrightarrow{\gamma_G}'' =\begin{cases}
            \mathrm{if} \; funn \in dom(F_g)    \hspace{6pt} ,
            \mathrm{then} \; [\overrightarrow{\gamma_G}[0];\overrightarrow{\gamma_G}'[1]]  \\
            \mathrm{otherwise}    \hspace{48pt}     , 
            \mathrm{then} \; \overrightarrow{\gamma_G}' 
        \end{cases}$   \vspace{10pt}

Where $\overrightarrow{\gamma_G}''$ is a list of two elements, index 1 is the global scope, and index 0 is the programmable block global scope, and we will retrieve it to be added as the resulted scope of the frame reduction.
$\overrightarrow{\gamma_G}'$ is the scope that is resulted from the statement reduction. 
$\overrightarrow{\gamma_G}$ is the original (initial) starting state's global list of the frame reduction. 









%\newpage
%\newcommand{\start}{\textit{start}}
%\subsection{Parser Block Semantics}
%The parser programmable block is a part of the P4 pipeline which is generally used to parse packets from bit-string representations to structures of parsed headers, described in \pfourspec{sec-control}{Section 13} of the P4 specification. It can be thought of as describing a state machine with three unique states: a \start{} state, an \accept{} state and a \reject{} state. A parser state $p$ (including \start{}, but not the abstract final states of \accept{} and \reject{}) consists of a list of statements to be executed, with a transition statement at the end which decides the parser state to jump to next.
%
%\begin{figure}[ht!]
%\begin{ottdefnblock}{$\ottsym{[}  \ottnt{stmt}  \ottsym{]}  s  \rightarrow  \ottsym{[}  \ottnt{stmt'}  \ottsym{]}  s'$}{\ottcom{statement semantics}}
%\ottusedrule{\ottdrulestmtXXverifyXXThree{}}
%\ottusedrule{\ottdrulestmtXXverifyXXFour{}}
%\ottusedrule{\ottdrulestmtXXtrans{}}
%\end{ottdefnblock}
%\caption{P4 Parser-Specific Statement Execution Semantics}
%\label{fig:parssemstmtexec}
%\end{figure}
%
%The parser-specific statement semantics is shown in Figure~\ref{fig:parssemstmtexec}. The \textsc{stmt\_verify\_3} and \textsc{stmt\_verify\_4} rules describe the semantics of \textbf{verify}, the expressions having been reduced to values. If the condition holds, the reduction is to the empty statement (i.e. nothing happens and execution continues). If the condition does not hold, reduction is also to the empty statement, but state status is set to \reject{}. The \textsc{stmt\_trans} rules describes reduction of the $\mathbf{transition}$ statement, whose only effect on the state is to set status to indicate next parser state (the \textsc{pars\_state} or \textsc{pars\_t\_fin} rules can then be used next)
%
%\begin{figure}[ht!]
%\ottdefnsparsXXsem
%\caption{Parser Block-Level Semantics}
%\label{fig:semparsexec}
%\end{figure}
%
%The parser state machine semantics is shown in Figure~\ref{fig:semparsexec}.
%
%The \textsc{pars\_stmt} rule performs a single small-step reduction of the current statement (the body of the current parser state), while the \textsc{pars\_state} rule governs transition to the next parser state: if the current statement \stmt{} is reduced to $\stmt{}'$ with the status being \trans{\vn{}} where \vn{} is not \accept{} or \reject{}, the next statement is the body of the parser state with name \vn{}, obtained from the map $P$ from parser state names to parser bodies. The \textsc{pars\_empty} rule covers the special case when the statement semantics runs out of statements in a parser state, in which case the status is set to \reject{}.

%\subsection{Control Block Semantics}
%The control block is a part of the P4 pipeline which is generally used to decide which actions to take (typically forwarding) based on the metadata (headers) which was extracted by the parser, as described in \pfourspec{sec-packet-parsing}{Section 12} of the P4 specification. The two main components of a control block are the match-action tables and the actions themselves. Note that part of the functionality is separated into the control plane, which is interfaced with here using the $\mathrm{ctrl}(table\_name,\ v,\ m\_kind)$ function that takes a table name, constant value and matching kind and obtains an action name $f$ and a list of function arguments ${v_1}, ..., {v_n}$.
%Actions can be thought of roughly as functions with no return values. The action can be called implicitly from the match-action process (i.e. in the table application), or explicitly from another action or a control block, as described in \pfourspec{sec-actions}{Section 13.1.1} of the P4 specification.
%
%The \textsc{apply\_table\_e} rule performs small-step evaluation of the header expression used for the matching.
%
%The \textsc{apply\_table\_v} looks up the table name in the table name map, then uses the result together with the header to be looked up to obtain an action (together with action arguments) from the control plane.
%
%\begin{figure}[ht!]
%\ottusedrule{\ottdrulestmtXXapplyXXtableXXe{}}
%\ottusedrule{\ottdrulestmtXXapplyXXtableXXv{}}
%\caption{Match Action Execution Semantics}
%\label{fig:semmatchaction}
%\end{figure}
%
%\begin{figure}[ht!]
%\ottdefnsctrlXXsem
%\caption{Control Block-Level Semantics}
%\label{fig:semctrl}
%\end{figure}
%
%The statement semantics unique to the control block is shown in Figure~\ref{fig:semmatchaction}. Note that the body of the control block consists of the statements inside the apply block, and that executing a return statement at this level signifies return from the control block as a whole. The block-level semantics of the control block are shown in Figure~\ref{fig:semctrl}, which is the same as the statement semantics, since the termination condition is handled in the architecture-level semantics.

\newcommand{\actx}{\ensuremath{\mathit{ctx}_\mathit{A}}}
\newcommand{\abl}{\ensuremath{\overline{ab}}}
\newcommand{\pbm}{\ensuremath{B_p}}
\newcommand{\ffbm}{\ensuremath{B_{ \mathit{ff}}}}
\newcommand{\aenv}{\ensuremath{\mathit{env}_\mathit{A}}}
\subsection{Architecture-Level Semantics}
The architecture-level semantics is the topmost-level semantics, describing the entirety of the P4 pipeline from input packets to output packets, and it uses the statement semantics for reduction steps inside programmable blocks. The judgment form, shown at the top of Figure~\ref{fig:semarch}, consists of multiple components: starting from the left, an \emph{architectural context} \actx{} (which contains the static componenents not changed by reduction steps) on the left-hand side of the turnstile, which contains the following:
\begin{enumerate}
\item The \emph{architectural block list} \abl{}: an architectural block represents a stage of packet processing. There are four fundamental stages of packet processing in a P4-compatible architecture. First, there are the input (\textbf{inp}) and output (\textbf{out}) stages: these stages just perform translation between the architectural packet format and the generic I/O format (consisting of a list of ports, each with pending packets to be arbitrated/sent off\todo{DL: This currently just a list, not a list of lists. Fix the Ott+HOL4, then \aenv{} below to agree with the description here.})\footnote{The demux block functionality may be modeled as part of the output stage, or it may be its own fixed-function block preceding the output stage}. Second, there are the programmable blocks (parser blocks and control blocks) and the fixed-function block stages. Fixed-function blocks, like their name implies, perform the parts of packet processing in the P4-programmable network element that are actually not P4-programmable.
\item The \emph{programmable block map} \pbm{}, which is a partial map between names of programmable block names (strings) and the all necessary items that model the block in question. This is the block type (parser or control), the list of directed parameters, the block-local function map containing function declared inside the block, a list of declarations of variables done at a block-global level, a statement representing initialisations and instantiations of these block-global variables followed by the body (for parsers, a transition statement pointing to ``start'', for control blocks the content of the apply statement encased in a block), and the parser state map $P$ between parser state names and their bodies (statements)\footnote{Note that \pfott{} represents all parser state bodies as encased in a block by convention} and a table map $\mathit{Tb}$ between names of tables and tuples of expressions and matching kinds. Note that the parser state map is empty for control blocks, as is the table map for parser blocks.
\item The \emph{fixed-function block map} \ffbm{}, which is a partial map between names of fixed-function blocks to the implementation of the fixed function itself, which is a partial function that maps the architectural scope to an updated architectural scope.\todo{DL: Why not include control plane configuration?}
\item The \emph{input function} $f_{ \mathit{in} }$ and the \emph{output function} $f_{ \mathit{out} }$, which are both partial functions from an IO list and the architectural scope to an updated IO list and architectural scope. They are used in the input and output stages.
\item The \emph{programmable block copy-in function} $\mathit{copyin}_{ \mathit{pbl} }$ and the \emph{programmable block copy-out function} $\mathit{copyout}_{ \mathit{pbl} }$: $\mathit{copyin}_{ \mathit{pbl} }$ is a partial function from a list of directed parameters, a list of expression arguments, the architectural scope and the block type to a scope (the block-global scope of the programmable block). $\mathit{copyout}_{ \mathit{pbl} }$ is a partial function from the global scopes list, a list of directed parameters, the architectural scope, the block type and status to an updated architectural scope. Note that these functions are responsible for the copy-in copy-out behaviour of the \textit{parseError} variable in parser blocks.
\item The \emph{extern object map} $X$, which is a partial map from extern object names to tuples of extern function maps (a map holding the extern functions of the object: tuples of directed parameter lists, function bodies, and the extern semantics), and an optional constructor (holding a tuple same as that of the extern function map).
\item The \emph{function map} $F$, which is a partial map from globally-declared function names to tuples of function bodies (statements) and their directed parameter lists.
\end{enumerate}

The states on the left-hand and right-hand sides of the reduction both have the same elements.
\begin{enumerate}
\item The \emph{architectural environment} \aenv{}, which in turn has four components:
\begin{enumerate}
\item The \emph{architectural block index}: This is an index which informs us of which architectural block in \abl{} is currently being reduced.
\item The \emph{input list}, which is a list of incoming packets (represented as tuples of lists of Booleans and numbers signifying input ports)
\item The \emph{output list}, which is the same as the input list, but used for output.
\item The \emph{architectural scope} $\gamma_A$, which is of polymorphic type, and is used for storing things in-between the programmable blocks, as well as things that are not accessible directly by P4 code.
\end{enumerate}
\item The global scope list \gscopel{}, which contains the top-level global scope with constants common to all programmable blocks as well as the block-global scope containing variables declared at the start of progrmamable blocks.
\item The \emph{architecture-level frame list}: this contains either a regular frame list (as described in the statement semantics), or it is a special empty architecture-level frame list ($[ \; ]_A$).\todo[inline]{DL: Three solutions to the problem of recognizing in-progress blocks: (1) add a Boolean in-progress flag to the state, (2) use an architecture-level frame list with this special symbol (2) use a regular empty frame list and special checks in the \textsc{exec} rules. Solution 2 is probably best, since it takes up the least additional space in the rules (no additional premise or tuple element)}\todo{DL: This could be assigned as symbol instead of being called ``\textit{arch\_frame\_list}'' in the judgment}
\item The control-plane configuration $C$, a partial function from strings, values and match kinds to tuples of strings and expression lists.
\item The status, which informs us of whether a parser state machine is finished, or the apply of a control block is finished.
\end{enumerate}

The rules of the architecture-level semantics are the following:
\begin{enumerate}
\item \textsc{arch\_in}: The first antecedent requires that the pending architecture block is \textbf{inp}, and then $f_{ \mathit{in} }$ updates the input list and the architectural scope.

\item \textsc{arch\_pbl\_init}: when the pending architecture block is a programmable block, a new block-global scope $\gamma'$ is created and initialised with the arguments of the programmable block (in the case of a parser block, \textit{parseError} is also initially set to \textit{NoError}). After this, the variables in the list of declarations are declared in $\gamma'$. The final result $\gamma'''$ is appended to the top-level global scope $\gscopel [0]$, forming a new global scopes list $\gscopel'$. Also, the empty architecture frame list is changed to a single frame where the singleton statement list contains the initialisations of the parser block \textit{stmt} followed by the body of the programmable block\footnote{Conventions for how these are represented are mentioned in the explanation of $\pbm$}, the scopes stack contains a single empty scope and the current function name is the name of the programmable block.

\item \textsc{arch\_ffbl} handles the fixed-function block: when the pending architecture block is a fixed-function block with name $x$, the implementation \textit{ff} of the fixed-function is looked-up in \ffbm{} using $x$, after which it is used to update the architectural scope. Also, the architecture block index is incremented.

\item \textsc{arch\_out}: Similar to the above, but the pending architecture block must be \textbf{out}, and then the output list and the architectural scope are updated by $f_{ \mathit{out} }$.

\item \textsc{arch\_parser\_trans}: In case the block at the block index $i$ is a parser block and the current status is \trans{x'}, this rule will obtain the parser state body $\mathit{stmt}'$ of $P(x')$ (where $P$ is the parser state map of the current parser block), and set the next frame to the singleton list of $\mathit{stmt}'$ with $[\escope{}]$ as the scope stack and $x'$ as the current function name, as well as set the status to \running{}.

\item \textsc{arch\_pbl\_exec} describes a reduction step inside a programmable block: the first two premises are there to obtain the content of the statement semantics context. Then, the global block list, the frame list, the control plane configuration and the status are updated by a statement reduction step $\longrightarrow$.

\item \textsc{arch\_pbl\_ret} rule describes the final step of programmable block reduction that reduces to an empty frame list. The first two premises obtain the directed parameters of the block. If $\mathit{state\_fin}$ (termination conditions of the two programmable blocks) holds of the status and frame list (if status was \running{}, it is then set to \trans{``reject"} if we are in a parser block). The block output function $\mathit{out}_{ \mathit{p} }$ proceeds to update the architectural scope (notably dependent on architecture, it copies out the value of $\mathit{parseError}$). Furthermore, the architecture block list index is incremented by 1 and the block-global scope is dropped from the global scopes list.
\end{enumerate}

\begin{figure}[ht!]
\resizebox{.8\linewidth}{!}{
\begin{minipage}{\linewidth}
\ottdefnsarchXXsem
\end{minipage}
}
\caption{Architecture-Level Semantics}
\label{fig:semarch}
\end{figure}


\clearpage
\appendix
\section{Concrete Syntax of Operations}
\label{app:op}
\begin{figure}[ht!]
\centering\ottgrammartabular{
\ottunop\ottafterlastrule
}
\caption{P4 Unary Operations}
\label{fig:unop}
\end{figure}

The unary expressions included are shown in Figure~\ref{fig:unop}. These include all of the unary operations in P4. Boolean negation is only defined on Booleans, the other operations have their standard meanings (note that \pfourspec{sec-bit-ops}{unary plus is a no-op}).

\newpage
\begin{figure}[ht!]
\centering\ottgrammartabular{
\ottbinop\ottafterlastrule
}
\caption{P4 Binary Operations}
\label{fig:binop}
\end{figure}

The binary expressions included are shown in Figure~\ref{fig:unop}. These include all of the binary operations in P4.

\section{Semantics of Expression Reduction}
\label{app:exp}
This appendix describes semantics for reducing expressions in certain contexts. The expression semantics are shown in Figure~\ref{fig:semexp2}. The statement semantics are shown in Figure~\ref{fig:semstmt2}.

\begin{figure}[ht!]
\centering{\begin{ottdefnblock}[#1]{$ [  \ottnt{e}  ] (  \sigma  ) \rightsquigarrow [  \ottnt{e'}  ] (  \sigma'  ) $}{\ottcom{expression semantics}}
%\ottusedrule{\ottdruleeXXfuncXXcallXXargs{}}
%\ottusedrule{\ottdruleeXXaccXXargTwo{}}
%\ottusedrule{\ottdruleeXXaccXXargOne{}}
\ottusedrule{\ottdruleeXXselXXarg{}}
\ottusedrule{\ottdruleeXXunopXXarg{}}
\ottusedrule{\ottdruleeXXbinopXXargOne{}}
\ottusedrule{\ottdruleeXXbinopXXargTwo{}}
\end{ottdefnblock}}
\caption{Expression Reduction-of-Argument Semantics}
\label{fig:semexp2}
\end{figure}

The \textsc{e\_func\_call\_args} rule reduces the leftmost function argument which has yet to be reduced to a constant with one expression evaluation step. The first two antecedents divide the list of arguments into two sub-lists, where the prefix must contain all constants. The head of the suffix is then reduced with one step, after which the corresponding index in the original list of arguments is update with the resulting expression.
\\~\\
\pfourspec{sec-expr-eval-order}{8.1} of the P4 specification states that expressions are evaluated left-to-right. Accordingly, the rules for binary operations - \textsc{e\_binop1} and \textsc{e\_binop2} - are split up so that reduction of the second operand requires that the first operand has been completely reduced to a constant. This is trivial for unary operations (\textsc{e\_unop}).

\begin{figure}[ht!]
\begin{ottdefnblock}{$\ottsym{[}  \ottnt{stmt}  \ottsym{]}  s  \rightarrow  \ottsym{[}  \ottnt{stmt'}  \ottsym{]}  s'$}{\ottcom{statement semantics}}
\ottusedrule{\ottdrulestmtXXretXXe{}}
\ottusedrule{\ottdrulestmtXXassXXe{}}
\ottusedrule{\ottdrulestmtXXcondXXe{}}
\ottusedrule{\ottdrulestmtXXverifyXXeOne{}}
\ottusedrule{\ottdrulestmtXXverifyXXeTwo{}}
\end{ottdefnblock}
\caption{Statement Reduction-of-Argument Semantics}
\label{fig:semstmt2}
\end{figure}

\printbibliography

\end{document}


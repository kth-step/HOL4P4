\documentclass[UTF8]{article}
%\documentclass[a4paper,11pt,reqno]{amsart}

\pagestyle{headings}
\usepackage{graphicx}
\usepackage[english]{babel}
\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}
\usepackage{verbatim}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{pstricks}
\usepackage{mathrsfs}
\usepackage{textcomp}
\usepackage{tikz}
\usepackage{subfig}
\usepackage{fancyvrb}

\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=cyan,
}

\usepackage{csquotes}
\usepackage[backend=biber]{biblatex}
\usepackage{todonotes}

\usepackage{supertabular}
\usepackage{geometry}
\usepackage{ifthen}
\usepackage{alltt}%hack

\include{p4_defs}

\addbibresource{p4.bib}
\newtheorem{thm}{Theorem}
\newtheorem{lemma}{Lemma}

\title{%
Pen-and-paper semantics for P4}
\author{Anoud Alshnakat\\
Didrik Lundberg
}
\date{\today}
\begin{document}
\maketitle
\noindent
This is a pen-and-paper semantics of P4, based on \href{https://p4.org/p4-spec/docs/P4-16-v1.2.1.html}{the official P4 specification} and inspired by Core P4~\cite{doenges2021petr4}.

%\newpage
\section{Syntax}
\subsection{Types}
\newcommand{\num}{\textit{num}}
\newcommand{\str}{\textit{x}}
\newcommand{\inte}{\textit{n}}
%
%TODO Base types (integers, booleans, bit strings, errors, headers...), function types (superset of base types also including tables, functions and constructors) and directions (in, out, inout), ...
%
\begin{figure}[h!]
\centering
\ottmetavars
\caption{Primitive Types}
\label{fig:types}
\end{figure}

The types shown in Figure~\ref{fig:types} are the subset of P4 types included in this formalization and their standard designations, plus the numerals \num{} and the indices which are not P4 types, but used throughout this formalization. A string \str{} can be used as a function name or a variable name. The integer \inte{} is a 64-bit word.

\newpage
\subsection{Expressions}
\newcommand{\fmap}{\textit{F}}

Our formalization includes a subset of the full set of P4 expressions found in \href{https://p4.org/p4-spec/docs/P4-16-v1.2.1.html#sec-exprs}{Section 8} of the P4 specification.

\begin{figure}[h!]
\centering\ottgrammartabular{
\ottexp\ottafterlastrule
}
\caption{P4 Expressions}
\label{fig:exp}
\end{figure}

The expressions included are shown in Figure~\ref{fig:exp}. First, an expression can be a Boolean or an integer (collectively referred to as constants), or a string. There exist unary and binary arithmetic operations, where the semantics of the individual operations are defined on some subset of the constants. The function call is built from the function name \str{}, and a list of arguments (expressions). Function execution is not found in any P4 program, but is rather an artifact of our semantics, signifying the in-progress execution of the body of a called function. The concrete syntax of unary and binary operations is found in Appendix~\ref{app:op}.

\newpage
\subsection{Statements}
\newcommand{\stmt}{\textit{stmt}}
\label{ssec:stmt}
See \href{https://p4.org/p4-spec/docs/P4-16-v1.2.1.html#sec-stmts}{Section 11} of the P4 specification.

\begin{figure}[h!]
\centering\ottgrammartabular{
\ottstmt\ottafterlastrule
}
\caption{P4 Statements}
\label{fig:stmt}
\end{figure}

\newpage
\newcommand{\state}{\Sigma}
\newcommand{\scope}{\ensuremath{\mathit{scope}}}
\newcommand{\stacks}{\sigma}
\newcommand{\currsf}{\ensuremath{\varepsilon}}
\newcommand{\gscope}{\ensuremath{\currsf [0] }}
\newcommand{\cstack}{E}
\newcommand{\status}{\textit{status}}
\subsection{Execution State}
A scope is a partial function that represents a mapping from variable names as strings to values in a certain scope. The operations that be done on the scopes are:
\begin{enumerate}
\item Finding the domain of a scope. (add math representation here)
\item and updating some variable (or multiple variables) mapping.
\end{enumerate}

The list of scopes $\currsf$ is a list where the global scope variables are stored at the bottom in location $\currsf$[0], whereas the variables of the current scope that being executed are stored on the top $\currsf$, and it is created whenever a new scope$\{ \}$ is entered. The operations that can be done on the list of scopes are (not limited to):
\begin{enumerate}
\item Adding a new scope to the list. (add math representation here)
\item Concatenating two scope frames together.
\item Updating a scope in a certain location (index).
\end{enumerate}

The call stack $\cstack$ is a list of stack frames, used wherever a function call occurs. Whenever the execution reaches a function call, the caller scope in location $\currsf$[i] will be stored in the $\cstack$, and later retrieved from $\cstack$ and store back in $\currsf$[i]. The operations that can be done on the list of scopes are (not limited to): 
\begin{enumerate}
\item Adding a list of scopes to the call stack.
\end{enumerate}

The state memory $\stacks{}$ consists of a tuple of ($\currsf$, $\cstack$), to represent the live variable values of the program at a certain execution point.
\\~\\
The status \textbf{Running} represents that the program is executing under regular circumstances. \textbf{TypeError} represents a crash caused by some badly-typed part of the program. \textbf{Return} is used when the \textbf{return} statement returns a constant inside a function.
\\~\\
The execution state S holds a the state memory $\stacks{}$ and the status. Note that none of these constructs are laid out in the P4 specification, but rather made up by yours truly in order to obtain a formal P4 semantics.
\begin{figure}[h!]
\centering\ottgrammartabular{
\ottstatus\ottinterrule
\ottstate\ottafterlastrule
}
\caption{P4 Execution State}
\label{fig:status}
\end{figure}

\section{Semantics}
\subsection{Expressions}
%\begin{figure}[h!]
%\centering\ottgrammartabular{
%\ottexpXXsem\ottafterlastrule
%}
%\caption{Judgment Forms of P4 Expression Evaluation}
%\label{fig:judgexp}
%\end{figure}

\begin{figure}[ht!]
\centering{\begin{ottdefnblock}[#1]{$ [  \ottnt{exp}  ] (  \sigma  ) \rightsquigarrow [  \ottnt{exp'}  ] (  \sigma'  ) $}{\ottcom{expression semantics}}
\ottusedrule{\ottdruleexpXXlookup{}}
\ottusedrule{\ottdruleexpXXfuncXXcallXXargsOne{}}
\ottusedrule{\ottdruleexpXXfuncXXcallXXargsTwo{}}
\ottusedrule{\ottdruleexpXXfuncXXexec{}}
\ottusedrule{\ottdruleexpXXfuncXXretXXexp{}}
\ottusedrule{\ottdruleexpXXunop{}}
\ottusedrule{\ottdruleexpXXbinopOne{}}
\ottusedrule{\ottdruleexpXXbinopTwo{}}
\end{ottdefnblock}}
\caption{P4 Expression Evaluation Semantics}
\label{fig:semexp}
\end{figure}

The small-step semantics for reducing expressions is shown in Figure~\ref{fig:semexp}.
\\~\\
In the \textsc{exp\_lookup} rule, the first antecedent is a function $index = min  \{ j . x  \in \mathrm{dom} ( $\currsf$ [j] ) $ ensures that the variable name \str{} is evaluated in the uppermost (i.e. most recent entered) scope of \currsf{} where it is declared, by preventing \str{} to be in the domain of any \scope{} higher in \currsf{} than the one used for variable resolution. This agrees with the description in \href{https://p4.org/p4-spec/docs/P4-16-v1.2.1.html#sec-name-resolution}{Sections 6.8} and \href{https://p4.org/p4-spec/docs/P4-16-v1.2.1.html#sec-variables}{10.2} of the P4 specification. The value of this variable is then resolved, and checked to be a constant.\\~\\
The \textsc{exp\_func\_call\_args1} rule reduces the leftmost function argument which has yet to be reduced to a constant with one expression evaluation step. The first two antecedents divide the list of arguments into two sub-lists, where the prefix must contain all constants. The head of the suffix is then reduced with one expression small-step, after which the corresponding index in the original list of arguments is update with the resulting expression.
\\~\\
The \textsc{exp\_func\_call\_args2} rule is used when all of the function arguments have been reduced to constants using \textsc{exp\_func\_call\_args1} (or if they were all constants to begin with). The constants are assigned to their respective argument names in a fresh scope, after which this scope is put on top of the global scope \gscope{} in order to form the new current list of scope frame $\currsf '$. The old current list of scopes frames \currsf{} is then saved on top of the call stack \cstack{} to be used later when returning from the function call, and the function call statement is reduced to $\mathbf{exec} \,\, \mathit{stmt}$ - in-progress execution of the function body \stmt{} (obtained from the function map \fmap{}, which holds mappings between function names \str{} and tuples of function bodies and lists of their argument names). Note that this rule also covers the case of a function call with no arguments.
\\~\\
The \textsc{exp\_func\_exec} rule reduces the function body of in-progess execution with one small-step statement reduction.
\\~\\
The \textsc{exp\_func\_ret\_exp} rule reduces finished (empty) in-progess execution with status $\mathbf{Return} \,\, \mathit{exp}$ to $\mathit{exp}$, provided $\mathit{exp}$ is a constant. This also changes the status to $\mathbf{Running}$.
\\~\\
\href{https://p4.org/p4-spec/docs/P4-16-v1.2.1.html#sec-expr-eval-order}{Section 8.1} of the P4 specification states that expressions are evaluated left-to-right. Accordingly, the rules for binary operations - \textsc{exp\_binop1} and \textsc{exp\_binop2} - are split up so that (small-step) reduction of the second operand requires that the first operand has been completely reduced to a constant. This is trivial for unary operations (\textsc{exp\_unop}).

\newpage
\subsection{Statement Execution}
The SOS of the statements is shown in Figure~\ref{fig:semstmtexec}  
\\~\\
The \textsc{stmt\_ret\_exp} rule implements one reduction to the expression at a time, to simplify the expression until it reduces to a constant. 
Once the \textbf{return} statement appears to return a constant the rule \textsc{stmt\_ret\_const} contains the antecedents that are required for such operation. The global scope is always stored in the location zero of the list of scopes, i.e. $\currsf$[0]. It is fetched and concatenated with most recent caller that was stored on top of the call stack $\cstack$. Thus, this concatenation will generate a $\currsf$ that has the same shape to the one before the function being called (of course before reaching the \textbf{return} statement some global variables could have been changed during function evaluation, that is the reason why we say that the shape is the same but not the variable mappings in the global scope). The status will be changed to \textbf{Return V} where it will be handled later in an other rule. 
\\~\\
The \textsc{stmt\_ass\_exp} rule implements one reduction to the expression at a time, to simplify the expression until it reduces to a constant.
The \textsc{stmt\_ass\_const} rule handles assignment statement. In general, the variables that the program can assign values to it should be in the global scope or the current scope of the frame, thus we need to look up into the current list of scopes $\currsf$, but never into $\cstack$. So the antecedent $index = max  \{ j . x  \in \mathrm{dom} ( $\currsf$ [j] ) $ fetches the proper index that locates the variable location, it should be the one in the lowermost part of the the current list of scopes $\currsf$ (i.e. oldest entry). In the last antecedent, $ (x \longrightarrow V )scope $ updates the mapping of the variable name x to the new value i.e. (constant V) in the proper frame location, that indeed lies in the current list of scope frame. One step reduction in this rule results an updated current list of scopes, and an empty statement to execute.
\\~\\
The \textsc{stmt\_seq1} and \textsc{stmt\_seq2} rules are trivial to understand, they are pretty standard.
\\~\\
The \textsc{stmt\_seq3} handles the \textbf{return} statement when it does not occur at the end of the the function code. The next statement to reduce will be empty and the status will be changed to \textbf{Return} that will be handled later.
\\~\\
The \textsc{stmt\_cond1}, \textsc{stmt\_cond2} and \textsc{stmt\_cond3} rules are pretty trivial to understand.
\\~\\
The \textsc{stmt\_decl} rule is a transition reduction for the declaration statements. Whenever a variable is declared, it will updated in the most recent scope and reduce the transition to an empty statement. The most recent/newest scope is fetched simply by checking the length of the list of scopes $\currsf$. 
\\~\\
The \textbf{\{\}} brackets indicates a block, while the \textbf{[ ]} brackets indicates a block being executed.
Whenever entering a block, in rule \textsc{stmt\_block\_enter}, a new empty scope is added to the list of scopes, and then the \textbf{\{\}} brackets are switched the executing ones \textbf{[ ]} to pinpoint the fact that the statements can be executed now.
\\~\\
\textsc{stmt\_block\_exec} rule shows a small step reduction for the statements inside a block.
\\~\\
\textsc{stmt\_block\_exit} rule handles the block termination. Whenever a block contains an empty statement, then it is necessary to also remove the corresponding scope from the list of scopes $\currsf$ which in the case of blocks is the most recent one.

%\begin{figure}[h!]
%\centering\ottgrammartabular{
%\ottpFourXXparserXXbstmtXXred\ottinterrule
%\ottpFourXXparserXXblockXXred\ottinterrule
%\ottpFourXXparserXXnblockXXred\ottafterlastrule
%}
%\caption{Judgment Forms of P4 Statement Execution}
%\label{fig:judgexec}
%\end{figure}

\begin{figure}[ht!]
\ottdefnsstmtXXsem
\caption{P4 Statement Execution Semantics}
\label{fig:semstmtexec}
\end{figure}

%\begin{figure}[h!]
%\ottdefnspFourXXparserXXstrXXstmtXXred
%\caption{P4 Structural Statement Execution Semantics}
%\label{fig:semstmtexec}
%\end{figure}
%
%\begin{figure}[h!]
%\ottdefnspFourXXparserXXblockXXred
%\caption{P4 Parser State Execution Semantics}
%\label{fig:semblockexec}
%\end{figure}
%
%\begin{figure}[h!]
%\ottdefnspFourXXparserXXnblockXXred
%\caption{P4 $n$-Parser State Execution Semantics}
%\label{fig:semnblockexec}
%\end{figure}

\printbibliography

\clearpage
\appendix
\section{Concrete Syntax of Operations}
\label{app:op}
\begin{figure}[ht!]
\centering\ottgrammartabular{
\ottunop\ottafterlastrule
}
\caption{P4 Unary Operations}
\label{fig:unop}
\end{figure}

The unary expressions included are shown in Figure~\ref{fig:unop}. These include all of the unary operations in P4. Boolean negation is only defined on Booleans, the other operations have their standard meanings (note that \href{https://p4.org/p4-spec/docs/P4-16-v1.2.1.html#sec-bit-ops}{unary plus is a no-op}).

\newpage
\begin{figure}[ht!]
\centering\ottgrammartabular{
\ottbinop\ottafterlastrule
}
\caption{P4 Binary Operations}
\label{fig:binop}
\end{figure}

The binary expressions included are shown in Figure~\ref{fig:unop}. These include all of the binary operations in P4.

\end{document}


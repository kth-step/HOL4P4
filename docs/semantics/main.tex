\documentclass[UTF8]{article}
%\documentclass[a4paper,11pt,reqno]{amsart}

\pagestyle{headings}
\usepackage{graphicx}
\usepackage[english]{babel}
\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}
\usepackage{verbatim}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{pstricks}
\usepackage{mathrsfs}
\usepackage{textcomp}
\usepackage{tikz}
\usepackage{subfig}
\usepackage{fancyvrb}
\usepackage{enumitem}

\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=cyan,
}

\usepackage{csquotes}
\usepackage[backend=bibtex]{biblatex}
\addbibresource{p4.bib}
\usepackage{todonotes}

\usepackage{supertabular}
\usepackage{geometry}
\usepackage{ifthen}
\usepackage{alltt}%hack


\newcommand*{\inference}[3][t]{%
   \begingroup
   \def\and{\\}%
   \begin{tabular}[#1]{@{\enspace}c@{\enspace}}
   #2 \\
   \hline
   #3
   \end{tabular}%
   \endgroup
}

\include{p4_defs}
\newtheorem{thm}{Theorem}
\newtheorem{lemma}{Lemma}

\title{%
The \texttt{HOL4P4} P4 Formalization}
\author{Anoud Alshnakat\\
Didrik Lundberg
}
\date{\today}
\begin{document}
\maketitle

\newcommand{\pfott}{\texttt{HOL4P4}}

\begingroup\lccode`?=`# \lowercase{\endgroup
\newcommand{\specsec}[1]{%
    ?#1%
}
}
\newcommand{\pfourspec}[2]{%
\href{https://p4.org/p4-spec/docs/P4-16-v-1.2.3.html\specsec{#1}}{#2\kern-0.5ex} %Removes weird whitespace???
}

\noindent
This is a description of the \pfott{} formalization of P4, which includes a syntax and a strictly small-step style semantics. It is based on \pfourspec{}{the official P4 specification} and inspired by Core P4~\cite{doenges2021petr4}.

\pfott{} is constructed using the \texttt{ott} tool. \texttt{ott} files can then be exported to \LaTeX{} commands (used in this document) as well as to the HOL4, Isabelle/HOL and Coq interactive theorem provers (of which only the first is currently supported).

%\newpage

\newcommand{\vn}{\ensuremath{x}}
\newcommand{\fn}{\ensuremath{f}}
\newcommand{\tn}{\ensuremath{\mathit{tbl}}}
\newcommand{\inte}{\ensuremath{bl}}
\newcommand{\num}{\ensuremath{i}}
\newcommand{\wid}{\ensuremath{w}}
\section{Syntax}
\subsection{Types and Values}
%TODO directions?

\begin{figure}[h!]
\centering
\ottmetavars
\caption{Variables}
\label{fig:vars}
\end{figure}

The (meta)variables shown in Figure~\ref{fig:vars} are standard designations for the data of \pfourspec{sec-base-types}{P4 base types} included in \pfott{}, plus the numerals \num{} (sometimes \wid{} when referring to width) and the indices $m, n, o$ which are not part of the P4 syntax, but used on a meta-level throughout this formalization. Depending on the context, strings are denoted with \vn{} (variable or parser state name), \fn{} (function or field name) or \tn{} (match-action table name). \inte{} is a list of Boolean values, used to represent bit-strings of fixed width.

Figure~\ref{fig:val} shows the values of our formalisation. This largely mirrors \pfourspec{sec-base-types}{P4 base types}, except for the lack of match kinds, arbitrary-sized constants and bit-strings of dynamically computed width. Notably, some derived types have also been placed here: headers, structs and extern object references as well as the $\bot$ value which is an artifact of our model. Other derived types (tuples, enums, header unions and stacks) are yet to be added to the model, while some (parser, control, package) are not treated as such here, since they cannot be manipulated at run time.

\begin{figure}[h!]
\centering\ottgrammartabular{
\ottv\ottafterlastrule
}
\caption{P4 Values}
\label{fig:val}
\end{figure}

P4 types are sometimes explicitly referenced in the syntax, e.g. in declaration statements. The notation for this is shown in Figure~\ref{fig:types}. $\mathit{struct\_ty}$ can be either \textbf{header} or \textbf{struct}, and $\mathit{num\_exp}$ is an arithmetic expression of type integer. Regular string literals are the special case of an $\mathit{x\_list}$ with length 1.

\begin{figure}[h!]
\centering\ottgrammartabular{
\otttau\ottafterlastrule
}
\caption{Types}
\label{fig:types}
\end{figure}

%\newpage
\newcommand{\funn}{\ensuremath{\mathit{funn}}}
\newcommand{\stmt}{\textit{stmt}}
\newcommand{\cval}{\ensuremath{v}}
\newcommand{\fexec}[1]{\textbf{exec}\,\,#1}
\newcommand{\avn}{\ensuremath{\mathit{varn}}}
\newcommand{\fmap}{\textit{F}}
\subsection{Expressions}

\pfott{} includes a subset of the full set of P4 expressions found in {\pfourspec{sec-exprs}{Section 8}} of the P4 specification, shown in Figure~\ref{fig:exp}.

\begin{figure}[h!]
\centering\ottgrammartabular{
\otte\ottafterlastrule
}
\caption{P4 Expressions}
\label{fig:exp}
\end{figure}

First, an expression can be a value $v$, the types of which were shown earlier in Figure~\ref{fig:val}. An expression can also be a variable, in which case it has an abstract variable name \avn{} which is either the special ``star'' function return placeholder variable, in which case it holds the corresponding \funn{}, or a regular variable, which holds the variable name \vn{}. Lists of expressions can be used in initialisation of variables of struct types. The fields of these structs may be accessed, which is denoted in the usual manner. There exist unary and binary arithmetic operations, where the semantics of the individual operations are defined on some subset of the values\footnote{The concrete syntax of the many unary and binary operations is found in Appendix~\ref{app:op}}. Bitstrings can be concatenated and sliced. The function call is built from the abstract function name \funn{}, and a list of arguments (expressions).

The \textbf{select} expression is similar to a switch statement in C or Java. The expression $e$ is evaluated, and then matched against $v_1 , \ldots , v_n$. If some match is successful, the \textbf{select} expression evaluates to the string at the corresponding index. If no match occurs, then it instead evaluates to the default string $x$.

Furthermore, structs and headers can also have expression values assigned to their keys, and so be expressions (separate from the struct and header values).

\newcommand{\accept}{``accept''}
\newcommand{\reject}{`reject''}
\subsection{Statements} \label{ssec:stmt}

\begin{figure}[h!]
\centering\ottgrammartabular{
\ottstmt\ottafterlastrule
}
\caption{P4 Statements}
\label{fig:stmt}
\end{figure}

\pfott{} includes a subset of the full set of P4 statements found in \pfourspec{sec-stmts}{Section 11} of the P4 specification, shown in Figure~\ref{fig:stmt}. All of the statements in Figure~\ref{fig:stmt} can be found in the specification, with the following exceptions: the block, verify, apply and extern statements. The block statement features an additional list of declarations (note the absence of declarations from this syntax, in contrast to the P4 specification), the apply statement (replacing the apply method in \pfourspec{sec-invoke-mau}{Section 11} of the P4 specification) features the list of arguments that are to be matched to the table \tn{} (which is possible to resolve at compile time), and the extern captures the semantics of an extern function or method. The \textbf{verify} statement (modeled as a statement and not as an extern function as in \pfourspec{sec-verify}{Section 12.7} of the P4 specification) can be found uniquely in a parser block. It asserts the expression $e$ and if it holds, does nothing. If $e$ does not hold, it jumps to the \reject{} parser state with the error message being the result of evaluating $e'$.

\begin{figure}[h!]
\centering\ottgrammartabular{
\ottlval\ottafterlastrule
}
\caption{P4 l-values}
\label{fig:lval}
\end{figure}

$lval$s are shown in Figure~\ref{fig:lval} and include variables identified by their names, a null variable (used to model method calls) and struct fields, which are identified by the struct and field names, similar to the field access expression.

\newpage
\newcommand{\exstate}{\ensuremath{s}}
\newcommand{\ascope}{\ensuremath{{\gamma}_A}}
\newcommand{\currsf}{\ensuremath{\varepsilon}}
\newcommand{\gscope}{\ensuremath{{\gamma}_G}}
\newcommand{\gscopel}{\ensuremath{\overline{\gamma_G}}}
\newcommand{\escope}{\ensuremath{{\gamma}_{\emptyset}}}
\newcommand{\cstack}{E}
\newcommand{\status}{\ensuremath{t}}
\newcommand{\running}{\textbf{run}}
\newcommand{\returnst}[1]{\ensuremath{\textbf{ret}\;#1}}
\newcommand{\trans}[1]{\ensuremath{\textbf{tra}\;#1}}
\newcommand{\sterr}{\ensuremath{\bot}}
\newcommand{\pfin}{\ensuremath{p_{\mathrm{fin}}}}
\newcommand{\expr}{\ensuremath{e}}
\newcommand{\varstar}{\mathbf{var} ( \mathbf{star} , \mathit{funn} )}
\newcommand{\scope}{\gamma}
\newcommand{\scopeL}{\overline{\gamma}}
\newcommand{\stmtL}{\overline{stmt}}
\newcommand{\cons}{, ... \, ,}
\newcommand{\concat}{{+}\mspace{-8mu}{+}}
\newcommand{\bitv}{\ensuremath{bitv}}
\newcommand{\estmt}{\emptyset_{ \mathrm{stmt} }}
\newcommand{\frameL}{\overline{\Phi}}
\newcommand{\declL}{\overline{decl}}
%TODO Change this...
\newcommand{\fapp}{\ensuremath{\mathit{table\_apply}}}

\subsection{Execution State}

\begin{figure}[h!]
\centering\ottgrammartabular{
\ottstatus\ottinterrule
\ottstate\ottafterlastrule
}
\caption{P4 Execution State}  %TODO: update this section
\label{fig:status}
\end{figure}

The P4 execution state is shown in Figure~\ref{fig:status}. Note that a ``P4 execution state'' is not defined in the P4 specification, so it is entirely an artifact of the \pfott{} implementation. In short, the execution state \exstate{} is a tuple of the architectural scope \ascope{}, the global scope list $\scopeL_G$, a frame list $\frameL$, and the state status \status{}. 

\subsubsection*{Scopes}
More formally, a scope $\gamma : X \hookrightarrow V * (X \cup \{ \bot \} )$ is a partial function from variable names $\vn{} \in X$ to tuples of their values $\cval{} \in V$ and optional variable names (used for variables introduced as out-directed function parameters). The following operations are be performed on $\scope$ in the semantics:
%TODO Notation for the below
\begin{itemize}
\item $\mathrm{dom} ( \gamma )$: Gets the domain of $\gamma$: obtains the set of variable names $\vn{} \in X$ which are mapped to values in $\gamma$.
\item $(\vn \mapsto  \cval) \,\, \gamma$: Updates a variable mapping in $\gamma$: yields the scope $\gamma'$, which is just $\gamma$ where \vn{} instead maps to \cval{} instead of its old value. By writing $\forall i \leq n. \,\, ({\vn}_i \mapsto  {\cval}_i) \,\, \gamma$ we extend this to lists of mappings from variable names to values.
\end{itemize}
$\scopeL$ is a list of scopes $\scope_1 \cons \scope_n$ where the index 1 is the most recently entered scope, and $n$ is the oldest.

\subsubsection*{Global scopes}
The global scope list \gscopel{} contains two elements; index 0 represents the programmable block local scope, while index 1 represents the global scope of the architecture. Initially, when a programmable block is entered, for each function declared globally in the architecture or locally in a programmable block a corresponding function return placeholder variable is declared in the local programmable block scope.

%The current scope - that which was most recently entered by execution - is stored on the top of \currsf{}  (note that this indexing is the reverse of what you would expect from a list). Whenever a new block (delineated by $\{ \}$) is entered, a new fresh scope \escope{} is pushed onto the frame $\currsf$. %TODO New notation for pushing?

%
% TODO update operations here and in the scope.
%

%The following operations can be performed on a list of scopes $\scopeL$:
%\begin{itemize}
%\item $ \gamma :: \scopeL $: Add a scope $\gamma$ to the list $\scopeL$ (i.e. cons).
%TODO Append (++)
%\item Concatenating two $\gamma$ frames together.
%TODO Tail tl
%\item $(\num \mapsto  \gamma) \,\, \currsf$: Updates the scope located at index \num{} of \currsf{} by setting it to $\gamma$.
%\end{itemize}

%The call stack $\cstack$ is a stack of frames used whenever a function call occurs. When a function call is executed, the frame \currsf{} (minus the global scope \gscope{}) of the caller will be pushed onto $\cstack$. When the callee function finishes execution and returns, \currsf{} will be popped from $\cstack$ and pushed onto a frame containing only \gscope{}. Note that this means that the same \gscope{} is kept throughout function calls, and updates to it are passed along accordingly. The following operations can be performed on $\cstack$: 
%\begin{itemize}
%\item $ \currsf :: \cstack$: Pushes a frame $\currsf$ onto the call stack $\cstack$.
%\end{itemize}

\subsubsection*{Lists of statements}
The list of statements $\stmtL$ is simply a list of $stmt_1 \cons stmt_n$ where $stmt_1$ belongs to the most recent block we have entered, and $stmt_n$ is the oldest one.

Whenever a block $\{ \declL \ stmt_b \} ; stmt$ is encountered, the block's statement $stmt_b$ will be appended to the old statement $stmt$ leaving an empty statement in its original place. So the next transition will become $stmt_b::(\emptyset_{stmt}; stmt$ 

\subsubsection*{Function names}
The abstract function name \funn{} identifies a function name, extern function (using extern object name and function name) or extern constructor (using only extern name). In P4, functions can be declared globally, or locally in the programmable block (actions). We model the actions exactly as the functions, and to distinguish between them we store their signatures and bodies in two different locations: the programmable block-local functions' signatures and bodies in the mapping $F_b$, and the globally declared functions' and actions' signatures and bodies in the mapping $F_g$. Both $F_b$ and $F_g$ are stored in the context $ctx$ which will be discussed later.

\subsubsection*{Frames}
The frame $\Phi$ is a tuple of three members: a function name \funn{}, a statement list $\stmtL$ and a scope list $\scopeL$: together represented as $ \stmtL^{\funn}_{\scopeL{}} $. Whenever a function call occurs, the frame of the callee will be appended to the list of frames in the state (in which the frame of the caller is the first) as $\Phi_{\mathrm{callee}} :: \frameL $.

\subsubsection*{Architectural scope}
The architectural scope is of polymorphic type. For specific architectures, this is supposed to hold table configurations and the states extern objects, as well as any other stateful components of the architecture. Exactly how this is represented is entirely up to the architecture in question.

\subsubsection*{Status}
Represented in the state with $t$. The status \running{} represents that the program is executing under regular circumstances. \returnst{v} is used when the \textbf{return} statement returns a value \cval{} ($\bot$ if it is a void function) at the end of a function call. The status \trans{\vn{}} signifies transition to a new parser state. The new parser state can be a final state in the case of \trans{\mathit{accept}} or \trans{\mathit{reject}}, or otherwise a state defined in the P4 program.

\subsection{Context}
The context $ctx$ - separated out from the execution state since it remains invariant over reductions - is a tuple of the following: 
\begin{enumerate}
   \item $\fapp$: the apply table function which takes a table name, parameters to match, match kinds, default action with arguments and the architectural scope and returns an action with parameters.
   \item $X$: the extern object map, which maps extern object names to tuples of constructors and their respective function maps.
   \item $F_g$: the globally-declared function map. It maps global function and action names to tuples of their bodies, argument names and directions. 
   \item $F_b$: the programmable block-local function map.  It maps local function names to tuples of their bodies, argument names and directions. 
   \item $P$: the parser states map. It maps the name of parser states to their bodies.
   \item $Tb$: the table map. It maps the table name to its list of match kinds and default action with parameters.
\end{enumerate}

%\subsection{Calling convention}   
%The calling conventions can be directioned or directionless. The direction can be either IN, OUT or INOUT. 
%IN direction summary:
%\begin{enumerate}
%    \setlength{\itemsep}{1pt}
%    \setlength{\parskip}{0pt}
%    \setlength{\parsep}{0pt}
%\item Should not be used on the left hand of assignment
%\item Shouldn't be passed to a function without using the proper calling convention IN
%\item Initialized by copying the value of the corresponding argument when the invocation is executed.
%\end{enumerate}
%OUT summary:
%\begin{enumerate}
%    \setlength{\itemsep}{1pt}
%    \setlength{\parskip}{0pt}
%    \setlength{\parsep}{0pt}
%\item usually uninitialized, and treated as l-values. after the execution of the call, the value of the OUT parameters copied to the corresponding location of the l-value. OUT parameters are initialized in the following cases
%\begin{enumerate}[label=(\alph*)]
%\item if the types are header or header\_union, OUT parameter is set to "invalid"
%\item if the type is a header stack, then all elements of the header stack set to "invalid" and the next index is initialized to 0.
%\item if the type is compound (e.g. struct or tuple) apply the rules recursively to its members.
%\item if any any other type than listed above (e.g. bit <W>), then it doesn't need any predictable value.
%\end{enumerate}
%\end{enumerate}
%
%INOUT summary:
%\begin{enumerate}
%    \setlength{\itemsep}{1pt}
%    \setlength{\parskip}{0pt}
%    \setlength{\parsep}{0pt}
%\item this type of parameters are both IN and OUT.
%\item it must be an l-value, which means it can be assigned to a value.
%\end{enumerate}
%NO direction summary:
%\begin{enumerate}
%    \setlength{\itemsep}{1pt}
%    \setlength{\parskip}{0pt}
%    \setlength{\parsep}{0pt}
%\item those parameters are known at compile time.
%\item it also can be an action parameter, can be set by the control plane.
%\item it also can be an action parameter that set directly by an other action, then the behaviour will be like IN parameter.
%\end{enumerate}
%
%The direction d can be $\downarrow$ denotes IN, $\uparrow$ denotes OUT, $\updownarrow$ denotes INOUT, $\circ$ denotes directionless. 
%
%Thus,
%d ::= $\downarrow$ | $\uparrow$ | $\updownarrow$ | $\circ$
%
%Due to the calling conventions, the scope has the type; $ \scope : X \hookrightarrow V * (X \cup \{ \bot \})  $ .
%
%The list of scopes is identified with an arrow following $\scopeL$.
%The local $\scopeL$ is meant to be a local list of scopes to the frame. The global $\scopeL_G$ is a list with a length of 2. The first index determines the external architecture scope (can not be defined by a P4 program), while the second index determines the architecture local variables (defined in the architecture level).
%Opeations on list of scopes:
%\begin{enumerate}
%    \setlength{\itemsep}{1pt}
%    \setlength{\parskip}{0pt}
%    \setlength{\parsep}{0pt}
%\item Operation $\scope [\vn \longmapsto v]$ to update a variable name \vn{} with value \cval{} in the scope $\scope$. 
%\item Operation $\scopeL [\vn \longmapsto v]$ to update a variable name \vn{} with value \cval{} in the most recent scope that contains the variable name \vn{}.   
%\item Operation $lookup_v(\scopeL, \scopeL_G, \vn)$ to return the value \cval{} of the tuple $(y, x \cup {\bot})$, which is whatever variable x is mapped to in the most recent scope it is defined in after concatenating $\scopeL_G \concat \scopeL$. 
%\end{enumerate}

\section{Semantics}

\subsection{Expressions}\label{sec:expsem}
The reductions of the expression semantics can not directly alter or have any side effects on the state. The rules reduce expressions - standard small step structural semantics - and may also produce a new frame (which can then indirectly have side effects on the state in other layers of the semantics), which occurs only in the function call reduction.  

\subsubsection*{Variable lookup}
In the \textsc{e\_lookup} rule, the lookup function ensures that the variable name \vn{} is evaluated in the uppermost scope (i.e. most recent scope $\scope$ that \vn{} is declared in). The evaluation will occur using the function $\mathrm{lookup}_v$. It will sweep the list of scopes $\scopeL \concat \scopeL_G$ and find the most recent (leftmost in the list) scope that contains variable $x$ and this is because the scopes grow from right to left, in accordance with the description in Sections \pfourspec{sec-name-resolution}{6.8} and \pfourspec{sec-variables}{10.2} of the P4 specification. The constant value of this variable is then propagated to the result of the expression reduction.

\begin{figure}[ht!]
    \ottusedrule{\ottdruleeXXlookup{}} 
\end{figure}



\subsubsection*{Function call}
Note that function calls also include actions as well as extern function calls.

The \textsc{e\_call\_args} is used whenever there is a function call expression with unreduced (in- and none-directioned) arguments. We fetch the parameter names and directions of the function using $\mathrm{lookup\_funn\_sig}$, then each function's arguments will be checked against the direction in the same position. If the direction is in or none, then the argument will be reduced until it becomes a constant, otherwise if the argument has the direction out or inout it should not be reduced beyond variable lookup.

The \textsc{e\_call\_newframe} rule is used when all of the function arguments have been reduced to constants (for non-out directions) or variables (directions with out). The function call reduction will produce a placeholder we call $\varstar$ and a new frame. The new frame will be added by the enclosing statement semantic layer on top of the state's existing frames, as explained later.
The way that this new frame is constructed is as follows: The function name \funn{} will be the same as the call in the expression. \funn{} will be looked up in both the function maps and extern maps to retrieve the function body \stmt{} and the signature of the parameters represented as a list of tuples of variable names and their directions $ [(\vn{}_1, d_1) \cons (\vn{}_n, d_n) ] $. Each argument will be checked to ensure that the arguments were reduced properly: (if $d_i$ is in or none then the expression in the same position should be a constant, otherwise a variable). The new frame's scope $\scope'$ is a new fresh empty scope to which the parameters are declared and copied in to using the function $\mathrm{copyin}$, depending on direction.

\begin{figure}[ht!]
    \ottusedrule{\ottdruleeXXcallXXargs{}} \\
    \ottusedrule{\ottdruleeXXcallXXnewframe{}}
\end{figure}


\subsubsection*{Headers and structs with expression fields}
Structs or headers with expressions in place of values have their own reduction rules. The \textsc{e\_eStruct} rule will reduce the expression fields one at a time from left to right. Once all the expressions have become values we can transform the expression struct to a value struct via \textsc{e\_eStruct\_to\_v}. Similar operations are applied on the header expressions.

\begin{figure}[ht!]
    \ottusedrule{\ottdruleeXXeStruct{}} \\
    \ottusedrule{\ottdruleeXXeStructXXtoXXv{}} \\
    \ottusedrule{\ottdruleeXXeHeader{}} \\
    \ottusedrule{\ottdruleeXXeHeaderXXtoXXv{}}
\end{figure}


\subsubsection*{Access headers and structs}
The \textsc{e\_s\_acc} rule is used to access the values of fields in structs, and the \textsc{e\_h\_acc} rule is similarly used for headers.

\begin{figure}[ht!]
    \ottusedrule{\ottdruleeXXsXXacc{}} \\
    \ottusedrule{\ottdruleeXXhXXacc{}} 
\end{figure}


\subsubsection*{Select label}
The \textsc{e\_sel\_acc} rule is used to match the given value $\cval$ against the label-value list, in the case a match exists. If the match doesn't exist, then return the default label \vn.

\begin{figure}[ht!]
    \ottusedrule{\ottdruleeXXselXXacc{}}
\end{figure}


\subsubsection*{Bit slicing}
This reduction gives a bitvector $\bitv'''$ that is reduced from the slicing operation. It extracts a contiguous list from the original $\bitv$ from the LSB \bitv'' to the MSB \bitv'.

\begin{figure}[ht!]
    \ottusedrule{\ottdruleeXXsliceXXv{}}
\end{figure}


\subsubsection*{Concatenation}
The reduction produces one bit string $\bitv''$ that is the result of concatenating two bit strings $\bitv$ and $\bitv'$.

\begin{figure}[ht!]
    \ottusedrule{\ottdruleeXXconcatXXv{}}
\end{figure}


\subsubsection*{Unary and binary arithmetic operations}
The unary and binary operations consist mostly of standard operations on bit vectors, and are for this reason elided in this section.


%%%%%%%%%%%%%%%%% statement semantics   
\subsection{Statement Semantics}
The semantics of the statements are presented in this section\footnote{Rules for reducing expressions in all contexts are found in Appendix~\ref{app:exp}}. Note that the statement semantics operates on single frames.


\subsubsection*{Assignment}
The assignment can assign to $lval$s (shown in Figure~\ref{fig:lval}), which can be either variables identified by their names, a null variable (used to model method calls) or struct fields, which are identified by the struct and field names, similar to the field access expression. Whenever an expression is assigned to an $lval$, that expression shall be reduced until it becomes a constant value. Then the appropriate scope in the current frame of execution will be updated with the mapping  $\vn \mapsto v$. With appropriate we mean that the topmost (most recent) scope that the $lval$ is declared in. The reduction results in the empty statement and an updated local or global scope lists. Note that this doesn't apply on $\mathbf{null}$ since it is used for method and action calls with no return values in mind.

\begin{figure}[ht!]
    \ottusedrule{\ottdrulestmtXXassXXv{}}
\end{figure}

\subsubsection*{If-then-else}
The \textsc{stmt\_cond2} and \textsc{stmt\_cond3} rules are the standard ones for conditional statements.

\begin{figure}[ht!]
    \ottusedrule{\ottdrulestmtXXcondTwo{}} \\
    \ottusedrule{\ottdrulestmtXXcondThree{}} 
\end{figure}


\subsubsection*{Block}
Once a block statement is encountered $ \{ \declL \ stmt \}$ the \textsc{stmt\_block\_enter} reduction will be used, which entails the $\declL{}$ being declared in a fresh scope that will be pushed to the local $\scopeL{}$ of the frame, and then the body $stmt$ of the block will be pushed to the statement list, in which the block statement has been reduced to the empty statement.

The \textsc{stmt\_block\_exec} rule simply describes small-step reduction of the block contents. We also check if the previous list $\stmtL$ is empty or not: if it is empty, then the other single block statement rules can be applied directly. It is also important to check that the head of the list $stmt::\stmtL$ is not $\estmt{}$, otherwise this rule is non-deterministic with \textsc{stmt\_block\_exit}.

The \textsc{stmt\_block\_exit} rule is used in the case where the end of a block is reached, i.e. whenever a block contains only $\estmt{}$: it pops the head (containing only $\estmt{}$) from the statement list as well as the scope corresponding to the block from the scope list $\scopeL$.

\begin{figure}[ht!]
    \ottusedrule{\ottdrulestmtXXblockXXenter{}} \\
    \ottusedrule{\ottdrulestmtXXblockXXexec{}} \\
    \ottusedrule{\ottdrulestmtXXblockXXexit{}} 
\end{figure}


\subsubsection*{Apply} 
The \textsc{stmt\_apply\_v} describes the apply table statement. Note that this is particular to our formalization: it is a method call in the P4 specification. Each apply statement has a table name \tn{} with a list of key expressions $\expr_1 \cons \expr_n$ to match on. This list has been previously reduced to constants one at a time in the rule \textsc{stmt\_apply\_e}. The $Tb$ will return a list of match kinds $mk_1 \cons mk_n$ and a default action with arguments, which is then used with $\mathit{apply\_table}$ to perform the actual table matching. %The ctrl is a function that maps table names $tbl$, expressions, and the match kinds to action that should be implemented as a method call, with a list of the arguments $\cval_1 \cons \cval_m $ .


\begin{figure}[ht!]
    \ottusedrule{\ottdrulestmtXXapplyXXtableXXe{}} \\
    \ottusedrule{\ottdrulestmtXXapplyXXtableXXv{}} 
\end{figure}

\subsubsection*{Return}
Once the expression of \textbf{return} is reduced to a constant value, the status is changed to $\returnst{\cval}$, and the statement becomes $\estmt{}$. The rest of the function return procedure will be described in the sequence rule and frame-level semantics.

\begin{figure}[ht!]
    \ottusedrule{\ottdrulestmtXXretXXv{}} 
\end{figure}

\subsubsection*{Sequence}
The sequential statements rules \textsc{stmt\_seq1} and \textsc{stmt\_seq2} are standard. The status \status{} must be \running{} in the initial state. The non-standard element of \textsc{stmt\_seq1} is that if any new frame is created (e.g. by a function call) or a statement added to the statement list (e.g. by a block statement), it will be added on top of the frame list. \\

Otherwise, the \textsc{stmt\_seq3}  rule is used whenever the status is \returnst{}, or \trans{} to indicate either a a transition to a parser state or a return from a function call. The statements that follow sequentially can be discarded: this gives flexibility to have return or transition statements in the body rather than only at the end.
Furthermore, \textsc{stmt\_seq1} and \textsc{stmt\_seq3} are both able to change the architectural scope.

\begin{figure}[h!]
    \ottusedrule{\ottdrulestmtXXseqOne{}} \\
    \ottusedrule{\ottdrulestmtXXseqTwo{}} \\
    \ottusedrule{\ottdrulestmtXXseqThree{}}
\end{figure}


\subsubsection*{Extern}
The symbol $\blacksquare$ represents a statement capturing the inner semantics of an extern function: i.e. the semantics other than copy-in, copy-out and return behaviour. $\blacksquare$ is able to modify the architectural scope, the local scope list $\scopeL$ and the execution status (which is always set to \returnst{v}). The exact behaviour is determined by looking up the entry of the \funn{} associated with the current frame in the extern function map $X$: since $\blacksquare$ is meant to be used only in extern function call bodies, $\mathit{funn}$ is the name of the extern function that is currently being called.

Note that calling an extern function works the same as calling any other function, as described in the function call subsection of Section~\ref{sec:expsem}. However, by convention the body of the extern function consists only of $\blacksquare$.

\begin{figure}[ht!]
    \ottusedrule{\ottdrulestmtXXext{}}
\end{figure}

\subsubsection*{Transition}
The transition statement $\mathbf{transition} \; \vn $, whose semantics is captured by the \textsc{stmt\_trans} rule, makes a change to the state's status \status{} based on the state name \vn{}.

\begin{figure}[ht!]
    \ottusedrule{\ottdrulestmtXXtrans{}} 
\end{figure}



\subsubsection*{Verify}
The $\mathbf{verify} \, \expr \, \expr'$ statement is used to check the whether the boolean expression $\expr$ holds; if it does, then nothing happens, as stated in the \textsc{stmt\_verify\_3} rule. Otherwise, it assigns the error in $\expr'$ to $"parseError"$ and reduces the statement to a $\mathbf{transition}$ statement to the state \reject{}.
 
\begin{figure}[ht!]
    \ottusedrule{\ottdrulestmtXXverifyXXThree{}} \\
    \ottusedrule{\ottdrulestmtXXverifyXXFour{}} 
\end{figure}



\subsection{Frame-Level Semantics}
The statement semantics in the previous section operate on a single frame containing a list of statements, however when a function being called, a new frame will be pushed to the frame list of the state. The frame-level semantics will always try to execute the top frame, however \textsc{frames\_comp1} will be used when the status is not set to $\returnst{v}$ and \textsc{frames\_comp2} when it is.

For \textsc{frames\_comp2}, note that the the global scope list $\scopeL_G$ will contain a $\varstar$ declared for every callable function in the current programmable block (set in the architecture-level semantics). This variable is then updated with the value $v$ that is found in the final status $\returnst{v}$ of the statement semantics reduction. The copy-out function takes the callee function signature, the global scope list, the caller's scope list $\scopeL'$ and the callee's scope list $\scopeL''$ (note that $\scopeL = \scopeL''$ due to the semantics of \textbf{return}). It returns a new updated scopes list for both the global and caller's frame.

In the copyout function, each out-directed parameter should be copied out to the variable name of its argument: note that these argument names are stored in the callee's scope.

\begin{figure}[ht!]
    \ottusedrule{\ottdruleframesXXcompOne{}} \\
    \ottusedrule{\ottdruleframesXXcompTwo{}}
\end{figure}

We define $\mathrm{scopes\_to\_pass}(\funn, F_g , F_b , \overline{\gamma_G})$ for function names as:
 \[  \overline{\gamma_G}' = \begin{cases}
            \mathrm{if} \; \funn \in dom(F_b)    \hspace{6pt} ,
            \mathrm{then} \;  \overline{\gamma_G}\\
            \mathrm{otherwise}    \hspace{45pt}     , 
            \mathrm{then} \; \mathrm{if} \; \funn \in dom(F_g) \; \mathrm{then} \; [ \emptyset_{\gamma} ; \overline{\gamma_G}[1] ] \; \mathrm{else} \; \overline{\gamma_G}\;,
        \end{cases}\]
and in the case \funn{} is an extern function or constructor, $\overline{\gamma_G}' = [ \emptyset_{\gamma} ; \overline{\gamma_G}[1] ]$.
Recall that the global scope is at index $1$ of $\overline{\gamma_G}$, and the programmable block-global scope is at index $0$. $\overline{\gamma_G}'$ is propagated to the statement semantics as the global scope list of the initial state. 

We define $\mathrm{scopes\_to\_retrieve}(\funn, F_g , F_b , \overline{\gamma_G}, \overline{\gamma_G}')$ for function names as:
\[\overline{\gamma_G}'' = \begin{cases}
            \mathrm{if} \; \funn \in dom(F_b)    \hspace{6pt} ,
            \mathrm{then} \;   \overline{\gamma_G}'\\
            \mathrm{otherwise}    \hspace{45pt}     , 
            \mathrm{then} \; \mathrm{if} \; \funn \in dom(F_g) \; \mathrm{then} \; [\overline{\gamma_G}[0];\overline{\gamma_G}'[1]] \; \mathrm{else} \; \overline{\gamma_G}'\; ,
        \end{cases}
\]
and in the case \funn{} is an extern function or constructor, $\overline{\gamma_G}'' = [\overline{\gamma_G}[0];\overline{\gamma_G}'[1]]$. The result here then becomes the global scope list of the final state of the frame-level reduction, after eventual copy-out.

%\newpage
%\newcommand{\start}{\textit{start}}
%\subsection{Parser Block Semantics}
%The parser programmable block is a part of the P4 pipeline which is generally used to parse packets from bit-string representations to structures of parsed headers, described in \pfourspec{sec-control}{Section 13} of the P4 specification. It can be thought of as describing a state machine with three unique states: a \start{} state, an \accept{} state and a \reject{} state. A parser state $p$ (including \start{}, but not the abstract final states of \accept{} and \reject{}) consists of a list of statements to be executed, with a transition statement at the end which decides the parser state to jump to next.
%
%\begin{figure}[ht!]
%\begin{ottdefnblock}{$\ottsym{[}  \ottnt{stmt}  \ottsym{]}  s  \rightarrow  \ottsym{[}  \ottnt{stmt'}  \ottsym{]}  s'$}{\ottcom{statement semantics}}
%\ottusedrule{\ottdrulestmtXXverifyXXThree{}}
%\ottusedrule{\ottdrulestmtXXverifyXXFour{}}
%\ottusedrule{\ottdrulestmtXXtrans{}}
%\end{ottdefnblock}
%\caption{P4 Parser-Specific Statement Execution Semantics}
%\label{fig:parssemstmtexec}
%\end{figure}
%
%The parser-specific statement semantics is shown in Figure~\ref{fig:parssemstmtexec}. The \textsc{stmt\_verify\_3} and \textsc{stmt\_verify\_4} rules describe the semantics of \textbf{verify}, the expressions having been reduced to values. If the condition holds, the reduction is to the empty statement (i.e. nothing happens and execution continues). If the condition does not hold, reduction is also to the empty statement, but state status is set to \reject{}. The \textsc{stmt\_trans} rules describes reduction of the $\mathbf{transition}$ statement, whose only effect on the state is to set status to indicate next parser state (the \textsc{pars\_state} or \textsc{pars\_t\_fin} rules can then be used next)
%
%\begin{figure}[ht!]
%\ottdefnsparsXXsem
%\caption{Parser Block-Level Semantics}
%\label{fig:semparsexec}
%\end{figure}
%
%The parser state machine semantics is shown in Figure~\ref{fig:semparsexec}.
%
%The \textsc{pars\_stmt} rule performs a single small-step reduction of the current statement (the body of the current parser state), while the \textsc{pars\_state} rule governs transition to the next parser state: if the current statement \stmt{} is reduced to $\stmt{}'$ with the status being \trans{\vn{}} where \vn{} is not \accept{} or \reject{}, the next statement is the body of the parser state with name \vn{}, obtained from the map $P$ from parser state names to parser bodies. The \textsc{pars\_empty} rule covers the special case when the statement semantics runs out of statements in a parser state, in which case the status is set to \reject{}.

%\subsection{Control Block Semantics}
%The control block is a part of the P4 pipeline which is generally used to decide which actions to take (typically forwarding) based on the metadata (headers) which was extracted by the parser, as described in \pfourspec{sec-packet-parsing}{Section 12} of the P4 specification. The two main components of a control block are the match-action tables and the actions themselves. Note that part of the functionality is separated into the control plane, which is interfaced with here using the $\mathrm{ctrl}(table\_name,\ v,\ m\_kind)$ function that takes a table name, constant value and matching kind and obtains an action name $f$ and a list of function arguments ${v_1}, ..., {v_n}$.
%Actions can be thought of roughly as functions with no return values. The action can be called implicitly from the match-action process (i.e. in the table application), or explicitly from another action or a control block, as described in \pfourspec{sec-actions}{Section 13.1.1} of the P4 specification.
%
%The \textsc{apply\_table\_e} rule performs small-step evaluation of the header expression used for the matching.
%
%The \textsc{apply\_table\_v} looks up the table name in the table name map, then uses the result together with the header to be looked up to obtain an action (together with action arguments) from the control plane.
%
%\begin{figure}[ht!]
%\ottusedrule{\ottdrulestmtXXapplyXXtableXXe{}}
%\ottusedrule{\ottdrulestmtXXapplyXXtableXXv{}}
%\caption{Match Action Execution Semantics}
%\label{fig:semmatchaction}
%\end{figure}
%
%\begin{figure}[ht!]
%\ottdefnsctrlXXsem
%\caption{Control Block-Level Semantics}
%\label{fig:semctrl}
%\end{figure}
%
%The statement semantics unique to the control block is shown in Figure~\ref{fig:semmatchaction}. Note that the body of the control block consists of the statements inside the apply block, and that executing a return statement at this level signifies return from the control block as a whole. The block-level semantics of the control block are shown in Figure~\ref{fig:semctrl}, which is the same as the statement semantics, since the termination condition is handled in the architecture-level semantics.

\newcommand{\actx}{\ensuremath{\mathit{ctx}_\mathit{A}}}
\newcommand{\abl}{\ensuremath{\overline{ab}}}
\newcommand{\pbm}{\ensuremath{B_p}}
\newcommand{\ffbm}{\ensuremath{B_{ \mathit{ff}}}}
\newcommand{\aenv}{\ensuremath{\mathit{env}_\mathit{A}}}
\subsection{Architecture-Level Semantics}
The architecture-level semantics is the topmost-level semantics, describing the entirety of the P4 pipeline from input packets to output packets, and it uses the frame semantics for reduction steps inside programmable blocks. The judgment form, shown at the top of Figure~\ref{fig:semarch}, consists of multiple components: starting from the left, an \emph{architectural context} \actx{} (which contains the static componenents not changed by reduction steps) on the left-hand side of the turnstile, which contains the following:
\begin{enumerate}
\item The \emph{architectural block list} \abl{}: an architectural block represents a stage of packet processing. There are four fundamental stages of packet processing in a P4-compatible architecture. First, there are the input (\textbf{inp}) and output (\textbf{out}) stages: these stages just perform translation between the architectural packet format and the generic I/O format (consisting of a list of ports, each with pending packets to be arbitrated/sent off)\footnote{The demux block functionality may be modeled as part of the output stage, or it may be its own fixed-function block preceding the output stage}. Second, there are the programmable blocks (parser blocks and control blocks) and the fixed-function block stages. Fixed-function blocks, like their name implies, perform the parts of packet processing in the P4-programmable network element that are actually not P4-programmable.
\item The \emph{programmable block map} \pbm{}, which is a partial map between names of programmable block names (strings) and the all necessary items that model the block in question. This is the block type (parser or control), the list of directed parameters, the block-local function map containing function declared inside the block, a list of declarations of variables done at a block-global level, a statement representing initialisations and instantiations of these block-global variables followed by the body (for parsers, a transition statement pointing to ``start'', for control blocks the content of the apply statement encased in a block), and the parser state map $P$ between parser state names and their bodies (statements)\footnote{Note that \pfott{} represents all parser state bodies as encased in a block by convention} and a table map $\mathit{Tb}$ between names of tables and tuples of expressions and matching kinds. Note that the parser state map is empty for control blocks, as is the table map for parser blocks.
\item The \emph{fixed-function block map} \ffbm{}, which is a partial map between names of fixed-function blocks to the implementation of the fixed function itself, which is a partial function that maps the architectural scope to an updated architectural scope.
\item The \emph{input function} $f_{ \mathit{in} }$ and the \emph{output function} $f_{ \mathit{out} }$, which are both partial functions from an IO list and the architectural scope to an updated IO list and architectural scope. They are used in the input and output stages.
\item The \emph{programmable block copy-in function} $\mathit{copyin}_{ \mathit{pbl} }$ and the \emph{programmable block copy-out function} $\mathit{copyout}_{ \mathit{pbl} }$: $\mathit{copyin}_{ \mathit{pbl} }$ is a partial function from a list of directed parameters, a list of expression arguments, the architectural scope and the block type to a scope (the block-global scope of the programmable block). $\mathit{copyout}_{ \mathit{pbl} }$ is a partial function from the global scopes list, a list of directed parameters, the architectural scope, the block type and status to an updated architectural scope. Note that these functions are responsible for the copy-in copy-out behaviour of the \textit{parseError} variable in parser blocks.
\item The \emph{extern object map} $X$, which is a partial map from extern object names to tuples of extern function maps (a map holding the extern functions of the object: tuples of directed parameter lists, function bodies, and the extern semantics), and an optional constructor (holding a tuple same as that of the extern function map).
\item The \emph{function map} $F$, which is a partial map from globally-declared function names to tuples of function bodies (statements) and their directed parameter lists.
\end{enumerate}

The states on the left-hand and right-hand sides of the reduction both have the same elements.
\begin{enumerate}
\item The \emph{architectural environment} \aenv{}, which in turn has four components:
\begin{enumerate}
\item The \emph{architectural block index}: This is an index which informs us of which architectural block in \abl{} is currently being reduced.
\item The \emph{input list}, which is a list of incoming packets (represented as tuples of lists of Booleans and numbers signifying input ports)
\item The \emph{output list}, which is the same as the input list, but used for output.
\item The \emph{architectural scope} $\gamma_A$, which is of polymorphic type, and is used for storing things in-between the programmable blocks, as well as things that are not accessible directly by P4 code.
\end{enumerate}
\item The global scope list \gscopel{}, which contains the top-level global scope with constants common to all programmable blocks as well as the block-global scope containing variables declared at the start of progrmamable blocks.
\item The \emph{architecture-level frame list}: this contains either a regular frame list (as described in the statement semantics), or it is a special empty architecture-level frame list ($[ \; ]_A$).
\item The status, which informs us of whether a parser state machine is finished, or the apply of a control block is finished.
\end{enumerate}

The rules of the architecture-level semantics are the following:
\begin{enumerate}
\item \textsc{arch\_in}: The first premise requires that the pending architecture block is \textbf{inp}, and then $f_{ \mathit{in} }$ updates the input list and the architectural scope.

\item \textsc{arch\_pbl\_init}: when the pending architecture block is a programmable block, a new block-global scope $\gamma'$ is created and initialised with the arguments of the programmable block (in the case of a parser block, \textit{parseError} is also initially set to \textit{NoError}). After this, the variables in the list of declarations are declared in $\gamma'$. The final result $\gamma''$ is appended to the top-level global scope $\gscopel[0]$, forming a new global scopes list $\gscopel''$, in which $\mathrm{initialise\_var\_stars}$ initialises function return placeholder variables for all callable functions in the block. Also, the empty architecture frame list is changed to a single frame where the singleton statement list contains the initialisations of the parser block \textit{stmt} followed by the body of the programmable block\footnote{Conventions for how these are represented are mentioned in the explanation of $\pbm$}, the scopes stack contains a single empty scope and the current function name is the name of the programmable block.

\item \textsc{arch\_ffbl} handles the fixed-function block: when the pending architecture block is a fixed-function block with name $x$, the implementation \textit{ff} of the fixed-function is looked-up in \ffbm{} using $x$, after which it is used to update the architectural scope. Also, the architecture block index is incremented.

\item \textsc{arch\_out}: Similar to the above, but the pending architecture block must be \textbf{out}, and then the output list and the architectural scope are updated by $f_{ \mathit{out} }$.

\item \textsc{arch\_parser\_trans}: In case the block at the block index $i$ is a parser block and the current status is \trans{x'}, this rule will obtain the parser state body $\mathit{stmt}'$ of $P(x')$ (where $P$ is the parser state map of the current parser block), and set the next frame to the singleton list of $\mathit{stmt}'$ with $[\escope{}]$ as the scope stack and $x'$ as the current function name, as well as set the status to \running{}.

\item \textsc{arch\_pbl\_exec} describes a reduction step inside a programmable block: the first two premises are there to obtain the content of the statement semantics context. Then, the global block list, the frame list, the control plane configuration and the status are updated by a statement reduction step $\longrightarrow$.

\item \textsc{arch\_pbl\_ret} rule describes the final step of programmable block reduction that reduces to an empty frame list. The first two premises obtain the directed parameters of the block. If $\mathit{state\_fin}$ (termination conditions of the two programmable blocks) holds of the status and frame list (if status was \running{}, $\mathrm{set\_fin\_status}$ then sets it to \trans{``reject"} if we are in a parser block). The block output function $\mathit{out}_{ \mathit{p} }$ proceeds to update the architectural scope (notably dependent on architecture, it copies out the value of $\mathit{parseError}$). Furthermore, the architecture block list index is incremented by 1 and the block-global scope is dropped from the global scopes list.
\end{enumerate}

\begin{figure}[ht!]
\resizebox{.8\linewidth}{!}{
\begin{minipage}{\linewidth}
\ottdefnsarchXXsem
\end{minipage}
}
\caption{Architecture-Level Semantics}
\label{fig:semarch}
\end{figure}


\clearpage
\appendix
\section{Concrete Syntax of Operations}
\label{app:op}
\begin{figure}[ht!]
\centering\ottgrammartabular{
\ottunop\ottafterlastrule
}
\caption{P4 Unary Operations}
\label{fig:unop}
\end{figure}

The unary expressions included are shown in Figure~\ref{fig:unop}. These include all of the unary operations in P4. Boolean negation is only defined on Booleans, the other operations have their standard meanings (note that \pfourspec{sec-bit-ops}{unary plus is a no-op}).

\newpage
\begin{figure}[ht!]
\centering\ottgrammartabular{
\ottbinop\ottafterlastrule
}
\caption{P4 Binary Operations}
\label{fig:binop}
\end{figure}

The binary expressions included are shown in Figure~\ref{fig:unop}. These include all of the binary operations in P4.

\section{Semantics of Expression Reduction}
\label{app:exp}
This appendix describes semantics for reducing nested expressions. A selection of this type of expression semantics are shown in Figure~\ref{fig:semexp2}, and for the statement semantics are in Figure~\ref{fig:semstmt2}.

\begin{figure}[ht!]
\centering{\begin{ottdefnblock}[#1]{$ [  \ottnt{e}  ] (  \sigma  ) \rightsquigarrow [  \ottnt{e'}  ] (  \sigma'  ) $}{\ottcom{expression semantics}}
%\ottusedrule{\ottdruleeXXfuncXXcallXXargs{}}
%\ottusedrule{\ottdruleeXXaccXXargTwo{}}
%\ottusedrule{\ottdruleeXXaccXXargOne{}}
\ottusedrule{\ottdruleeXXselXXarg{}}
\ottusedrule{\ottdruleeXXunopXXarg{}}
\ottusedrule{\ottdruleeXXbinopXXargOne{}}
\ottusedrule{\ottdruleeXXbinopXXargTwo{}}
\end{ottdefnblock}}
\caption{Expression Reduction-of-Argument Semantics (selection)}
\label{fig:semexp2}
\end{figure}

\pfourspec{sec-expr-eval-order}{8.1} of the P4 specification states that expressions are evaluated left-to-right. Accordingly, the rules for binary operations - \textsc{e\_binop1} and \textsc{e\_binop2} - are split up so that reduction of the second operand requires that the first operand has been completely reduced to a constant. This is trivial for unary operations (\textsc{e\_unop}).

\begin{figure}[ht!]
\begin{ottdefnblock}{$\ottsym{[}  \ottnt{stmt}  \ottsym{]}  s  \rightarrow  \ottsym{[}  \ottnt{stmt'}  \ottsym{]}  s'$}{\ottcom{statement semantics}}
\ottusedrule{\ottdrulestmtXXretXXe{}}
\ottusedrule{\ottdrulestmtXXassXXe{}}
\ottusedrule{\ottdrulestmtXXcondXXe{}}
\ottusedrule{\ottdrulestmtXXverifyXXeOne{}}
\ottusedrule{\ottdrulestmtXXverifyXXeTwo{}}
\end{ottdefnblock}
\caption{Statement Reduction-of-Argument Semantics (selection)}
\label{fig:semstmt2}
\end{figure}

\printbibliography

\end{document}


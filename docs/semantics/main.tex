\documentclass[UTF8]{article}
%\documentclass[a4paper,11pt,reqno]{amsart}

\pagestyle{headings}
\usepackage{graphicx}
\usepackage[english]{babel}
\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}
\usepackage{verbatim}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{pstricks}
\usepackage{mathrsfs}
\usepackage{textcomp}
\usepackage{tikz}
\usepackage{subfig}
\usepackage{fancyvrb}
\usepackage{enumitem}

\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=cyan,
}

\usepackage{csquotes}
\usepackage[backend=biber]{biblatex}
\usepackage{todonotes}

\usepackage{supertabular}
\usepackage{geometry}
\usepackage{ifthen}
\usepackage{alltt}%hack


\newcommand*{\inference}[3][t]{%
   \begingroup
   \def\and{\\}%
   \begin{tabular}[#1]{@{\enspace}c@{\enspace}}
   #2 \\
   \hline
   #3
   \end{tabular}%
   \endgroup
}

\include{p4_defs}

\addbibresource{p4.bib}
\newtheorem{thm}{Theorem}
\newtheorem{lemma}{Lemma}

\title{%
The \texttt{p4ott} P4 Formalization}
\author{Anoud Alshnakat\\
Didrik Lundberg
}
\date{\today}
\begin{document}
\maketitle

\newcommand{\pfott}{\texttt{p4ott}}

\begingroup\lccode`?=`# \lowercase{\endgroup
\newcommand{\specsec}[1]{%
    ?#1%
}
}
\newcommand{\pfourspec}[2]{%
\href{https://p4lang.github.io/p4-spec/docs/P4-16-v1.2.2.html\specsec{#1}}{#2\kern-0.5ex} %Removes weird whitespace???
}
\noindent
This is a description of the \pfott{} formalization of P4, which includes a syntax and a strictly small-step style semantics. It is based on \pfourspec{}{the official P4 specification} and inspired by Core P4~\cite{doenges2021petr4}.

\pfott{} is constructed using the \texttt{ott} tool. \texttt{ott} files can then be exported to \LaTeX{} commands (used in this document) as well as to the HOL4, Isabelle/HOL and Coq interactive theorem provers (of which only the first is currently supported).

%\newpage
\section{Syntax}
\subsection{Types}
\newcommand{\num}{\ensuremath{i}}
\newcommand{\vn}{\ensuremath{x}}
\newcommand{\vna}{\ensuremath{a}}
\newcommand{\msg}{\ensuremath{\mathit{msg}}}
\newcommand{\tn}{\ensuremath{\mathit{table\_name}}}
\newcommand{\fn}{\ensuremath{f}}
\newcommand{\inte}{\ensuremath{bl}}
%
%TODO Base types (integers, booleans, bit strings, errors, headers...), function types (superset of base types also including tables, functions and constructors) and directions (in, out, inout), ...
%
\begin{figure}[h!]
\centering
\ottmetavars
\caption{Variables}
\label{fig:vars}
\end{figure}

The variables shown in Figure~\ref{fig:vars} are standard designations for variables of \pfourspec{sec-base-types}{P4 base types} included in \pfott{}, plus the numerals \num{} and the indices $m, n, o$ which are not part of the P4 syntax, but used on a meta-level throughout this formalization. Depending on the context, strings are denoted with \vna{}, \vn{} (variable or parser state name), \msg{} (error message), \tn{} (match-action table name) or \fn{} (function or field name). \inte{} is a list of Boolean values, used to represent bit-strings of fixed width.

Types are sometimes explicitly referenced in the syntax, e.g. in declaration statements. The notation for this is shown in Figure~\ref{fig:types}. Subscript $t$ is used to clarify the notation refers to a type, as opposed to a variable of that type. Declared instances of composite types are stored in the type environment $T$.

\begin{figure}[h!]
\centering\ottgrammartabular{
\ottbt\ottinterrule
\ottt\ottafterlastrule
}
\caption{Types}
\label{fig:types}
\end{figure}

\newpage
\subsection{Expressions}
\newcommand{\fmap}{\textit{F}}

\pfott{} includes a subset of the full set of P4 expressions found in {\pfourspec{sec-exprs}{Section 8}} of the P4 specification, shown in Figure~\ref{fig:exp}.

\begin{figure}[h!]
\centering\ottgrammartabular{
\otte\ottafterlastrule
}
\caption{P4 Expressions}
\label{fig:exp}
\end{figure}
\newcommand{\stmt}{\textit{stmt}}
\newcommand{\cval}{\ensuremath{v}}
\newcommand{\fexec}[1]{\textbf{exec}\,\,#1}

First, an expression can be a value: a Boolean or an integer (collectively referred to as constant values \cval{}), or a variable or parser state name $x$. Lists of expressions can be used in declarations of variables of struct types. The fields of these structs may be accessed, which is denoted in the usual manner. There exist unary and binary arithmetic operations, where the semantics of the individual operations are defined on some subset of the constants\footnote{The concrete syntax of the many unary and binary operations is found in Appendix~\ref{app:op}}. The function call is built from the function name \fn{}, and a list of arguments (expressions). In-progress execution of the body of a called function, \fexec{\stmt{}}, is not a part of the P4 syntax, but is rather an artifact of our small-step semantics.

The \textbf{select} expression is similar to a switch statement in C or Java. The expression $e$ is evaluated, and then matched against $v_1 , \ldots , v_n$. If some match is successful, the \textbf{select} expression evaluates to the string at the corresponding index. If no match occurs, then it instead evaluates to the default string $x$.

\newpage
\subsection{Statements}

\label{ssec:stmt}
\pfott{} includes a subset of the full set of P4 statements found in \pfourspec{sec-stmts}{Section 11} of the P4 specification, shown in Figure~\ref{fig:stmt}. They are mostly standard, apart from the following: the in-progress block is an artifact of our small-step semantics. The \textbf{verify} statement (here a statement and not an extern function as in \pfourspec{sec-verify}{Section 12.7} of the P4 specification) can be found uniquely in a parser block. It asserts the expression $e$ and if it holds, does nothing. If $e$ does not hold, it jumps to a rejecting parser state with error message being the result of evaluating $e'$. The \textbf{transition} statement continues execution at a new parser state, the name of which is the result of evaluating $e$. The \textbf{apply} statement applies the match-action table with name \tn{} (found in the control plane) to the result of evaluating $e$, thus obtaining an action (modeled as a function call) to execute next.

\begin{figure}[h!]
\centering\ottgrammartabular{
\ottstmt\ottafterlastrule
}
\caption{P4 Statements}
\label{fig:stmt}
\end{figure}

The assignment can assign to $lval$s (shown in Figure~\ref{fig:lval}), which include variables identified by their names, a null variable (used to model method calls) and struct fields, which are identified by the struct and field names, similar to the field access expression.

\begin{figure}[h!]
\centering\ottgrammartabular{
\ottlval\ottafterlastrule
}
\caption{P4 l-values}
\label{fig:lval}
\end{figure}

\newpage
\newcommand{\exstate}{\ensuremath{s}}
\newcommand{\scope}{\ensuremath{\mathit{scope}}}
\newcommand{\stacks}{\ensuremath{\sigma}}
\newcommand{\currsf}{\ensuremath{\varepsilon}}
\newcommand{\gscope}{\ensuremath{{\gamma}_G}}
\newcommand{\escope}{\ensuremath{{\gamma}_{\emptyset}}}
\newcommand{\cstack}{E}
\newcommand{\status}{\ensuremath{t}}
\newcommand{\running}{\textbf{R}}
\newcommand{\returnst}[1]{\ensuremath{\textbf{Ret}\,\,#1}}
\newcommand{\accept}{\textbf{Accept}}
\newcommand{\reject}[1]{\textbf{Reject} #1}
\newcommand{\trans}[1]{\textbf{Trans} #1}
\newcommand{\sterr}{\ensuremath{\bot}}
\newcommand{\pfin}{\ensuremath{p_{\mathrm{fin}}}}
\subsection{Execution State}

The P4 execution state is shown in Figure~\ref{fig:status}. Note that nothing like this is described in the P4 specification, so it is entirely an artifice of the \pfott{} implementation. In short, the execution state \exstate{} is a tuple of the state memory \stacks{} and the state status \status{}. The state memory $\stacks{}$ consists of a tuple ($\currsf$, $\cstack$), where $\currsf$ is a stack of scopes $\gamma$ (induced by entering nested blocks) which hold the values of variables which are currently visible, and $\cstack$ holds variable mappings which belong to previous caller contexts.

\begin{figure}[h!]
\centering\ottgrammartabular{
\ottstatus\ottinterrule
\ottstate\ottafterlastrule
}
\caption{P4 Execution State}
\label{fig:status}
\end{figure}

More formally, a scope $\gamma : X \hookrightarrow V$ is a partial function from variable names $\vn{} \in X$ to constant values $\cval{} \in V$. The following operations can be performed on $\gamma$:
%TODO Notation for the below
\begin{itemize}
\item $\mathrm{dom} ( \gamma )$: Gets the domain of $\gamma$: obtains the set of variable names $\vn{} \in X$ which are mapped to values in $\gamma$.
\item $(\vn \mapsto  \cval) \,\, \gamma$: Updates a variable mapping in $\gamma$: yields the scope $\gamma'$, which is just $\gamma$ where \vn{} instead maps to \cval{}. By writing $\forall i \leq n. \,\, ({\vn}_i \mapsto  {\cval}_i) \,\, \gamma$ we extend this to lists of mappings from variable names to values.
\end{itemize}

A frame \currsf{} is a stack of scopes where the global scope \gscope{} is located at the bottom; that is, in location $\currsf [0]$.
When a frame is considered a list the head of the list (i.e $\currsf{} [0]$) represent the bottom of the stack.
The current scope - that which was most recently entered by execution - is stored on the top of \currsf{}  (note that this indexing is the reverse of what you would expect from a list). Whenever a new block (delineated by $\{ \}$) is entered, a new fresh scope \escope{} is pushed onto the frame $\currsf$. %TODO New notation for pushing?

The following operations can be performed on a frame $\currsf$:
\begin{itemize}
\item $ \gamma :: \currsf$: Add a scope $\gamma$ on bottom of \currsf{} (i.e. cons).
%TODO Append (++)
%\item Concatenating two $\gamma$ frames together.
%TODO Tail tl
\item $(\num \mapsto  \gamma) \,\, \currsf$: Updates the scope located at index \num{} of \currsf{} by setting it to $\gamma$.
\end{itemize}

The call stack $\cstack$ is a stack of frames used whenever a function call occurs. When a function call is executed, the frame \currsf{} (minus the global scope \gscope{}) of the caller will be pushed onto $\cstack$. When the callee function finishes execution and returns, \currsf{} will be popped from $\cstack$ and pushed onto a frame containing only \gscope{}. Note that this means that the same \gscope{} is kept throughout function calls, and updates to it are passed along accordingly. The following operations can be performed on $\cstack$: 
\begin{itemize}
\item $ \currsf :: \cstack$: Pushes a frame $\currsf$ onto the call stack $\cstack$.
\end{itemize}

The status \running{} represents that the program is executing under regular circumstances. \returnst{v} is used when the \textbf{return} statement returns a constant \cval{} at the end of a function call. The status $p$ signifies transition to a new parser state inside the parser - a named state in the case of \trans{\vn{}}, or a final state (\pfin{}) in the case of \accept{} or \reject{}. \sterr{} represents a crash or undefined behaviour, for example caused by some badly-typed part of the program. 

In addition to the above, there's also a function map $F$ mapping function names to tuples of their bodies and argument names, a table map $\mathit{Tb}$ mapping table names to tuples of expressions and matching kinds, a parser map $P$ mapping parser state names to their bodies and a type environment $T$. These are assumed to be static, and are therefore not part of the execution state.

\section{Semantics}
\subsection{Expressions}
%\begin{figure}[h!]
%\centering\ottgrammartabular{
%\otteXXsem\ottafterlastrule
%}
%\caption{Judgment Forms of P4 Expression Evaluation}
%\label{fig:judgexp}
%\end{figure}

\begin{figure}[ht!]
\centering{\begin{ottdefnblock}[#1]{$ [  \ottnt{e}  ] (  \sigma  ) \rightsquigarrow [  \ottnt{e'}  ] (  \sigma'  ) $}{\ottcom{expression semantics}}
\ottusedrule{\ottdruleeXXlookup{}}
\ottusedrule{\ottdruleeXXfuncXXcallXXnewframe{}}
\ottusedrule{\ottdruleeXXfuncXXexec{}}
\ottusedrule{\ottdruleeXXfuncXXret{}}
\ottusedrule{\ottdruleeXXsXXacc{}}
\ottusedrule{\ottdruleeXXhXXacc{}}
\ottusedrule{\ottdruleeXXselXXacc{}}
\ottusedrule{\ottdruleeXXselXXdef{}}
\ottusedrule{\ottdruleeXXextXXexec{}}
\end{ottdefnblock}}
\caption{P4 Expression Evaluation Semantics}
\label{fig:semexp}
\end{figure}
\newcommand{\expr}{\ensuremath{e}}

The semantics of expressions is shown in Figure~\ref{fig:semexp}\footnote{The semantics for reducing concrete arithmetic operations is standard and covers everything found in Appendix~\ref{app:op}}\footnote{Rules for reducing expressions in all contexts can be found in Appendix~\ref{app:exp}}.
\\~\\
In the \textsc{e\_lookup} rule, the lookup function ensures that the variable name \vn{} is evaluated in the uppermost (i.e. most recently entered) scope of \currsf{} where it can be found. This agrees with the description in Sections \pfourspec{sec-name-resolution}{6.8} and \pfourspec{sec-variables}{10.2} of the P4 specification. The value of this variable is then resolved, and checked to be a constant.
\\~\\
The \textsc{e\_func\_call\_newframe} rule is used when all of the function arguments have been reduced to constants (for non-out directions) or variables (directions with out). Arguments with out-directions are looked up in the caller frame, and a tuple of the resulting value and the originating variable is assigned to a variable with the corresponding parameter name in a fresh callee scope $\gamma'$. Similarly, arguments with non-out directions are simply assigned to their parameter names in $\gamma'$. Finally, $\gamma'$ is put on top of the global scope \gscope{} in order to form the new frame of the callee $\currsf '$. The old current frame \currsf{} (minus \gscope{}) is then saved on top of the call stack \cstack{} to be used later when returning from the function call, and the function call statement is reduced to $\mathbf{exec} \,\, \mathit{stmt}$ - in-progress execution of the function body \stmt{} (obtained from the function map \fmap{}, which holds mappings between function names \fn{} and tuples of function bodies and lists of their argument names and directions). Note that this rule also covers the case of a function call with no arguments. The \textsc{e\_func\_exec} rule reduces the function body of in-progess execution with one statement reduction, and the \textsc{e\_func\_ret} rule reduces finished (empty) in-progress execution with status $\mathbf{Ret} \,\, \cval$ to $\cval$. This also changes the status to $\mathbf{R}$.
\\~\\
The \textsc{e\_s\_acc} rule is used to access the values of fields in structs, and the \textsc{e\_h\_acc} rule is similarly used for headers.
\\~\\
The \textsc{e\_sel\_acc} rule is used to match the given value $v$ against the key-value list, in the case a match exists. The \textsc{e\_sel\_def} rule is used for the default case, when no match exists. 

%TODO Write explanation for new function return
%Once the expression in the \textbf{return} statement has been reduced to a constant, the rule \textsc{stmt\_ret} can be applied. The global scope \gscope{} is always stored at the bottom (index zero) in the stack of scopes, i.e. $\currsf [0]$. It is fetched and concatenated with the frame of the most recent caller that is stored on top of the call stack $\cstack$. Thus, this concatenation will yield a new frame $\currsf$ that has the same shape as the one before the function being called (of course before reaching the \textbf{return} statement some variable mappings in the global scope \gscope{} could have been changed during function evaluation). Then, the values of parameters with direction out (obtained from the function map $F$) are copied over to the frame of the caller, using the names of the provided arguments (stored in the frame of the callee $\varepsilon$). The status is also changed to $\mathbf{Return} \,\, v$ which allows for applying \textsc{e\_func\_ret}.

\newpage
\subsection{Calling convention}   
The calling conventions can be directioned or directionless. The direction can be either IN, OUT or INOUT. 
IN direction summary:
\begin{enumerate}
\item Should not be used on the left hand of assignment
\item Shouldn't be passed to a function without using the proper calling convention IN
\item Initialized by copying the value of the corresponding argument when the invocation is executed.
\end{enumerate}
OUT summary:
\begin{enumerate}
\item usually uninitialized, and treated as l-values. after the execution of the call, the value of the OUT parameters copied to the corresponding location of the l-value. OUT parameters are initialized in the following cases
\begin{enumerate}[label=(\alph*)]
\item if the types are header or header\_union, OUT parameter is set to "invalid"
\item if the type is a header stack, then all elements of the header stack set to "invalid" and the next index is initialized to 0.
\item if the type is compound (e.g. struct or tuple) apply the rules recursively to its members.
\item if any any other type than listed above (e.g. bit <W>), then it doesn't need any predictable value.
\end{enumerate}
\end{enumerate}

INOUT summary:
\begin{enumerate}
\item this type of parameters are both IN and OUT.
\item it must be an l-value, which means it can be assigned to a value.
\end{enumerate}
NO direction summary:
\begin{enumerate}
\item those parameters are known at compile time.
\item it also can be an action parameter, can be set by the control plane.
\item it also can be an action parameter that set directly by an other action, then the behaviour will be like IN parameter.
\end{enumerate}

The direction d can be $\downarrow$ denotes IN, $\uparrow$ denotes OUT, $\updownarrow$ denotes INOUT, $\circ$ denotes directionless. 

Thus,
d ::= $\downarrow$ | $\uparrow$ | $\updownarrow$ | $\circ$

In the function calls, it requires extending the scope type to be as following;
$ \gamma : X \hookrightarrow V * (X \cup \{ \bot \})  $ \\We shall also modify the stack E to be a list of tuples of 2 members. First member is the frame, while second member is the function name as in ($\varepsilon$, F\_name). Define a a few new operations: 
\begin{enumerate}
\item operation $\varepsilon[x \longmapsto v]$ to update a variable x with value v in the frame $\varepsilon$. This should be equivalent to the three premises in STMT\_ASS\_V
\item operation $lookup_t(\varepsilon, x)$ to return a tuple (y, d) that that variable x is mapped to in frame $\varepsilon$. 
\item operation $lookup_v(\varepsilon, x)$ to return the value v of the tuple $(y, x \cup {\bot})$, which is whatever variable x is mapped to in frame $\varepsilon$. 
\end{enumerate}

\begin{figure}[h]
\centering\ottgrammartabular{
\ottd\ottafterlastrule
}
\caption{direction syntax}
\label{fig:dir}
\end{figure}

\begin{figure}[h]
\centering\ottgrammartabular{
\ottcalledXXfunctionXXname\ottafterlastrule
}
\caption{called function name list}
\label{fig:fnl}
\end{figure}

   
\subsection{Statement Execution}
The semantics of the statements is shown in Figures~\ref{fig:strsemstmtexec} and~\ref{fig:semstmtexec}\footnote{Rules for reducing expressions in all contexts are found in Appendix~\ref{app:exp}}.

\begin{figure}[ht!]
\begin{ottdefnblock}{$\ottsym{[}  \ottnt{stmt}  \ottsym{]}  s  \rightarrow  \ottsym{[}  \ottnt{stmt'}  \ottsym{]}  s'$}{\ottcom{statement semantics}}
\ottusedrule{\ottdrulestmtXXdecl{}}
\ottusedrule{\ottdrulestmtXXassXXv{}}
\ottusedrule{\ottdrulestmtXXassXXnull{}}
\ottusedrule{\ottdrulestmtXXcondTwo{}}
\ottusedrule{\ottdrulestmtXXcondThree{}}
\end{ottdefnblock}
\caption{P4 Statement Execution Semantics}
\label{fig:semstmtexec}
\end{figure}
The \textsc{stmt\_decl} is used to reduce the \textbf{decl} statement, which has the effect of declaring variable mappings in the current (topmost) scope. The newly declared variable is given an uninitialized value, denoted by $?$.
\\~\\
The \textsc{stmt\_ass\_v} rule handles the assignment statement. In general, the variables that the program can assign values to are in the current frame, and never in $\cstack$. The antecedent $\currsf [ \vn \longmapsto \cval ]$ obtains the topmost (i.e. most recently entered) scope in the current frame $\currsf$ containing the variable, then updates the mapping of the variable name \vn{} to the new value (constant \cval{}) in this scope. The reduction results in the empty statement and an updated current frame.
\\~\\
The \textsc{stmt\_ass\_null} rule handles the case where null variable is assigned to, i.e., in method calls.
\\~\\
The \textsc{stmt\_cond2} and \textsc{stmt\_cond3} rules are the standard ones for conditional statements.
\\~\\

\begin{figure}[ht!]
\begin{ottdefnblock}{$\ottsym{[}  \ottnt{stmt}  \ottsym{]}  s  \rightarrow  \ottsym{[}  \ottnt{stmt'}  \ottsym{]}  s'$}{\ottcom{statement semantics}}
\ottusedrule{\ottdrulestmtXXseqOne{}}
\ottusedrule{\ottdrulestmtXXseqTwo{}}
\ottusedrule{\ottdrulestmtXXblockXXenter{}}
\ottusedrule{\ottdrulestmtXXblockXXexec{}}
\ottusedrule{\ottdrulestmtXXblockXXexit{}}
\end{ottdefnblock}
\caption{P4 Statement Execution Semantics: Structural Rules}
\label{fig:strsemstmtexec}
\end{figure}

The \textsc{stmt\_seq1} and \textsc{stmt\_seq2} rules are pretty standard.
\\~\\
The \{\} brackets indicate a block, while the [ ] brackets indicate a block in progress of being executed.
The \textsc{stmt\_block\_enter} rule is used to enter a block, which entails a new empty scope \escope{} being pushed onto the current frame \currsf{}, and then the \{\} brackets are switched to the in-progress ones [ ] to signify that the block is currently being executed. The \textsc{stmt\_block\_exec} rule simply describes small-step reduction of the block contents, and the \textsc{stmt\_block\_exit} rule is used in the case where the end of a block is reached, i.e. whenever a block contains only an empty statement: it pops the scope corresponding to the block (the most recent one) from the frame $\currsf$.
\\~\\

\newcommand{\start}{\textit{start}}
\subsection{Parser Block Semantics}
The parser programmable block is a part of the P4 pipeline which is generally used to parse packets from bit-string representations to structures of parsed headers, described in \pfourspec{sec-control}{Section 13} of the P4 specification. It can be thought of as describing a state machine with three unique states: a \start{} state, an \accept{} state and a \reject{\msg{}} state. A parser state $p$ (including \start{}, but not the abstract final states of \accept{} and \reject{\msg{}}) consists of a list of statements to be executed, with a transition statement at the end which decides the parser state to jump to next.

\begin{figure}[ht!]
\begin{ottdefnblock}{$\ottsym{[}  \ottnt{stmt}  \ottsym{]}  s  \rightarrow  \ottsym{[}  \ottnt{stmt'}  \ottsym{]}  s'$}{\ottcom{statement semantics}}
\ottusedrule{\ottdrulestmtXXverifyXXThree{}}
\ottusedrule{\ottdrulestmtXXverifyXXFour{}}
\ottusedrule{\ottdrulestmtXXtransXXOne{}}
\ottusedrule{\ottdrulestmtXXtransXXTwo{}}
\ottusedrule{\ottdrulestmtXXtransXXThree{}}
\end{ottdefnblock}
\caption{P4 Parser-Specific Statement Execution Semantics}
\label{fig:parssemstmtexec}
\end{figure}

The parser-specific statement semantics is shown in Figure~\ref{fig:parssemstmtexec}. The \textsc{stmt\_verify\_3} and \textsc{stmt\_verify\_4} rules describe the semantics of \textbf{verify}, the expressions having been reduced to values. If the condition holds, the reduction is to the empty statement (i.e. nothing happens and execution continues). If the condition does not hold, reduction is also to the empty statement, but state status is set to $\mathbf{Reject}\ x$. The \textsc{stmt\_trans} rules describe reduction of the $\mathbf{transition}$ statement, whose only effect on the state is to set status to indicate next parser state (the \textsc{pars\_state} or \textsc{pars\_t\_fin} rules can then be used next)

\begin{figure}[ht!]
\ottdefnsparsXXsem
\caption{Parser Block-Level Semantics}
\label{fig:semparsexec}
\end{figure}

The parser state machine semantics is shown in Figure~\ref{fig:semparsexec}.

The \textsc{pars\_stmt} rule performs a single small-step reduction of the current statement (the body of the current parser state), while the \textsc{pars\_state} rule governs transition to the next parser state: if the current statement \stmt{} is reduced to $\stmt{}'$ with the status being \trans{\vn{}}, the next statement is the body of the parser state with name \vn{}, obtained from the map $P$ from parser state names to parser bodies.

The \textsc{pars\_t\_fin} rule says that when reduction using the statement semantics of the current statement results in a status with a final parser state $p_{\mathrm{fin}}$, this is also set as the status in the parser semantics. The \textsc{pars\_t\_empty} rule covers the special case when the statement semantics runs out of statements in a parser state, in which case the status is set to \reject{ParserStateEnd}.

\subsection{Control Block Semantics}
The control block is a part of the P4 pipeline which is generally used to decide which actions to take (typically forwarding) based on the metadata (headers) which was extracted by the parser, as described in \pfourspec{sec-packet-parsing}{Section 12} of the P4 specification. The two main components of a control block are the match-action tables and the actions themselves. Note that part of the functionality is separated into the control plane, which is interfaced with here using the $\mathrm{ctrl}(table\_name,\ v,\ m\_kind)$ function that takes a table name, constant value and matching kind and obtains an action name $f$ and a list of function arguments ${v_1}, ..., {v_n}$.
Actions can be thought of roughly as functions with no return values. The action can be called implicitly from the match-action process (i.e. in the table application), or explicitly from another action or a control block, as described in \pfourspec{sec-actions}{Section 13.1.1} of the P4 specification.

The \textsc{apply\_table\_e} rule performs small-step evaluation of the header expression used for the matching.

The \textsc{apply\_table\_v} looks up the table name in the table name map, then uses the result together with the header to be looked up to obtain an action (together with action arguments) from the control plane.

\begin{figure}[ht!]
\ottusedrule{\ottdrulestmtXXapplyXXtableXXe{}}
\ottusedrule{\ottdrulestmtXXapplyXXtableXXv{}}
\caption{Match Action Execution Semantics}
\label{fig:semmatchaction}
\end{figure}

\begin{figure}[ht!]
\ottdefnsctrlXXsem
\caption{Control Block-Level Semantics}
\label{fig:semctrl}
\end{figure}

The statement semantics unique to the control block is shown in Figure~\ref{fig:semmatchaction}. Note that the body of the control block consists of the statements inside the apply block, and that executing a return statement at this level signifies return from the control block as a whole. The block-level semantics of the control block are shown in Figure~\ref{fig:semctrl}. It's almost the same as the statement semantics, the only difference being that the return statement causes an immediate reduction to the empty statement.

\newcommand{\actx}{\ensuremath{\mathit{ctx}_\mathit{A}}}
\newcommand{\abl}{\ensuremath{\overline{ab}}}
\newcommand{\pbm}{\ensuremath{B_p}}
\newcommand{\ffbm}{\ensuremath{B_{ \mathit{ff}}}}
\newcommand{\aenv}{\ensuremath{\mathit{env}_\mathit{A}}}
\subsection{Architecture-Level Semantics}

The architecture-level semantics is the topmost-level semantics, and it describes the entirety of the P4 pipeline from input packets to output packets. The judgment form, shown in Figure~\ref{fig:semarch}, consists of multiple components: starting from the left, an \emph{architectural context} \actx{} on the left-hand side of the turnstile, which contains the following:
\begin{enumerate}
\item The \emph{architectural block list} \abl{}: the architectural block represents one of the four fundamental stages in a P4-compatible architecture. First, there are the input (\textbf{inp}) and output (\textbf{out}) stages: these stages are just translators between the P4 input packet format and the general I/O format consisting of a list of ports, each with pending packets to be arbitrated/sent off. The demux block functionality may be modeled as part of the output stage, or it may be its own fixed-function block preceding the output stage. Second, there are the programmable blocks - parser blocks and control blocks, which are described in more detail elsewhere in this document, as well as the fixed-function blocks. Fixed-function blocks can be thought of as analoguous to extern calls, but on the architectural level. They perform the parts of the functionality of the P4-programmable network element that is not written in the P4 language.
\item The \emph{programmable block map} \pbm{}, which is a map between names of programmable blocks (strings) and the necessary information required to execute the block in question. For parser blocks, this is the list of directed parameters and the parser state map $P$ between parser state names and their bodies (statements). For programmable blocks, this is the body of the control block (found in the topmost apply statement), the list of directed parameters and a table map $\mathit{Tb}$ between names of tables and tuples of expressions and matching kinds.
\item The \emph{programmable block map} \ffbm{}, which is a map between names of fixed-function blocks and their lists of directed parameters, as well as the implementation of the fixed fiunction itself - this is a function between an expression list (arguments), the architectural scope, and the current frame to an updated architectural scope and current frame.
\item The \emph{input function} $f_{ \mathit{in} }$ and the output function $f_{ \mathit{out} }$, which are both functions from the IO list and the architectural scope to an updates IO list and architectural scope.
\item The \emph{type map} $\mathit{Ty}$, which is a (currently unused) map from names of types to their actual types.
\item The \emph{extern map} $X$, which is a map from extern names (strings) to tuples of extern functions (functions from tuples of lvals, arguments and states to option types of values and states) and their directed parameter lists. Note that that since the state contains the control plane configuration, extern functions may modify it.
\item The \emph{function map} $F$, which is a map from function names (strings) to tuples of function bodies (statements) and their directed parameter lists.
\end{enumerate}
The architectural context contains everything which can not change between reductions.

The left-hand and right-hand sides of the reduction both consist of an \emph{architectural statement} and an \emph{architectural environment} \aenv{}, which may change between reductions. The architectural statement is either a regular statement as defined above, or a programmable or fixed-function block call which both take lists of directed parameters and function names. \aenv has five components:
\begin{enumerate}
\item The \emph{architectural block index}: This is an index which informs us of which architectural block in \abl{} is currently being reduced.
\item The \emph{in-progress flag}, which is a Boolean telling us whether a programmable block is currently being executed (as opposed to returning or being initialised) or not.
\item The \emph{input list}, which is a list of incoming packets (represented as tuples of lists of Booleans and numbers signifying input ports)
\item The \emph{output list}, which is the same as the input list, but used for output.
\item The \emph{architectural scope}, which is of the same type as the regular scope, but used for storing values in-between non-adjacent blocks.
\end{enumerate}

The rules of the architecture-level semantics can be divided into several categories:
\begin{enumerate}
\item The \textsc{arch\_in}, \textsc{arch\_pbl\_call}, \textsc{arch\_ffbl\_call} and \textsc{arch\_out} rules all deal with queueing the next block to be executed. Input and output takes place immediately by applying their respective functions.
\item The \textsc{arch\_parser\_init} and \textsc{arch\_control\_init} rules are similar to the \textsc{e\_func\_call\_newframe} rule in the expression semantics: both set up the values of variables in the new parser and control blocks, respectively. In the parser case, this rule also sets the value of $\mathit{parseError}$ to $\mathit{NoError}$ and the statement to be executed to the statement mapped to $\mathit{start}$ in $P$.
\item The \textsc{arch\_parser\_exec}, \textsc{arch\_control\_exec} and \textsc{arch\_ffblock\_exec} rules all govern the actual execution of blocks. \textsc{arch\_ffblock\_exec} is different from the other two in that it performs execution in one step only, and thus also checks for properly reduced arguments the same way \textsc{arch\_parser\_init} (for example) does. Accordingly, it also increments the architecture block index. \textsc{arch\_parser\_exec} takes a step in the parser semantics (using the parser map $P$ that was obtained from \pbm{}) that does not start in a state with status $\mathit{pars\_fin}$. \textsc{arch\_control\_exec} similarly takes a step in the control semantics using the table map $Tb$ that was obtained from \pbm{}.
\item The \textsc{arch\_parser\_ret} and \textsc{arch\_control\_ret} rules govern the return phase of programmable block execution. They are similar in many respects to \textsc{e\_func\_ret}, but they also increment the architecture block index, and \textsc{arch\_parser\_ret} furthermore copies back the value of $\mathit{parseError}$ to the architecture scope.
\end{enumerate}

\begin{figure}[ht!]
\resizebox{.7\linewidth}{!}{
\begin{minipage}{\linewidth}
\begin{ottdefnblock}[#1]{$ { \mathit{ctx}_\mathit{A} }  \vdash [  \ottnt{arch\_stmt}  ] (  { \mathit{env}_\mathit{A} }  ,  \sigma  ,  t  ) {\longrightarrow}_{A} [  \ottnt{arch\_stmt'}  ] (  { \mathit{env}_\mathit{A} }' ,  \sigma'  ,  t'  ) $}{\ottcom{architecture-level semantics}}
\ottusedrule{\ottdrulearchXXin{}}
\ottusedrule{\ottdrulearchXXpblXXcall{}}
\ottusedrule{\ottdrulearchXXffblXXcall{}}
\ottusedrule{\ottdrulearchXXout{}}
\ottusedrule{\ottdrulearchXXparserXXinit{}}
\ottusedrule{\ottdrulearchXXcontrolXXinit{}}
\ottusedrule{\ottdrulearchXXparserXXexec{}}
\ottusedrule{\ottdrulearchXXcontrolXXexec{}}
\ottusedrule{\ottdrulearchXXparserXXret{}}
\ottusedrule{\ottdrulearchXXcontrolXXret{}}
\ottusedrule{\ottdrulearchXXffblockXXexec{}}
\end{ottdefnblock}
\end{minipage}
}
\caption{Architecture-Level Semantics}
\label{fig:semarch}
\end{figure}

\printbibliography

\clearpage
\appendix
\section{Concrete Syntax of Operations}
\label{app:op}
\begin{figure}[ht!]
\centering\ottgrammartabular{
\ottunop\ottafterlastrule
}
\caption{P4 Unary Operations}
\label{fig:unop}
\end{figure}

The unary expressions included are shown in Figure~\ref{fig:unop}. These include all of the unary operations in P4. Boolean negation is only defined on Booleans, the other operations have their standard meanings (note that \pfourspec{sec-bit-ops}{unary plus is a no-op}).

\newpage
\begin{figure}[ht!]
\centering\ottgrammartabular{
\ottbinop\ottafterlastrule
}
\caption{P4 Binary Operations}
\label{fig:binop}
\end{figure}

The binary expressions included are shown in Figure~\ref{fig:unop}. These include all of the binary operations in P4.

\section{Semantics of Expression Reduction}
\label{app:exp}
This appendix describes semantics for reducing expressions in certain contexts. The expression semantics are shown in Figure~\ref{fig:semexp2}. The statement semantics are shown in Figure~\ref{fig:semstmt2}. The architecture semantics are shown in Figure~\ref{fig:semarch2}.

\begin{figure}[ht!]
\centering{\begin{ottdefnblock}[#1]{$ [  \ottnt{e}  ] (  \sigma  ) \rightsquigarrow [  \ottnt{e'}  ] (  \sigma'  ) $}{\ottcom{expression semantics}}
\ottusedrule{\ottdruleeXXfuncXXcallXXargs{}}
\ottusedrule{\ottdruleeXXaccXXargTwo{}}
\ottusedrule{\ottdruleeXXaccXXargOne{}}
\ottusedrule{\ottdruleeXXselXXarg{}}
\ottusedrule{\ottdruleeXXunopXXarg{}}
\ottusedrule{\ottdruleeXXbinopXXargOne{}}
\ottusedrule{\ottdruleeXXbinopXXargTwo{}}
\end{ottdefnblock}}
\caption{Expression Reduction-of-Argument Semantics}
\label{fig:semexp2}
\end{figure}

The \textsc{e\_func\_call\_args} rule reduces the leftmost function argument which has yet to be reduced to a constant with one expression evaluation step. The first two antecedents divide the list of arguments into two sub-lists, where the prefix must contain all constants. The head of the suffix is then reduced with one step, after which the corresponding index in the original list of arguments is update with the resulting expression.
\\~\\
\pfourspec{sec-expr-eval-order}{8.1} of the P4 specification states that expressions are evaluated left-to-right. Accordingly, the rules for binary operations - \textsc{e\_binop1} and \textsc{e\_binop2} - are split up so that reduction of the second operand requires that the first operand has been completely reduced to a constant. This is trivial for unary operations (\textsc{e\_unop}).

\begin{figure}[ht!]
\begin{ottdefnblock}{$\ottsym{[}  \ottnt{stmt}  \ottsym{]}  s  \rightarrow  \ottsym{[}  \ottnt{stmt'}  \ottsym{]}  s'$}{\ottcom{statement semantics}}
\ottusedrule{\ottdrulestmtXXretXXe{}}
\ottusedrule{\ottdrulestmtXXassXXe{}}
\ottusedrule{\ottdrulestmtXXcondXXe{}}
\ottusedrule{\ottdrulestmtXXverifyXXeOne{}}
\ottusedrule{\ottdrulestmtXXverifyXXeTwo{}}
\end{ottdefnblock}
\caption{Statement Reduction-of-Argument Semantics}
\label{fig:semstmt2}
\end{figure}

\begin{figure}[ht!]
\begin{ottdefnblock}[#1]{$ { \mathit{ctx}_\mathit{A} }  \vdash  { \mathit{env}_\mathit{A} }   \mathit{ctx}  [  \ottnt{stmt}  ] (  \sigma  ,  t  ) \rightharpoonup  { \mathit{env}_\mathit{A} }'   \mathit{ctx}'  [  \ottnt{stmt'}  ] (  \sigma'  ,  t'  ) $}{\ottcom{architectural-level semantics}}
\ottusedrule{\ottdrulearchXXpblockXXargs{}}
\ottusedrule{\ottdrulearchXXffblockXXargs{}}
\end{ottdefnblock}
\caption{Architecture Reduction-of-Argument Semantics}
\label{fig:semarch2}
\end{figure}

\end{document}


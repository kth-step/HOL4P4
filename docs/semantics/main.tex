\documentclass[UTF8]{article}
%\documentclass[a4paper,11pt,reqno]{amsart}

\pagestyle{headings}
\usepackage{graphicx}
\usepackage[english]{babel}
\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}
\usepackage{verbatim}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{pstricks}
\usepackage{mathrsfs}
\usepackage{textcomp}
\usepackage{tikz}
\usepackage{subfig}
\usepackage{fancyvrb}

\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=cyan,
}

\usepackage{csquotes}
\usepackage[backend=biber]{biblatex}
\usepackage{todonotes}

\usepackage{supertabular}
\usepackage{geometry}
\usepackage{ifthen}
\usepackage{alltt}%hack

\include{p4_new_defs}

\addbibresource{p4.bib}
\newtheorem{thm}{Theorem}
\newtheorem{lemma}{Lemma}

\title{%
Pen-and-paper semantics for P4}
\author{Anoud Alshnakat\\
Didrik Lundberg
}
\date{\today}
\begin{document}
\maketitle
\noindent
This is a pen-and-paper semantics of P4, inspired by Core P4~\cite{doenges2021petr4}.

%\newpage
\section{Syntax}
\subsection{Types}
%
%TODO Base types (integers, booleans, bit strings, errors, headers...), function types (superset of base types also including tables, functions and constructors) and directions (in, out, inout), ...
%
\begin{figure}[h!]
\centering
\ottmetavars
\caption{P4 Types}
\end{figure}
%
TODO: P4 typing rules?
%
\newpage
\subsection{Expressions}
The \href{https://p4.org/p4-spec/docs/P4-16-v1.2.1.html#sec-exprs}{full set of P4 expressions} as stated by the P4 specification includes more than the expressions stated here.
%
%Let $b$ be a Boolean value and $\mathit{bs} = [b_1 , \ldots , b_n]$ a bitstring. As shown in Figure~\ref{fig:exp}, an expression is either the parser input ($\mathbf{In}$, a bitstring), or the parser output ($\mathbf{Out}$, a map from field names $f$ (strings) to bitstrings - supposed to represent a record), a comparison between two expressions, or a constant bitstring. Note that this means we have currently ignored most unary and binary expressions, keeping only the equality comparison.
%
%Note also that $\mathbf{In}$ and $\mathbf{Out}$ are hard-coded in the sense that they will syntactically be part of the execution state, which is introduced later on. More generally you might have something like just a variable environment, where the variable names $\mathbf{In}$ and $\mathbf{Out}$ map to their respective values.
%
%{\color{red} NOTE: $\mathbf{In}$ and $\mathbf{Out}$ could be renamed with a prefix ``Pars'' or similar, to distinguish them from direction types.}
%
\begin{figure}[h!]
\centering\ottgrammartabular{
\ottexp\ottafterlastrule
}
\caption{P4 Expressions}
\label{fig:exp}
\end{figure}
%
\newpage
\subsection{Statements}
See \href{https://p4.org/p4-spec/docs/P4-16-v1.2.1.html#sec-stmts}{Section 11} of the P4 specification.

%
\begin{figure}[h!]
\centering\ottgrammartabular{
\ottstmt\ottafterlastrule
}
\caption{P4 Statements}
\label{fig:stmt}
\end{figure}

\newpage
\newcommand{\state}{\Sigma}
\newcommand{\stacks}{\sigma}
\newcommand{\currsf}{\varepsilon}
\newcommand{\cstack}{E}
\newcommand{\status}{\textit{status}}
\subsection{Execution State}
The execution state $\state{}$ holds a current stack frame $\currsf$ (itself a stack of scopes created by blocks), a call stack $\cstack$ and the execution status \status{}. The tuple of the current stack frame and the call stack is abbreviated by $\stacks{}$. Note that none of these constructs are laid out in the P4 specification, but rather made up by yours truly.

The status \textbf{Running} represents that the parser is executing under regular circumstances. \textbf{TypeError} represents a crash caused by some badly-typed part of the program. \textbf{Return} is used to return a value from a function - for now, only 64-bit words.

\begin{figure}[h!]
\centering\ottgrammartabular{
\ottstatus\ottinterrule
\ottstate\ottafterlastrule
}
\caption{P4 Execution State}
\label{fig:status}
\end{figure}

\section{Semantics}
\subsection{Expressions}
%\begin{figure}[h!]
%\centering\ottgrammartabular{
%\ottexpXXsem\ottafterlastrule
%}
%\caption{Judgment Forms of P4 Expression Evaluation}
%\label{fig:judgexp}
%\end{figure}

\begin{figure}[h!]
\centering{\begin{ottdefnblock}[#1]{$ [  \ottnt{exp}  ] (  \sigma  ) \rightsquigarrow [  \ottnt{exp'}  ] (  \sigma'  ) $}{\ottcom{expression semantics}}
\ottusedrule{\ottdruleexpXXlookup{}}
\ottusedrule{\ottdruleexpXXfuncXXcallXXnoargs{}}
\ottusedrule{\ottdruleexpXXfuncXXexec{}}
\ottusedrule{\ottdruleexpXXfuncXXretXXexp{}}
\ottusedrule{\ottdruleexpXXbinopOne{}}
\ottusedrule{\ottdruleexpXXbinopTwo{}}
\end{ottdefnblock}}
\caption{P4 Expression Evaluation Semantics}
\label{fig:semexp}
\end{figure}

In the \textsc{exp\_lookup} rule, the first antecedent ensures that the variable $x$ is evaluated in the uppermost (i.e. most recent entered) scope of the current stack frame $\varepsilon$. This agrees with the description in Sections 6.8 and 10.2 in the P4 specification.

The \textsc{exp\_func\_cal\_noargs} rule is for the case of function calls inside expressions with no arguments. It takes the global scope ($\varepsilon [0]$) and uses this as the bottom element of a new current stack frame $\varepsilon '$ which has a fresh scope as head. The tail of the old current stack frame $\varepsilon$ is then pushed onto the call stack $E$, to be used later when returning from the function call. Note that this means duplicates of the global scope are not saved in the call stack. Finally, the body of the function ($\mathit{stmt}$) is obtained from $\mathit{func\_map}$, which holds mappings between function names $x$ and tuples of function bodies and argument names.

\href{https://p4.org/p4-spec/docs/P4-16-v1.2.1.html#sec-expr-eval-order}{Section 8.1} of the P4 specification states that expressions are evaluated left-to-right. Accordingly, our rules are split up so that (small-step) reduction of the second operand requires that the first operand has been completely reduced, illustrated by \textsc{exp\_binop1} and \textsc{exp\_binop2}.

\newpage
\subsection{Statement Execution}
%\begin{figure}[h!]
%\centering\ottgrammartabular{
%\ottpFourXXparserXXbstmtXXred\ottinterrule
%\ottpFourXXparserXXblockXXred\ottinterrule
%\ottpFourXXparserXXnblockXXred\ottafterlastrule
%}
%\caption{Judgment Forms of P4 Statement Execution}
%\label{fig:judgexec}
%\end{figure}

\begin{figure}[h!]
\ottdefnsstmtXXsem
\caption{P4 Statement Execution Semantics}
\label{fig:semstmtexec}
\end{figure}

%\begin{figure}[h!]
%\ottdefnspFourXXparserXXstrXXstmtXXred
%\caption{P4 Structural Statement Execution Semantics}
%\label{fig:semstmtexec}
%\end{figure}
%
%\begin{figure}[h!]
%\ottdefnspFourXXparserXXblockXXred
%\caption{P4 Parser State Execution Semantics}
%\label{fig:semblockexec}
%\end{figure}
%
%\begin{figure}[h!]
%\ottdefnspFourXXparserXXnblockXXred
%\caption{P4 $n$-Parser State Execution Semantics}
%\label{fig:semnblockexec}
%\end{figure}

\printbibliography
\end{document}


\documentclass[UTF8]{article}
%\documentclass[a4paper,11pt,reqno]{amsart}

\pagestyle{headings}
\usepackage{graphicx}
\usepackage[english]{babel}
\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}
\usepackage{verbatim}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{pstricks}
\usepackage{mathrsfs}
\usepackage{textcomp}
\usepackage{tikz}
\usepackage{subfig}
\usepackage{fancyvrb}

\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=cyan,
}

\usepackage{csquotes}
\usepackage[backend=biber]{biblatex}
\usepackage{todonotes}

\usepackage{supertabular}
\usepackage{geometry}
\usepackage{ifthen}
\usepackage{alltt}%hack


\newcommand*{\inference}[3][t]{%
   \begingroup
   \def\and{\\}%
   \begin{tabular}[#1]{@{\enspace}c@{\enspace}}
   #2 \\
   \hline
   #3
   \end{tabular}%
   \endgroup
}

\include{p4_defs}

\addbibresource{p4.bib}
\newtheorem{thm}{Theorem}
\newtheorem{lemma}{Lemma}

\title{%
The \texttt{p4ott} P4 Formalization}
\author{Anoud Alshnakat\\
Didrik Lundberg
}
\date{\today}
\begin{document}
\maketitle

\newcommand{\pfott}{\texttt{p4ott}}

\begingroup\lccode`?=`# \lowercase{\endgroup
\newcommand{\specsec}[1]{%
    ?#1%
}
}
\newcommand{\pfourspec}[2]{%
\href{https://p4lang.github.io/p4-spec/docs/P4-16-v1.2.2.html\specsec{#1}}{#2\kern-0.5ex} %Removes weird whitespace???
}
\noindent
This is a description of the \pfott{} formalization of P4, which includes a syntax and a strictly small-step style semantics. It is based on \pfourspec{}{the official P4 specification} and inspired by Core P4~\cite{doenges2021petr4}.

\pfott{} is constructed using the \texttt{ott} tool. \texttt{ott} files can then be exported to \LaTeX{} commands (used in this document) as well as to the HOL4, Isabelle/HOL and Coq interactive theorem provers (of which only the first is currently supported).

%\newpage
\section{Syntax}
\subsection{Types}
\newcommand{\num}{\ensuremath{i}}
\newcommand{\vn}{\ensuremath{x}}
\newcommand{\msg}{\ensuremath{\mathit{msg}}}
\newcommand{\fn}{\ensuremath{f}}
\newcommand{\inte}{\ensuremath{bl}}
%
%TODO Base types (integers, booleans, bit strings, errors, headers...), function types (superset of base types also including tables, functions and constructors) and directions (in, out, inout), ...
%
\begin{figure}[h!]
\centering
\ottmetavars
\caption{Variables}
\label{fig:vars}
\end{figure}

The variables shown in Figure~\ref{fig:vars} are standard designations for variables of \pfourspec{sec-base-types}{P4 base types} included in \pfott{}, plus the numerals \num{} and the indices $m, n, o$ which are not part of the P4 syntax, but used on a meta-level throughout this formalization. Depending on the context, strings are denoted with \vn{} (variable name), \fn{} (function or field name) or \msg{} (error message). The integer \inte{} is a list of Boolean values.

Types are sometimes explicitly referenced in the syntax, e.g. in declaration statements. The notation for this is shown in Figure~\ref{fig:types}. Subscript $t$ is used to clarify the notation refers to a type, as opposed to a variable of that type. Declared instances of composite types are stored in the type environment $T$.

\begin{figure}[h!]
\centering\ottgrammartabular{
\ottbt\ottinterrule
\ottt\ottinterrule
}
\caption{Types}
\label{fig:types}
\end{figure}

\newpage
\subsection{Expressions}
\newcommand{\fmap}{\textit{F}}

\pfott{} includes a subset of the full set of P4 expressions found in {\pfourspec{sec-exprs}{Section 8}} of the P4 specification, shown in Figure~\ref{fig:exp}.

\begin{figure}[h!]
\centering\ottgrammartabular{
\otte\ottafterlastrule
}
\caption{P4 Expressions}
\label{fig:exp}
\end{figure}
\newcommand{\stmt}{\textit{stmt}}
\newcommand{\cval}{\ensuremath{v}}
\newcommand{\fexec}[1]{\textbf{exec}\,\,#1}

First, an expression can be a value: a Boolean or an integer (collectively referred to as constant values \cval{}), or a variable name. Lists of expressions can be used in declarations of variables of struct types. The fields of these structs may be accessed, which is denoted in the usual manner. There exist unary and binary arithmetic operations, where the semantics of the individual operations are defined on some subset of the constants\footnote{The concrete syntax of the many unary and binary operations is found in Appendix~\ref{app:op}}. The function call is built from the function name \fn{}, and a list of arguments (expressions). In-progress execution of the body of a called function, \fexec{\stmt{}}, is not a part of the P4 syntax, but is rather an artifact of our small-step semantics.

The \textbf{select} expression is similar to a switch statement in C or Java. The expression $e$ is evaluated, and then matched against $v_1 , \ldots , v_n$. If some match is successful, the \textbf{select} expression evaluates to the string at the corresponding index. If no match occurs, then it instead evaluates to the default string $x$.

\newpage
\subsection{Statements}

\label{ssec:stmt}
\pfott{} includes a subset of the full set of P4 statements found in \pfourspec{sec-stmts}{Section 11} of the P4 specification, shown in Figure~\ref{fig:stmt}. They are mostly standard, apart from the following: the in-progress block is an artifact of our small-step semantics. The \textbf{verify} statement (here a statement and not an extern function as in \pfourspec{sec-verify}{Section 12.7} of the P4 specification) can be found uniquely in a parser block. It asserts the expressions $e$ and if it holds, does nothing. If $e$ does not hold, it jumps to a rejecting parser state with error message being the result of evaluating $e'$. The \textbf{transition} statement continues execution at a new parser state $p$.

\begin{figure}[h!]
\centering\ottgrammartabular{
\ottstmt\ottafterlastrule
}
\caption{P4 Statements}
\label{fig:stmt}
\end{figure}

The assignment can assign to $lval$s (shown in Figure~\ref{fig:lval}), which include variables identified by their names, and struct fields, which are identified by the struct and field names, similar to the field access expression.

\begin{figure}[h!]
\centering\ottgrammartabular{
\ottlval\ottafterlastrule
}
\caption{P4 l-values}
\label{fig:lval}
\end{figure}

\newpage
\newcommand{\exstate}{\ensuremath{s}}
\newcommand{\scope}{\ensuremath{\mathit{scope}}}
\newcommand{\stacks}{\ensuremath{\sigma}}
\newcommand{\currsf}{\ensuremath{\varepsilon}}
\newcommand{\gscope}{\ensuremath{{\gamma}_G}}
\newcommand{\escope}{\ensuremath{{\gamma}_{\emptyset}}}
\newcommand{\cstack}{E}
\newcommand{\status}{\ensuremath{t}}
\newcommand{\running}{\textbf{R}}
\newcommand{\returnst}[1]{\ensuremath{\textbf{Ret}\,\,#1}}
\newcommand{\accept}{\textbf{Accept}}
\newcommand{\reject}[1]{\textbf{Reject} #1}
\newcommand{\trans}[1]{\textbf{Trans} #1}
\newcommand{\sterr}{\ensuremath{\bot}}
\newcommand{\pfin}{\ensuremath{p_{\mathrm{fin}}}}
\subsection{Execution State}

The P4 execution state is shown in Figure~\ref{fig:status}. Note that nothing like this is described in the P4 specification, so it is entirely an artifice of the \pfott{} implementation. In short, the execution state \exstate{} is a tuple of the state memory \stacks{} and the state status \status{}. The state memory $\stacks{}$ consists of a tuple ($\currsf$, $\cstack$), where $\currsf$ is a stack of scopes $\gamma$ which hold the values of variables which are currently visible, and $\cstack$ holds variable mappings which belong to previous caller contexts.

\begin{figure}[h!]
\centering\ottgrammartabular{
\ottstatus\ottinterrule
\ottstate\ottafterlastrule
}
\caption{P4 Execution State}
\label{fig:status}
\end{figure}

More formally, a scope $\gamma : X \hookrightarrow V$ is a partial function from variable names $\vn{} \in X$ to constant values $\cval{} \in V$. The following operations can be performed on $\gamma$:
%TODO Notation for the below
\begin{itemize}
\item $\mathrm{dom} ( \gamma )$: Gets the domain of $\gamma$: obtains the set of variable names $\vn{} \in X$ which are mapped to values in $\gamma$.
\item $(\vn \mapsto  \cval) \,\, \gamma$: Updates a variable mapping in $\gamma$: yields the scope $\gamma'$, which is just $\gamma$ where \vn{} instead maps to \cval{}. By writing $\forall i \leq n. \,\, ({\vn}_i \mapsto  {\cval}_i) \,\, \gamma$ we extend this to lists of mappings from variable names to values.
\end{itemize}

A frame \currsf{} is a stack of scopes where the global scope \gscope{} is located at the bottom; that is, in location $\currsf [0]$. The current scope - that which was most recently entered by execution - is stored on the top of \currsf{}  (note that this indexing is the reverse of what you would expect from a list). Whenever a new block (delineated by $\{ \}$) is entered, a new fresh scope \escope{} is pushed onto the frame $\currsf$. %TODO New notation for pushing?
The following operations can be performed on a frame $\currsf$:
\begin{itemize}
\item $ \gamma :: \currsf$: Pushes a scope $\gamma$ on top of \currsf{}.
%TODO Append (++)
%\item Concatenating two $\gamma$ frames together.
%TODO Tail tl
\item $(\num \mapsto  \gamma) \,\, \currsf$: Updates the scope located at index \num{} of \currsf{} by setting it to $\gamma$.
\end{itemize}

The call stack $\cstack$ is a stack of frames used whenever a function call occurs. When a function call is executed, the frame \currsf{} (minus the global scope \gscope{}) of the caller will be pushed onto $\cstack$. When the callee function finishes execution and returns, \currsf{} will be popped from $\cstack$ and pushed onto a frame containing only \gscope{}. Note that this means that the same \gscope{} is kept throughout function calls, and updates to it are passed along accordingly. The following operations can be performed on $\cstack$: 
\begin{itemize}
\item $ \currsf :: \cstack$: Pushes a frame $\currsf$ onto the call stack $\cstack$.
\end{itemize}

The status \running{} represents that the program is executing under regular circumstances. \returnst{v} is used when the \textbf{return} statement returns a constant \cval{} at the end of a function call. The status $p$ signifies transition to a new parser state inside the parser - a named state in the case of \trans{\vn{}}, or a final state (\pfin{}) in the case of \accept{} or \reject{}. \sterr{} represents a crash or undefined behaviour, for example caused by some badly-typed part of the program. 

In addition to the above, there's also a function map $F$ mapping function names to tuples of their bodies and argument names, a parser map $P$ mapping parser state names to their bodies and a type environment $T$. These are assumed to be static, and are therefore not part of the execution state.

\section{Semantics}
\subsection{Expressions}
%\begin{figure}[h!]
%\centering\ottgrammartabular{
%\otteXXsem\ottafterlastrule
%}
%\caption{Judgment Forms of P4 Expression Evaluation}
%\label{fig:judgexp}
%\end{figure}

\begin{figure}[ht!]
\centering{\begin{ottdefnblock}[#1]{$ [  \ottnt{e}  ] (  \sigma  ) \rightsquigarrow [  \ottnt{e'}  ] (  \sigma'  ) $}{\ottcom{expression semantics}}
\ottusedrule{\ottdruleeXXlookup{}}
\ottusedrule{\ottdruleeXXfuncXXcallXXnewframe{}}
\ottusedrule{\ottdruleeXXfuncXXexec{}}
\ottusedrule{\ottdruleeXXfuncXXret{}}
\ottusedrule{\ottdruleeXXsXXacc{}}
\ottusedrule{\ottdruleeXXhXXacc{}}
\ottusedrule{\ottdruleeXXselXXacc{}}
\ottusedrule{\ottdruleeXXselXXdef{}}
\end{ottdefnblock}}
\caption{P4 Expression Evaluation Semantics}
\label{fig:semexp}
\end{figure}
\newcommand{\expr}{\ensuremath{e}}

The semantics of expressions is shown in Figure~\ref{fig:semexp}\footnote{The semantics for reducing concrete arithmetic operations is standard and covers everything found in Appendix~\ref{app:op}}\footnote{Rules for reducing expressions in all contexts can be found in Appendix~\ref{app:exp}}.
\\~\\
In the \textsc{e\_lookup} rule, the first antecedent states that $\num = \mathrm{max} \, \{ j . \,\, \vn  \in \mathrm{dom} ( $\currsf$ [j] ) \} $, which ensures that the variable name \vn{} is evaluated in the uppermost (i.e. most recently entered) scope of \currsf{} where it can be found. This agrees with the description in Sections \pfourspec{sec-name-resolution}{6.8} and \pfourspec{sec-variables}{10.2} of the P4 specification. The value of this variable is then resolved, and checked to be a constant.
\\~\\
The \textsc{e\_func\_call\_newframe} rule is used when all of the function arguments have been reduced to constants. The constants are assigned to their respective argument names in a fresh scope, after which this scope is put on top of the global scope \gscope{} in order to form the new current frame $\currsf '$. The old current frame \currsf{} (minus \gscope{}) is then saved on top of the call stack \cstack{} to be used later when returning from the function call, and the function call statement is reduced to $\mathbf{exec} \,\, \mathit{stmt}$ - in-progress execution of the function body \stmt{} (obtained from the function map \fmap{}, which holds mappings between function names \fn{} and tuples of function bodies and lists of their argument names). Note that this rule also covers the case of a function call with no arguments. The \textsc{e\_func\_exec} rule reduces the function body of in-progess execution with one statement reduction, and the \textsc{e\_func\_ret} rule reduces finished (empty) in-progress execution with status $\mathbf{Return} \,\, \expr$ to $\expr$, provided $\expr$ is a constant. This also changes the status to $\mathbf{Running}$.
\\~\\
The \textsc{e\_s\_acc} rule is used to access the values of fields in structs, and the \textsc{e\_h\_acc} rule is similarly used for headers.
\\~\\
The \textsc{e\_sel\_acc} rule is used to match the given value $v$ against the key-value list, in the case a match exists. The \textsc{e\_sel\_def} rule is used for the default case, when no match exists. 

\newpage
\subsection{Statement Execution}
The semantics of the statements is shown in Figures~\ref{fig:strsemstmtexec} and~\ref{fig:semstmtexec}\footnote{Rules for reducing expressions in all contexts are found in Appendix~\ref{app:exp}}.

%\begin{figure}[h!]
%\centering\ottgrammartabular{
%\ottpFourXXparserXXbstmtXXred\ottinterrule
%\ottpFourXXparserXXblockXXred\ottinterrule
%\ottpFourXXparserXXnblockXXred\ottafterlastrule
%}
%\caption{Judgment Forms of P4 Statement Execution}
%\label{fig:judgexec}
%\end{figure}

\begin{figure}[ht!]
\begin{ottdefnblock}{$\ottsym{[}  \ottnt{stmt}  \ottsym{]}  s  \rightarrow  \ottsym{[}  \ottnt{stmt'}  \ottsym{]}  s'$}{\ottcom{statement semantics}}
\ottusedrule{\ottdrulestmtXXdecl{}}
\ottusedrule{\ottdrulestmtXXassXXv{}}
\ottusedrule{\ottdrulestmtXXassXXs{}}
\ottusedrule{\ottdrulestmtXXassXXh{}}
\ottusedrule{\ottdrulestmtXXret{}}
\ottusedrule{\ottdrulestmtXXcondTwo{}}
\ottusedrule{\ottdrulestmtXXcondThree{}}
\end{ottdefnblock}
\caption{P4 Statement Execution Semantics}
\label{fig:semstmtexec}
\end{figure}
The \textsc{stmt\_decl} is used to reduce the \textbf{decl} statement, which has the effect of declaring variable mappings in the current (topmost) scope. The newly declared variable is given an uninitialized value, denoted by $?$.
\\~\\
The \textsc{stmt\_ass\_v} rule handles the assignment statement. In general, the variables that the program can assign values to are in the global scope \gscope{} or the current frame, thus we need to look up mappings in the current frame $\currsf$, but never in $\cstack$. So the antecedent $i = \mathrm{max} \{ j . \,\, x  \in \mathrm{dom} ( $\currsf$ [j] ) $ obtains the index $i$ of the uppermost (i.e. most recently entered) scope in the current frame $\currsf$ containing the variable. In the last antecedent, $ (\vn \longrightarrow \cval )\gamma $ updates the mapping of the variable name \vn{} to the new value (constant \cval{}) in the proper scope, that indeed lies in the current frame. The reduction results in the empty statement and an updated current frame.
\\~\\
The \textsc{stmt\_ass\_s} and \textsc{stmt\_ass\_h} rules handle the cases where the field of a struct or header are assigned to; specifically, they reduce $lval$s with field accesses to $f$ in the assignment to a $lval$ without field access, and the value $v$ to be assigned to $v'$, where $v'$ is the value of $lval$ (considered as an expression) looked up (lookup\_lval) in the current stack frame $\currsf$, with field $f$ set to $v$. Accordingly, for a $lval$ with $m$ nested field accesses, this rule will have to be applied $m$ times in order for \textsc{stmt\_ass\_v} to be used on the result.

Once the expression in the \textbf{return} statement has been reduced to a constant, the rule \textsc{stmt\_ret} can be applied. The global scope \gscope{} is always stored at the bottom (index zero) in the stack of scopes, i.e. $\currsf [0]$. It is fetched and concatenated with the frame of the most recent caller that is stored on top of the call stack $\cstack$. Thus, this concatenation will yield a new frame $\currsf$ that has the same shape as the one before the function being called (of course before reaching the \textbf{return} statement some variable mappings in the global scope \gscope{} could have been changed during function evaluation). The status is also changed to $\mathbf{Return} \,\, v$ which allows for applying \textsc{e\_func\_ret}.
\\~\\
The \textsc{stmt\_cond2} and \textsc{stmt\_cond3} rules are the standard ones for conditional statements.
\\~\\

\begin{figure}[ht!]
\begin{ottdefnblock}{$\ottsym{[}  \ottnt{stmt}  \ottsym{]}  s  \rightarrow  \ottsym{[}  \ottnt{stmt'}  \ottsym{]}  s'$}{\ottcom{statement semantics}}
\ottusedrule{\ottdrulestmtXXseqOne{}}
\ottusedrule{\ottdrulestmtXXseqTwo{}}
\ottusedrule{\ottdrulestmtXXseqThree{}}
\ottusedrule{\ottdrulestmtXXblockXXenter{}}
\ottusedrule{\ottdrulestmtXXblockXXexec{}}
\ottusedrule{\ottdrulestmtXXblockXXexit{}}
\end{ottdefnblock}
\caption{P4 Statement Execution Semantics: Structural Rules}
\label{fig:strsemstmtexec}
\end{figure}

The \textsc{stmt\_seq1} and \textsc{stmt\_seq2} rules are pretty standard. The \textsc{stmt\_seq3} rule is used in the situation when the \textbf{return} statement does not occur at the end of the the function body. The next statement to reduce will be empty and the status will be changed to \textbf{Return}, which is handled by \textsc{stmt\_ret}.
\\~\\
The \{\} brackets indicate a block, while the [ ] brackets indicate a block in progress of being executed.
The \textsc{stmt\_block\_enter} rule is used to enter a block, which entails a new empty scope \escope{} being pushed onto the current frame \currsf{}, and then the \{\} brackets are switched to the in-progress ones [ ] to signify that the block is currently being executed. The \textsc{stmt\_block\_exec} rule simply describes small-step reduction of the block contents, and the \textsc{stmt\_block\_exit} rule is used in the case where the end of a block is reached, i.e. whenever a block contains only an empty statement: it pops the scope corresponding to the block (the most recent one) from the frame $\currsf$.
\\~\\

\newcommand{\start}{\textit{start}}
\subsection{Parser}
The parser is a part of the P4 language which is generally used to parse packets from bit-string representations to structures of parsed headers, described in \pfourspec{sec-control}{Section 13} of the P4 specification. It can be thought of as describing a state machine with three unique states: a \start{} state, an \accept{} state and a \reject{\msg{}} state. A parser state $p$ (including \start{}, but not the abstract final states of \accept{} and \reject{\msg{}}) consists of a list of statements to be executed, with a transition statement at the end which decides the parser state to jump to next.

\begin{figure}[ht!]
\begin{ottdefnblock}{$\ottsym{[}  \ottnt{stmt}  \ottsym{]}  s  \rightarrow  \ottsym{[}  \ottnt{stmt'}  \ottsym{]}  s'$}{\ottcom{statement semantics}}
\ottusedrule{\ottdrulestmtXXverifyXXThree{}}
\ottusedrule{\ottdrulestmtXXverifyXXFour{}}
\ottusedrule{\ottdrulestmtXXtransXXOne{}}
\ottusedrule{\ottdrulestmtXXtransXXTwo{}}
\ottusedrule{\ottdrulestmtXXtransXXThree{}}
\end{ottdefnblock}
\caption{P4 Parser-Specific Statement Execution Semantics}
\label{fig:parssemstmtexec}
\end{figure}

The parser-specific statement semantics is shown in Figure~\ref{fig:parssemstmtexec}. The \textsc{stmt\_verify\_3} and \textsc{stmt\_verify\_4} rules describe the semantics of \textbf{verify}, the expressions having been reduced to values. If the condition holds, the reduction is to the empty statement (i.e. nothing happens and execution continues). If the condition does not hold, reduction is also to the empty statement, but state status is set to $\mathbf{Reject}\ x$. The \textsc{stmt\_trans} rules describe reduction of the $\mathbf{transition}$ statement, whose only effect on the state is to set status to indicate next parser state (the \textsc{pars\_state} or \textsc{pars\_t\_fin} rules can then be used next)

\begin{figure}[ht!]
\ottdefnsparsXXsem
\ottdefnsparsXXtXXsem
\caption{Parser Execution Semantics}
\label{fig:semparsexec}
\end{figure}

The parser state machine semantics is shown in Figure~\ref{fig:semparsexec}. Note the separate judgment form for the final step of the parser, which goes to a state with status \accept{} or \reject{} (representing the abstract accepting and rejecting states).

The \textsc{pars\_stmt} rule performs a single small-step reduction of the current statement (the body of the current parser state), while the \textsc{pars\_state} rule governs transition to the next parser state: if the current statement \stmt{} is reduced to $\stmt{}'$ with the status being \trans{\vn{}}, the next statement is the body of the parser state with name \vn{}, obtained from the map $P$ from parser state names to parser bodies.

The \textsc{pars\_t\_fin} rule says that when reduction using the statement semantics of the current statement results in a status with a final parser state $p_{\mathrm{fin}}$, this is also set as the status in the parser semantics. The \textsc{pars\_t\_empty} rule covers the special case when the statement semantics runs out of statements in a parser state, in which case the status is set to \reject{ParserStateEnd}.

\subsection{Control Blocks}
The control block is a part of the P4 language which is generally used to decide which actions to take (typically forwarding) based on the metadata (headers) which was extracted by the parser, as described in \pfourspec{sec-packet-parsing}{Section 12} of the P4 specification. The two main components of a control block is the match-action table and the actions themselves. Note that part of the functionality is separated into the control plane, which is interfaced with here using the $\mathrm{ctrl}(table\_name,\ v,\ m\_kind)$ function that takes a table name, constant value and matching kind and obtains an action name $f$ and a list of function arguments ${v_1}, ..., {v_n}$.
Actions can be thought of roughly as functions with no return values. The action can be called implicitly from the match-action process (i.e. in the table application), or explicitly from another action or a control block, as described in \pfourspec{sec-actions}{Section 13.1.1} of the P4 specification.

The \textsc{apply\_table\_e} rule performs small-step evaluation of the header expression used for the matching.

The \textsc{apply\_table\_v} looks up the table name in the table name map, then uses the result together with the header to be looked up to obtain an action (together with action arguments) from the control plane.

\begin{figure}[ht!]
\centering
\inference[c]{$[e](\sigma) \rightsquigarrow [e'](\sigma ')$ }
            {[$\mathbf{apply}\ table\_name\ e](\sigma) \rightarrow [\textbf{apply}\ table\_name \ e'](\sigma')$} \bigskip \textsc{apply\_table\_e}

\inference[c]{$\mathrm{t\_map}(table\_name) = (e', m\_kind)$
            \and $\mathrm{ctrl}(table\_name,\ v,\ m\_kind) = (f,\ {v_1}, ..., {v_n})$ } 
            {[$\textbf{apply}\ table\_name\ v](\sigma) \rightarrow [\textbf{call}\ f({v_1}, ..., {v_n})](\sigma ')$} \bigskip \textsc{apply\_table\_v}
\caption{Match-Action Semantics}
\label{fig:match}
\end{figure}  

\printbibliography

\clearpage
\appendix
\section{Concrete Syntax of Operations}
\label{app:op}
\begin{figure}[ht!]
\centering\ottgrammartabular{
\ottunop\ottafterlastrule
}
\caption{P4 Unary Operations}
\label{fig:unop}
\end{figure}

The unary expressions included are shown in Figure~\ref{fig:unop}. These include all of the unary operations in P4. Boolean negation is only defined on Booleans, the other operations have their standard meanings (note that \pfourspec{sec-bit-ops}{unary plus is a no-op}).

\newpage
\begin{figure}[ht!]
\centering\ottgrammartabular{
\ottbinop\ottafterlastrule
}
\caption{P4 Binary Operations}
\label{fig:binop}
\end{figure}

The binary expressions included are shown in Figure~\ref{fig:unop}. These include all of the binary operations in P4.

\section{Semantics of Expression Reduction}
\label{app:exp}
This appendix describes semantics for reducing expressions in certain contexts. The expression semantics are shown in Figure~\ref{fig:semexp2}. The statement semantics are shown in Figure~\ref{fig:semstmt2}.

\begin{figure}[ht!]
\centering{\begin{ottdefnblock}[#1]{$ [  \ottnt{e}  ] (  \sigma  ) \rightsquigarrow [  \ottnt{e'}  ] (  \sigma'  ) $}{\ottcom{expression semantics}}
\ottusedrule{\ottdruleeXXfuncXXcallXXargs{}}
\ottusedrule{\ottdruleeXXaccXXargTwo{}}
\ottusedrule{\ottdruleeXXaccXXargOne{}}
\ottusedrule{\ottdruleeXXselXXarg{}}
\ottusedrule{\ottdruleeXXunopXXarg{}}
\ottusedrule{\ottdruleeXXbinopXXargOne{}}
\ottusedrule{\ottdruleeXXbinopXXargTwo{}}
\end{ottdefnblock}}
\caption{P4 Expression Evaluation Semantics}
\label{fig:semexp2}
\end{figure}

The \textsc{e\_func\_call\_args} rule reduces the leftmost function argument which has yet to be reduced to a constant with one expression evaluation step. The first two antecedents divide the list of arguments into two sub-lists, where the prefix must contain all constants. The head of the suffix is then reduced with one step, after which the corresponding index in the original list of arguments is update with the resulting expression.
\\~\\
\pfourspec{sec-expr-eval-order}{8.1} of the P4 specification states that expressions are evaluated left-to-right. Accordingly, the rules for binary operations - \textsc{e\_binop1} and \textsc{e\_binop2} - are split up so that reduction of the second operand requires that the first operand has been completely reduced to a constant. This is trivial for unary operations (\textsc{e\_unop}).

\begin{figure}[ht!]
\begin{ottdefnblock}{$\ottsym{[}  \ottnt{stmt}  \ottsym{]}  s  \rightarrow  \ottsym{[}  \ottnt{stmt'}  \ottsym{]}  s'$}{\ottcom{statement semantics}}
\ottusedrule{\ottdrulestmtXXretXXe{}}
\ottusedrule{\ottdrulestmtXXassXXe{}}
\ottusedrule{\ottdrulestmtXXcondXXe{}}
\ottusedrule{\ottdrulestmtXXverifyXXeOne{}}
\ottusedrule{\ottdrulestmtXXverifyXXeTwo{}}
\end{ottdefnblock}
\caption{P4 Statement Execution Semantics}
\label{fig:semstmt2}
\end{figure}

\end{document}


\documentclass[UTF8]{article}
%\documentclass[a4paper,11pt,reqno]{amsart}

\pagestyle{headings}
\usepackage{graphicx}
\usepackage[english]{babel}
\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}
\usepackage{verbatim}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{pstricks}
\usepackage{mathrsfs}
\usepackage{textcomp}
\usepackage{tikz}
\usepackage{subfig}
\usepackage{fancyvrb}

\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=cyan,
}

\usepackage{csquotes}
\usepackage[backend=biber]{biblatex}
\usepackage{todonotes}

\usepackage{supertabular}
\usepackage{geometry}
\usepackage{ifthen}
\usepackage{alltt}%hack

\include{p4_defs}

\addbibresource{p4.bib}
\newtheorem{thm}{Theorem}
\newtheorem{lemma}{Lemma}

\title{%
Pen-and-paper semantics for P4}
\author{Anoud Alshnakat\\
Didrik Lundberg
}
\date{\today}
\begin{document}
\maketitle

\begingroup\lccode`?=`# \lowercase{\endgroup
\newcommand{\specsec}[1]{%
    ?#1%
}
}
\newcommand{\pfourspec}[2]{%
\href{https://p4lang.github.io/p4-spec/docs/P4-16-v1.2.2.html\specsec{#1}}{#2}
}
\noindent
This is a pen-and-paper semantics of P4, based on \pfourspec{}{the official P4 specification} and inspired by Core P4~\cite{doenges2021petr4}.

%\newpage
\section{Syntax}
\subsection{Types}
\newcommand{\num}{\textit{num}}
\newcommand{\str}{\textit{x}}
\newcommand{\msg}{\textit{m}}
\newcommand{\inte}{\textit{n}}
%
%TODO Base types (integers, booleans, bit strings, errors, headers...), function types (superset of base types also including tables, functions and constructors) and directions (in, out, inout), ...
%
\begin{figure}[h!]
\centering
\ottmetavars
\caption{Primitive Types}
\label{fig:types}
\end{figure}

The types shown in Figure~\ref{fig:types} are the subset of P4 types included in this formalization and their standard designations, plus the numerals \num{} and the indices which are not P4 types, but used throughout this formalization. A string \str{} can be used as a function name or a variable name. The integer \inte{} is a 64-bit word.

\newpage
\subsection{Expressions}
\newcommand{\fmap}{\textit{F}}

Our formalization includes a subset of the full set of P4 expressions found in \pfourspec{sec-exprs}{Section 8} of the P4 specification.

\begin{figure}[h!]
\centering\ottgrammartabular{
\ottexp\ottafterlastrule
}
\caption{P4 Expressions}
\label{fig:exp}
\end{figure}

The expressions included are shown in Figure~\ref{fig:exp}. First, an expression can be a Boolean or an integer (collectively referred to as constants), or a string. There exist unary and binary arithmetic operations, where the semantics of the individual operations are defined on some subset of the constants. The function call is built from the function name \str{}, and a list of arguments (expressions). Function execution is not found in any P4 program, but is rather an artifact of our semantics, signifying the in-progress execution of the body of a called function. The concrete syntax of unary and binary operations is found in Appendix~\ref{app:op}.

\newpage
\subsection{Statements}
\newcommand{\stmt}{\textit{stmt}}
\label{ssec:stmt}
See \pfourspec{sec-stmts}{Section 11} of the P4 specification.

%\begin{figure}[h!]
%\centering\ottgrammartabular{
%\ottstmt\ottafterlastrule
%}
%\caption{P4 Statements}
%\label{fig:stmt}
%\end{figure}

\newpage
\newcommand{\state}{\Sigma}
\newcommand{\scope}{\ensuremath{\mathit{scope}}}
\newcommand{\stacks}{\sigma}
\newcommand{\currsf}{\ensuremath{\varepsilon}}
\newcommand{\gscope}{\ensuremath{\currsf [0] }}
\newcommand{\cstack}{E}
\newcommand{\status}{\textit{status}}
\newcommand{\running}{\textbf{R}}
\newcommand{\returnst}{\textbf{Ret}}
\newcommand{\accept}{\textbf{Accept}}
\newcommand{\reject}[1]{\textbf{Reject} #1}
\newcommand{\trans}[1]{\textbf{Trans} #1}
\newcommand{\sterr}{\ensuremath{\bot}}
\newcommand{\pfin}{\ensuremath{p_{\mathrm{fin}}}}
\subsection{Execution State}
The execution state $\state{}$ holds a current stack frame $\currsf$ (a stack of scopes - denoted by \scope{} - created by $\{ \}$-enclosed blocks, with the global \scope{} at the bottom), a call stack $\cstack$ (where the current \currsf{} is stored when a function is called) and the execution status \status{}. The tuple of the current stack frame and the call stack is abbreviated by $\stacks{}$. Note that none of these constructs are laid out in the P4 specification, but rather made up by yours truly in order to obtain a formal P4 semantics.

The status \running{} represents that the program is executing under regular circumstances. \returnst{} is used when the \textbf{return} statement returns a constant inside a function. The status $p$ signifies transition to a new parser state inside the parser - a named state in the case of \trans{\str{}}, or a final state (\pfin{}) in the case of \accept{} or \reject{}. \sterr{} represents a crash or undefined behaviour, for example caused by some badly-typed part of the program. 

\begin{figure}[h!]
\centering\ottgrammartabular{
\ottstatus\ottinterrule
\ottstate\ottafterlastrule
}
\caption{P4 Execution State}
\label{fig:status}
\end{figure}

\section{Semantics}
\subsection{Expressions}
%\begin{figure}[h!]
%\centering\ottgrammartabular{
%\ottexpXXsem\ottafterlastrule
%}
%\caption{Judgment Forms of P4 Expression Evaluation}
%\label{fig:judgexp}
%\end{figure}

\begin{figure}[ht!]
\centering{\begin{ottdefnblock}[#1]{$ [  \ottnt{exp}  ] (  \sigma  ) \rightsquigarrow [  \ottnt{exp'}  ] (  \sigma'  ) $}{\ottcom{expression semantics}}
\ottusedrule{\ottdruleexpXXfuncXXcallXXnewframe{}}
\ottusedrule{\ottdruleexpXXfuncXXexec{}}
\ottusedrule{\ottdruleexpXXfuncXXretXXexp{}}
\ottusedrule{\ottdruleexpXXlookup{}}
\ottusedrule{\ottdruleexpXXacc{}}
\end{ottdefnblock}}
\caption{P4 Expression Evaluation Semantics}
\label{fig:semexp}
\end{figure}

The small-step semantics for reducing expressions is shown in Figure~\ref{fig:semexp}. Rules for reducing expressions in all contexts can be found in Appendix TODO.

In the \textsc{exp\_lookup} rule, the first antecedent ensures that the variable \str{} is evaluated in the uppermost (i.e. most recent entered) scope of the current stack frame \currsf{} where it is declared, by preventing \str{} to be in the domain of any \scope{} higher in \currsf{} than the one used for variable resolution. This agrees with the description in Sections \pfourspec{sec-name-resolution}{6.8} and \pfourspec{sec-variables}{10.2} of the P4 specification. The value of this variable is then resolved, and checked to be a constant.

The \textsc{exp\_func\_call\_args1} rule reduces the leftmost function argument which has yet to be reduced to a constant with one expression evaluation step. The first two antecedents divide the list of arguments into two sub-lists, where the prefix must contain all constants. The head of the suffix is then reduced with one expression small-step, after which the corresponding index in the original list of arguments is update with the resulting expression.

The \textsc{exp\_func\_call\_args2} rule is used when all of the function arguments have been reduced to constants using \textsc{exp\_func\_call\_args1} (or if they were all constants to begin with). The constants are assigned to their respective argument names in a fresh scope, after which this scope is put on top of the global scope \gscope{} in order to form the new current stack frame $\currsf '$. The old current stack frame \currsf{} is then saved on top of the call stack \cstack{} to be used later when returning from the function call, and the function call statement is reduced to $\mathbf{exec} \,\, \mathit{stmt}$ - in-progress execution of the function body \stmt{} (obtained from the function map \fmap{}, which holds mappings between function names \str{} and tuples of function bodies and lists of their argument names). Note that this rule also covers the case of a function call with no arguments.

The \textsc{exp\_func\_exec} rule reduces the function body of in-progess execution with one small-step statement reduction.

The \textsc{exp\_func\_ret\_exp} rule reduces finished (empty) in-progess execution with status $\mathbf{Return} \,\, \mathit{exp}$ to $\mathit{exp}$, provided $\mathit{exp}$ is a constant. This also changes the status to $\mathbf{Running}$.

\pfourspec{sec-expr-eval-order}{8.1} of the P4 specification states that expressions are evaluated left-to-right. Accordingly, the rules for binary operations - \textsc{exp\_binop1} and \textsc{exp\_binop2} - are split up so that (small-step) reduction of the second operand requires that the first operand has been completely reduced to a constant. This is trivial for unary operations (\textsc{exp\_unop}).

\newpage
\subsection{Statement Execution}
%\begin{figure}[h!]
%\centering\ottgrammartabular{
%\ottpFourXXparserXXbstmtXXred\ottinterrule
%\ottpFourXXparserXXblockXXred\ottinterrule
%\ottpFourXXparserXXnblockXXred\ottafterlastrule
%}
%\caption{Judgment Forms of P4 Statement Execution}
%\label{fig:judgexec}
%\end{figure}

\begin{figure}[ht!]
\ottdefnsstmtXXsem
\caption{P4 Statement Execution Semantics}
\label{fig:semstmtexec}
\end{figure}

\newcommand{\start}{\textit{start}}
\subsection{Parser}
The parser is a part of the P4 language which is generally used to parse packets from bit-string representations to structures of parsed headers, described in \pfourspec{sec-packet-parsing}{Section 12} of the P4 specification. It can be thought of as describing a state machine with three unique states: a \start{} state, an \accept{} state and a \reject{\msg{}} state. A parser state $p$ (including \start{}, but not the abstract final states of \accept{} and \reject{\msg{}}) consists of a list of statements to be executed, with a transition statement at the end which decides the parser state to jump to next.
\begin{figure}[ht!]
\ottdefnsparsXXsem
\ottdefnsparsXXtXXsem
\caption{Parser Execution Semantics}
\label{fig:semparsexec}
\end{figure}

The parser semantics is shown in Figure~\ref{fig:semparsexec}. Note the separate judgment form for the final step of the parser, which goes to a state with status \accept{} or \reject{} (representing the abstract accepting and rejecting states).

The \textsc{pars\_stmt} rule performs a single small step reduction of the current statement (the body in-execution of the current parser state), while the \textsc{pars\_state} rule governs transition to the next parser state: if the current statement \stmt{} is reduced to $\stmt{}'$ with the status being \trans{\str{}}, the next statement is the body of the parser state with name \str{}, obtained from the map $P$ from parser state names to parser bodies.

The \textsc{pars\_t\_fin} rule says that when reduction using the statement semantics of the current statement results in a status with a final parser state $p_{\mathrm{fin}}$, this is also set as the status in the parser semantics. The \textsc{pars\_t\_empty} rule covers the special case when the statement semantics runs out of statements in a parser state, in which case the status is set to \reject{ParserStateEnd}.

\printbibliography

\clearpage
\appendix
\section{Concrete Syntax of Operations}
\label{app:op}
\begin{figure}[ht!]
\centering\ottgrammartabular{
\ottunop\ottafterlastrule
}
\caption{P4 Unary Operations}
\label{fig:unop}
\end{figure}

The unary expressions included are shown in Figure~\ref{fig:unop}. These include all of the unary operations in P4. Boolean negation is only defined on Booleans, the other operations have their standard meanings (note that \pfourspec{sec-bit-ops}{unary plus is a no-op}).

\newpage
\begin{figure}[ht!]
\centering\ottgrammartabular{
\ottbinop\ottafterlastrule
}
\caption{P4 Binary Operations}
\label{fig:binop}
\end{figure}

The binary expressions included are shown in Figure~\ref{fig:unop}. These include all of the binary operations in P4.

\end{document}


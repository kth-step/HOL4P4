\documentclass[UTF8]{article}
%\documentclass[a4paper,11pt,reqno]{amsart}

\pagestyle{headings}
\usepackage{graphicx}
\usepackage[english]{babel}
\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}
\usepackage{verbatim}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{pstricks}
\usepackage{mathrsfs}
\usepackage{textcomp}
\usepackage{tikz}
\usepackage{subfig}
\usepackage{fancyvrb}

\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=cyan,
}

\usepackage{csquotes}
\usepackage[backend=biber]{biblatex}
\usepackage{todonotes}

\usepackage{supertabular}
\usepackage{geometry}
\usepackage{ifthen}
\usepackage{alltt}%hack


\newcommand*{\inference}[3][t]{%
   \begingroup
   \def\and{\\}%
   \begin{tabular}[#1]{@{\enspace}c@{\enspace}}
   #2 \\
   \hline
   #3
   \end{tabular}%
   \endgroup
}

\include{p4_defs}

\addbibresource{p4.bib}
\newtheorem{thm}{Theorem}
\newtheorem{lemma}{Lemma}

\title{%
Pen-and-paper semantics for P4}
\author{Anoud Alshnakat\\
Didrik Lundberg
}
\date{\today}
\begin{document}
\maketitle

\begingroup\lccode`?=`# \lowercase{\endgroup
\newcommand{\specsec}[1]{%
    ?#1%
}
}
\newcommand{\pfourspec}[2]{%
\href{https://p4lang.github.io/p4-spec/docs/P4-16-v1.2.2.html\specsec{#1}}{#2}
}
\noindent
This is a pen-and-paper semantics of P4, based on \pfourspec{}{the official P4 specification} and inspired by Core P4~\cite{doenges2021petr4}. It is written in a stricty small-step style.

%\newpage
\section{Syntax}
\subsection{Types}
\newcommand{\num}{\ensuremath{i}}
\newcommand{\vn}{\ensuremath{x}}
\newcommand{\mg}{\ensuremath{\mathit{msg}}}
\newcommand{\fn}{\ensuremath{f}}
\newcommand{\msg}{\ensuremath{m}}
\newcommand{\inte}{\ensuremath{n_w}}
%
%TODO Base types (integers, booleans, bit strings, errors, headers...), function types (superset of base types also including tables, functions and constructors) and directions (in, out, inout), ...
%
\begin{figure}[h!]
\centering
\ottmetavars
\caption{Primitive Types}
\label{fig:types}
\end{figure}

The types shown in Figure~\ref{fig:types} include the subset of \pfourspec{sec-base-types}{P4 base types} included in this formalization and their standard designations, plus the numerals \num{} and the indices $m, n, o$ which are not part of the P4 syntax, but used on a meta-level throughout this formalization. Depending on the context, strings are denoted with \vn{} (variable name), \fn{} (function or field name) or \mg{} (error message). The integer \inte{} is a 64-bit word.

\newpage
\subsection{Expressions}
\newcommand{\fmap}{\textit{F}}

Our formalization includes a subset of the full set of P4 expressions found in \pfourspec{sec-exprs}{Section 8} of the P4 specification.

\begin{figure}[h!]
\centering\ottgrammartabular{
\otte\ottafterlastrule
}
\caption{P4 Expressions}
\label{fig:exp}
\end{figure}
\newcommand{\stmt}{\textit{stmt}}
\newcommand{\cval}{\ensuremath{v}}
\newcommand{\fexec}[1]{\textbf{exec}\,\,#1}

The expressions included are shown in Figure~\ref{fig:exp}. First, an expression can be a Boolean or an integer (collectively referred to as constant values \cval{}), or a string. There exist unary and binary arithmetic operations, where the semantics of the individual operations are defined on some subset of the constants\footnote{The concrete syntax of unary and binary operations is found in Appendix~\ref{app:op}}. The function call is built from the function name \fn{}, and a list of arguments (expressions). In-progress execution of the body of a called function, \fexec{\stmt{}}, is not a part of the P4 syntax, but is rather an artifact of our small-step semantics.

\newpage
\subsection{Statements}

\label{ssec:stmt}
See \pfourspec{sec-stmts}{Section 11} of the P4 specification.

%\begin{figure}[h!]
%\centering\ottgrammartabular{
%\ottstmt\ottafterlastrule
%}
%\caption{P4 Statements}
%\label{fig:stmt}
%\end{figure}

\newpage
\newcommand{\exstate}{\ensuremath{s}}
\newcommand{\scope}{\ensuremath{\mathit{scope}}}
\newcommand{\stacks}{\ensuremath{\sigma}}
\newcommand{\currsf}{\ensuremath{\varepsilon}}
\newcommand{\gscope}{\ensuremath{{\gamma}_G}}
\newcommand{\escope}{\ensuremath{{\gamma}_{\emptyset}}}
\newcommand{\cstack}{E}
\newcommand{\status}{\ensuremath{t}}
\newcommand{\running}{\textbf{R}}
\newcommand{\returnst}[1]{\ensuremath{\textbf{Ret}\,\,#1}}
\newcommand{\accept}{\textbf{Accept}}
\newcommand{\reject}[1]{\textbf{Reject} #1}
\newcommand{\trans}[1]{\textbf{Trans} #1}
\newcommand{\sterr}{\ensuremath{\bot}}
\newcommand{\pfin}{\ensuremath{p_{\mathrm{fin}}}}
\subsection{Execution State}
\begin{figure}[h!]
\centering\ottgrammartabular{
\ottstatus\ottinterrule
\ottstate\ottafterlastrule
}
\caption{P4 Execution State}
\label{fig:status}
\end{figure}

A scope $\gamma : X \hookrightarrow V$ is a partial function from variable names $\vn{} \in X$ to constant values $\cval{} \in V$. The following operations can be performed on $\gamma$:
%TODO Notation for the below
\begin{itemize}
\item $\mathrm{dom} ( \gamma )$: Gets the domain of $\gamma$. Obtains the set of variable names $\vn{} \in X$ which are mapped to values in $\gamma$.
\item $(\vn \mapsto  \cval) \,\, \gamma$: Updates a variable mapping in $\gamma$. Yields the scope $\gamma'$, which is just $\gamma$ where \vn{} instead maps to \cval{}. By writing $\forall i \leq n. \,\, ({\vn}_i \mapsto  {\cval}_i) \,\, \gamma$ we extend this to lists of variables and values.
\end{itemize}

A frame \currsf{} is a stack of $\gamma$ where the global scope \gscope{} is located at the bottom; that is, in location $\currsf [0]$. The current scope - that which was most recently entered by execution - is stored on the top of \currsf{}  (note that the indexing is the reverse of what you would expect from a list). Whenever a new block (delineated by $\{ \}$) is entered, a new fresh scope \escope{} is pushed onto the frame $\currsf$. %TODO New notation for pushing?
The following operations can be performed on $\currsf$:
\begin{itemize}
\item $ \escope :: \currsf$: Pushes a new $\gamma$ on top of \currsf{}.
%TODO Append (++)
%\item Concatenating two $\gamma$ frames together.
%TODO Tail tl
\item $(\num \mapsto  \gamma) \,\, \currsf$: Updates a scope located at index \num{} of \currsf{} by setting it to $\gamma$.
\end{itemize}

The call stack $\cstack$ is a stack of frames $\currsf$ used whenever a function call occurs. When a function call is executed, the frame of the caller \currsf{} (minus the global scope \gscope{}) will be pushed onto $\cstack$. When the callee function finishes execution and returns, \currsf{} will be popped from $\cstack$ and pushed onto a frame containing only \gscope{}. Note that this means that the same \gscope{} is kept throughout function calls, and updates to it are passed along accordingly. The following operations can be performed on $\cstack$: 
\begin{itemize}
\item $ \currsf :: \cstack$: Pushes a frame $\currsf$ onto the call stack $\cstack$.
\end{itemize}

The state memory $\stacks{}$ consists of a tuple ($\currsf$, $\cstack$), where $\currsf$ holds the values of variables which are currently visible, and $\cstack$ holds variable mappings which belong to previous caller contexts.
\\~\\
The status is denoted by \status{}. The status \running{} represents that the program is executing under regular circumstances. \returnst{v} is used when the \textbf{return} statement returns a constant \cval{} at the end of a function call. The status $p$ signifies transition to a new parser state inside the parser - a named state in the case of \trans{\vn{}}, or a final state (\pfin{}) in the case of \accept{} or \reject{}. \sterr{} represents a crash or undefined behaviour, for example caused by some badly-typed part of the program. 
\\~\\
The execution state \exstate{} is a tuple of \stacks{} and \status{}. Note that none of these constructs are laid out in the P4 specification, but rather made up by yours truly in order to obtain a formal P4 semantics.

\section{Semantics}
\subsection{Expressions}
%\begin{figure}[h!]
%\centering\ottgrammartabular{
%\otteXXsem\ottafterlastrule
%}
%\caption{Judgment Forms of P4 Expression Evaluation}
%\label{fig:judgexp}
%\end{figure}

\begin{figure}[ht!]
\centering{\begin{ottdefnblock}[#1]{$ [  \ottnt{e}  ] (  \sigma  ) \rightsquigarrow [  \ottnt{e'}  ] (  \sigma'  ) $}{\ottcom{expression semantics}}
\ottusedrule{\ottdruleeXXfuncXXcallXXnewframe{}}
\ottusedrule{\ottdruleeXXfuncXXexec{}}
\ottusedrule{\ottdruleeXXfuncXXretXXe{}}
\ottusedrule{\ottdruleeXXlookup{}}
%\ottusedrule{\ottdruleeXXacc{}}
\end{ottdefnblock}}
\caption{P4 Expression Evaluation Semantics}
\label{fig:semexp}
\end{figure}
\newcommand{\expr}{\ensuremath{e}}

The semantics for reducing expressions is shown in Figure~\ref{fig:semexp}. Rules for reducing expressions in all contexts can be found in Appendix~\ref{app:exp}.
\\~\\
The \textsc{e\_func\_call\_newframe} rule is used when all of the function arguments have been reduced to constants (or if they were all constants to begin with). The constants are assigned to their respective argument names in a fresh scope, after which this scope is put on top of the global scope \gscope{} in order to form the new current frame $\currsf '$. The old current frame \currsf{} (minus \gscope{}) is then saved on top of the call stack \cstack{} to be used later when returning from the function call, and the function call statement is reduced to $\mathbf{exec} \,\, \mathit{stmt}$ - in-progress execution of the function body \stmt{} (obtained from the function map \fmap{}, which holds mappings between function names \fn{} and tuples of function bodies and lists of their argument names). Note that this rule also covers the case of a function call with no arguments.
\\~\\
The \textsc{e\_func\_exec} rule reduces the function body of in-progess execution with one statement reduction.
\\~\\
The \textsc{e\_func\_ret\_e} rule reduces finished (empty) in-progress execution with status $\mathbf{Return} \,\, \expr$ to $\expr$, provided $\expr$ is a constant. This also changes the status to $\mathbf{Running}$.
\\~\\
In the \textsc{e\_lookup} rule, the first antecedent states that $\num = \mathrm{max}  \{ j . \,\, \vn  \in \mathrm{dom} ( $\currsf$ [j] ) \} $, which ensures that the variable name \vn{} is evaluated in the uppermost (i.e. most recently entered) scope of \currsf{} where it can be found. This agrees with the description in Sections \pfourspec{sec-name-resolution}{6.8} and \pfourspec{sec-variables}{10.2} of the P4 specification. The value of this variable is then resolved, and checked to be a constant.

\newpage
\subsection{Statement Execution}
The semantics of the statements is shown in Figure~\ref{fig:semstmtexec}.
\\~\\
The \textsc{stmt\_ret\_e} rule implements one reduction to the expression at a time, to simplify the expression until it reduces to a constant. 
Once the \textbf{return} statement appears to return a constant the rule \textsc{stmt\_ret\_const} contains the antecedents that are required for such operation. The global scope \gscope{} is always stored at the bottom (index zero) in the stack of scopes, i.e. $\currsf [0]$. It is fetched and concatenated with most recent caller that was stored on top of the call stack $\cstack$. Thus, this concatenation will generate a $\currsf$ that has the same shape to the one before the function being called (of course before reaching the \textbf{return} statement some global variables could have been changed during function evaluation, that is the reason why we say that the shape is the same but not the variable mappings in the global scope \gscope{}). The status will be changed to $\mathbf{Return} \,\, v$ where it will be handled later in an other rule. 
\\~\\
The \textsc{stmt\_ass\_e} rule implements one reduction to the expression at a time, to simplify the expression until it reduces to a constant.
The \textsc{stmt\_ass\_const} rule handles assignment statement. In general, the variables that the program can assign values to it should be in the global scope \gscope{} or the current scope of the frame, thus we need to look up into the current frame $\currsf$, but never into $\cstack$. So the antecedent $i = max \{ j . \,\, x  \in \mathrm{dom} ( $\currsf$ [j] ) $ fetches the proper index that locates the variable location, it should be the one in the uppermost part of the the current frame $\currsf$ (i.e. oldest entry). In the last antecedent, $ (\vn \longrightarrow \cval )scope $ updates the mapping of the variable name \vn{} to the new value (constant \cval{}) in the proper frame location, that indeed lies in the current frame. One step reduction in this rule results an updated current frame, and an empty statement to execute.
\\~\\
The \textsc{stmt\_seq1} and \textsc{stmt\_seq2} rules are trivial to understand, they are pretty standard.
\\~\\
The \textsc{stmt\_seq3} handles the \textbf{return} statement when it does not occur at the end of the the function code. The next statement to reduce will be empty and the status will be changed to \textbf{Return} that will be handled later.
\\~\\
The \textsc{stmt\_cond1}, \textsc{stmt\_cond2} and \textsc{stmt\_cond3} rules are pretty trivial to understand.
\\~\\
The \textsc{stmt\_decl} rule is a transition reduction for the declaration statements. Whenever a variable is declared, it will updated in the most recent scope and reduce the transition to an empty statement. The most recent/newest scope is fetched simply by checking the length of the current frame $\currsf$. 
\\~\\
The \textbf{\{\}} brackets indicates a block, while the \textbf{[ ]} brackets indicates a block being executed.
Whenever entering a block, in rule \textsc{stmt\_block\_enter}, a new empty scope \escope{} is added to the current frame \currsf{}, and then the \textbf{\{\}} brackets are switched the executing ones \textbf{[ ]} to pinpoint the fact that the statements can be executed now.
\\~\\
\textsc{stmt\_block\_exec} rule shows a small step reduction for the statements inside a block.
\\~\\
\textsc{stmt\_block\_exit} rule handles the block termination. Whenever a block contains an empty statement, then it is necessary to also remove the corresponding scope from the frame $\currsf$ which in the case of blocks is the most recent one.

%\begin{figure}[h!]
%\centering\ottgrammartabular{
%\ottpFourXXparserXXbstmtXXred\ottinterrule
%\ottpFourXXparserXXblockXXred\ottinterrule
%\ottpFourXXparserXXnblockXXred\ottafterlastrule
%}
%\caption{Judgment Forms of P4 Statement Execution}
%\label{fig:judgexec}
%\end{figure}

\begin{figure}[ht!]
\ottdefnsstmtXXsem
\caption{P4 Statement Execution Semantics}
\label{fig:semstmtexec}
\end{figure}

\newcommand{\start}{\textit{start}}
\subsection{Parser}
The parser is a part of the P4 language which is generally used to parse packets from bit-string representations to structures of parsed headers, described in \pfourspec{sec-packet-parsing}{Section 12} of the P4 specification. It can be thought of as describing a state machine with three unique states: a \start{} state, an \accept{} state and a \reject{\msg{}} state. A parser state $p$ (including \start{}, but not the abstract final states of \accept{} and \reject{\msg{}}) consists of a list of statements to be executed, with a transition statement at the end which decides the parser state to jump to next.
\begin{figure}[ht!]
\ottdefnsparsXXsem
\ottdefnsparsXXtXXsem
\caption{Parser Execution Semantics}
\label{fig:semparsexec}
\end{figure}

The parser semantics is shown in Figure~\ref{fig:semparsexec}. Note the separate judgment form for the final step of the parser, which goes to a state with status \accept{} or \reject{} (representing the abstract accepting and rejecting states).

The \textsc{pars\_stmt} rule performs a single small step reduction of the current statement (the body in-execution of the current parser state), while the \textsc{pars\_state} rule governs transition to the next parser state: if the current statement \stmt{} is reduced to $\stmt{}'$ with the status being \trans{\vn{}}, the next statement is the body of the parser state with name \vn{}, obtained from the map $P$ from parser state names to parser bodies.

The \textsc{pars\_t\_fin} rule says that when reduction using the statement semantics of the current statement results in a status with a final parser state $p_{\mathrm{fin}}$, this is also set as the status in the parser semantics. The \textsc{pars\_t\_empty} rule covers the special case when the statement semantics runs out of statements in a parser state, in which case the status is set to \reject{ParserStateEnd}.

\subsection{Control Blocks}
 The match-action table takes the meta data (headers) after it was extracted in the parser. Note that here there are is a control plane and a data plane. 
Syntactically actions resemble functions with no return value, the body of the action contains statements and declarations. The action can be called implicitly from the match-action process(i.e. means in the table apply), or explicitly from an other action or a control block. (section 12.1 p4).

The first rule shows that the header (as an expression) needs to be evaluated, and in this case, extract the required field for the matching. 
We still need to add expression list because there can be multiple keys.

\bigskip
apply table e:
\bigskip
\inference[c]{<e>($\sigma$) $\rightsquigarrow$ <e'>($\sigma '$) }
            {[apply table\_name e]($\sigma$) $\rightarrow$ [apply\ table\_name \ e']($\sigma'$)} \bigskip

\bigskip
apply table const:
\bigskip
\inference[c]{t\_map(table\_name) = (e', m\_kind)
            \and ctrl(table\_name, const, m\_kind) = (f, ${v_1}, ..., {v_n}$) } 
            {[apply table\_name const]($\sigma$) $\rightarrow$ [call f (${v_1}, ..., {v_n}$)]($\sigma '$)}
\bigskip
              

\printbibliography

\clearpage
\appendix
\section{Concrete Syntax of Operations}
\label{app:op}
\begin{figure}[ht!]
\centering\ottgrammartabular{
\ottunop\ottafterlastrule
}
\caption{P4 Unary Operations}
\label{fig:unop}
\end{figure}

The unary expressions included are shown in Figure~\ref{fig:unop}. These include all of the unary operations in P4. Boolean negation is only defined on Booleans, the other operations have their standard meanings (note that \pfourspec{sec-bit-ops}{unary plus is a no-op}).

\newpage
\begin{figure}[ht!]
\centering\ottgrammartabular{
\ottbinop\ottafterlastrule
}
\caption{P4 Binary Operations}
\label{fig:binop}
\end{figure}

The binary expressions included are shown in Figure~\ref{fig:unop}. These include all of the binary operations in P4.

\section{Semantics of Expression Reduction}
\label{app:exp}
This appendix describes semantics for reducing expressions in certain contexts. The expression semantics are shown in Figure~\ref{fig:semexp2}.

\begin{figure}[ht!]
\centering{\begin{ottdefnblock}[#1]{$ [  \ottnt{e}  ] (  \sigma  ) \rightsquigarrow [  \ottnt{e'}  ] (  \sigma'  ) $}{\ottcom{expression semantics}}
\ottusedrule{\ottdruleeXXfuncXXcallXXargs{}}
\ottusedrule{\ottdruleeXXaccXXargTwo{}}
\ottusedrule{\ottdruleeXXaccXXargOne{}}
\ottusedrule{\ottdruleeXXunopXXarg{}}
\ottusedrule{\ottdruleeXXbinopXXargOne{}}
\ottusedrule{\ottdruleeXXbinopXXargTwo{}}
\end{ottdefnblock}}
\caption{P4 Expression Evaluation Semantics}
\label{fig:semexp2}
\end{figure}

The \textsc{e\_func\_call\_args} rule reduces the leftmost function argument which has yet to be reduced to a constant with one expression evaluation step. The first two antecedents divide the list of arguments into two sub-lists, where the prefix must contain all constants. The head of the suffix is then reduced with one step, after which the corresponding index in the original list of arguments is update with the resulting expression.
\\~\\
\pfourspec{sec-expr-eval-order}{8.1} of the P4 specification states that expressions are evaluated left-to-right. Accordingly, the rules for binary operations - \textsc{e\_binop1} and \textsc{e\_binop2} - are split up so that reduction of the second operand requires that the first operand has been completely reduced to a constant. This is trivial for unary operations (\textsc{e\_unop}).

\end{document}


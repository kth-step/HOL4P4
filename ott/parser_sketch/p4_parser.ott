embed
{{ hol
open wordsTheory;
}}
metavar string ::=
      {{ lex alphanum }}
      {{ hol string }}
      {{ com string }}
metavar num ::=
      {{ lex numeral }}
      {{ hol num }}
      {{ com natural number }}
metavar bool ::=
      {{ lex numeral }}
      {{ hol bool }}
      {{ com boolean }}
metavar int ::=
      {{ lex numeral }}
      {{ hol word64 }}
      {{ com integer }}
indexvar i, j, k, l ::=
  {{ lex numeral }}
  {{ coq nat }}
  {{ hol num }}
grammar

%This is a sketch of the semantics of a fragment of the P4 parser.
%For a more detailed description, see https://p4.org/p4-spec/docs/P4-16-v1.2.1.html#sec-packet-parsing


%Bitvector (simple representation)
%TODO Add some exceptional value?
bit_vector :: bit_vector_ ::=
| [ bool1 , ... , booli ] :: :: vec

err_msg :: err_msg_ ::=
| string :: :: text


%%%%%%%%%%%%%%%%%%%
% Execution state %
%%%%%%%%%%%%%%%%%%%

%Execution status.
%Note that this is made up for verification purposes.
exec_status :: exec_status_ ::=
 {{ com Execution status }}
| Running :: :: running
| TypeError :: :: type_error
| Reject err_msg :: :: reject
| JumpOutside :: :: jump_outside
% Parser accept?
% Parser reject?

in :: in_ ::=
| bit_vector :: :: vec

%TODO Generalise record types...

out_rec_entry :: out_rec_entry_ ::=
| string = bit_vector :: :: str_vec

out :: out_ ::=
| <| out_rec_entry1 ; ... ; out_rec_entryi |> :: :: rec

%Maybe be for HOL4 this could use some record type that has been defined in some preamble
exec_state :: exec_state_ ::=
| <| status = exec_status ; pstate_name = string ; pstate_index = num ; input = in ; output = out |> :: :: rec


%%%%%%%%%%%%%%%
% Expressions %
%%%%%%%%%%%%%%%

exp_val :: exp_val_ ::=
| in :: :: vec
| out . string :: :: fld

out_field :: out_field_ ::=
| out . string :: :: fld

%Expressions need only be equalities for now... 
exp :: exp_ ::=
| p4_val == p4_val :: :: equality


%%%%%%%%%%%
% Program %
%%%%%%%%%%%


bstmt :: bstmt_ ::=
| verify( exp , err_msg ) :: :: verif
| extract( string ) :: :: extr

trs :: trs_ ::=
| transition( string ) :: :: uncond

%A parser state has a name, a list of statements and a final transition statement
pstate :: pstate_ ::=
| { [ bstmt1 , ... , bstmti ] transition( trs ) }

%In our case, the program fragment is simply a list of parser states
program :: program_ ::=
| pstate1 , ... , pstatei


subrules
  out_field <:: exp_val

%%%%%%%%%%%%%%%%%%%%%%%%
% Expression semantics %
%%%%%%%%%%%%%%%%%%%%%%%%

defns
JFld :: ” ::=

  defn
  [[ O.out_field ]]( exec_state ) --> bit_vector :: :: eval_fld ::” {{ com O.$[[out_field]]$ evaluates to $[[bit_vector]]$}} by


   exec_state.output = O
   O.fld = bvec
   -------------------------------------  :: fld
   [[O.fld]]( exec_state ) --> bvec


%   size(fld) = sz
%   i = [v1, ..., vn]
%   vn < sz
%   -----------------------  :: fld_error
%   [[fld]](in, out) --> TypeError


JExp :: ” ::=

   defn
   %Currently, we only need evaluation to Boolean, possibly with some exceptional value (resulting in TypeError)
   [ exp ]( exec_state ) --> bool :: ::eval_exp::” {{ com $[[p4_exp]]$ evaluates to $[[bool]]$}} by


   --------------------------  :: eq
   [ I == O.fld ]( exec_state ) --> (exec_state.input = [[ O.fld ]]( exec_state ))


%%%%%%%%%%%%%%%%%%%%
% Parser semantics %
%%%%%%%%%%%%%%%%%%%%

JParser :: ” ::=

  defn
%	P ; s -> s'
  program ; exec_state --> exec_state :: :: exec_parser ::” {{ com Effect of parser execution}} by



%Execution of verify statement, case property holds
	exec_state1.status = Running
	P(exec_state1.pstate_index, exec_state1.pstate_name) = verify(p, err)
	[p](exec_state1)
	exec_state2.n = exec_state1.n + 1
   --------------------------  :: verif_pass
	P ; exec_state1 -> exec_state2

%Execution of verify statement, case property does not hold


	exec_state1.status = Running
	P(exec_state1.pstate_index, exec_state1.pstate_name) = verify(p, err)
	~[p](exec_state1)
	exec_state2.status = Reject(err)
   --------------------------  :: verif_fail
	P ; exec_state1 -> exec_state2


%Regular execution of extract statement
	exec_state1.status = Running
	P(exec_state1.pstate_index, exec_state1.c) = extract(f1)
	[f1](exec_state1) = (i', o')
	exec_state2.(i, o) = (i', o')
	exec_state2.n = exec_state1.n + 1
   --------------------------  :: extract_ok
	P ; exec_state1 -> exec_state2


%TypeError caused by extract statement
	exec_state1.status = Running
	P(exec_state1.pstate_index, exec_state1.pstate_name) = extract(f1)
	[f1](exec_state1) = TypeError
	exec_state2.status = TypeError
   --------------------------  :: extract_type_error
	P ; exec_state1 -> exec_state2


%Regular transition
	exec_state1.status = Running
	P(exec_state1.pstate_index, exec_state1.pstate_name) = transition c
	exec_state2.pstate_name = c
	exec_state2.pstate_index = 0
   --------------------------  :: trans_ok
	P ; exec_state1 -> exec_state2

%Transition outside program
	exec_state1.status = Running
	size(P(exec_state1.pstate_name)) <= exec_state1.pstate_index
	exec_state2.status = JumpOutside
   --------------------------  :: trans_outside
	P ; exec_state1 -> exec_state2






%%TODO: Terminals?




%%TODO: Formula?
metavar f ::=
 {{ lex alphanum }}
 {{ hol string }}
 {{ com field }}
%TODO Type "m" might need some oversight. errors are a built-in P4 type for holding errors. See 7.1.2 and appendix D.
metavar m ::=
 {{ lex alphanum }}
 {{ hol string }}
 {{ com message }}
metavar name ::=
 {{ lex alphanum }}
 {{ hol string }}
 {{ com parser state name }}
metavar out ::=
 {{ lex alphanum }}
 {{ hol string |-> bool list }}
 {{ com output }}
metavar nstep ::=
 {{ lex numeral }}
 {{ hol num }}
 {{ com number of steps }}
indexvar k, n ::=
 {{ lex numeral }}
 {{ hol num }}
 {{ com index variable }}
grammar
%TODO: Merge bv, b, exp?

bv, inp :: bv_ ::=
 {{ hol bool list }}
 {{ com bitstring }}
| [ b1 , .. , bn ] :: M :: enum
  {{ hol [[b1 .. bn]] }}

b :: b_ ::=
{{ com boolean }}
{{ hol bool }}
| bv = bv' :: M :: bv_eq
  {{ hol ([[bv]] = [[bv']]) }}
| b1 = b2 :: M :: b_eq
  {{ hol ([[b1]] = [[b2]]) }}
| true :: M :: true
  {{ hol T }}
| false :: M :: false
  {{ hol F }}

exp :: exp_ ::=
 {{ com expression }}
| In :: :: input
| Out . f :: :: output
| exp == exp' :: :: eq
| bv :: :: bv_const

%TODO "Start" should also map to some (bstmt, estmt)... Now only names (strings) can.
pst_id :: pst_id_ ::=
 {{ com parser state id }}
| Conc name :: :: conc
| start :: :: start
| accept :: :: accept
| reject m :: :: reject

bstmt :: bstmt_ ::=
 {{ com basic statement }}
| bstmt1 ; bstmt2 :: :: comp
| extract f :: :: extract
| verify b m :: :: verify

estmt :: estmt_ ::=
 {{ com ending statement }}
| transition pst_id :: :: transition

parser :: parser_ ::=
 {{ com parser }}
 {{ hol name |-> (bstmt # estmt) }}
| ( name , bstmt , estmt ) :: :: parser
  {{ tex name \rightarrow (bstmt, estmt) }}

status :: status_ ::=
 {{ com execution status }}
| Running :: :: running
| Accept ::  :: accept
| Reject m :: :: reject
| TypeError :: :: type_error
| JumpOutside :: :: jump_outside

state :: state_ ::=
 {{ com execution state }}
| ( pst_id , inp , out , status ) :: :: ct

%%%%%%%%%%%%%%%%%%%%%%%
% STATEMENT SEMANTICS %
%%%%%%%%%%%%%%%%%%%%%%%

terminals :: terminals_ ::=
| -> :: :: rightarrow {{ tex \rightarrow }}

formula :: formula_ ::=
{{ com formulas }}
| judgement :: :: judgement
  {{ com judgement }}
| out . f = bv :: M :: out_f_eq_bv
  {{ hol (FLOOKUP [[out]] [[f]] = SOME [[bv]]) }}
| k < n :: M :: lt
  {{ hol ([[k]] < [[n]]) }}
| bv = bv' :: M :: bv_eq
  {{ hol ([[bv]] = [[bv']]) }}
| b = b' :: M :: b_eq
  {{ hol ([[b]] = [[b']]) }}
| nstep = 1 :: M :: num_eq
  {{ hol ([[nstep]] = 1) }}
| pst_id = pst_id' :: M :: pst_id_eq
  {{ hol ([[pst_id]] = [[pst_id']]) }}
%TODO: Well-advised to have fields with initialisation flag and sizes
| size ( out , f ) = n :: M :: size_f
  {{ hol (LENGTH (THE (FLOOKUP [[out]] [[f]])) = [[n]]) }}
| parser name = (bstmt, estmt) :: M :: parser_lookup
  {{ hol (FLOOKUP [[parser]] [[name]] = SOME (bstmt, estmt)) }}
| nstep' = nstep - 1 :: M :: num_minus
  {{ hol (nstep' = nstep - 1) }}

defns
  p4_parser_exp_red :: '' ::=
defn
  [ exp ] state -> b :: :: exp_red :: exp_red_
  {{ com expression semantics }}
by

  out.f = bv  
  ----------------------------------- :: eq
  [In == Out.f](pst_id,inp,out,status) -> inp = bv

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% BASIC STATEMENT EXECUTION %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
  p4_parser_bstmt_red :: '' ::=
defn
  [ bstmt ] state -> state' :: :: bstmt_red :: bstmt_red_
  {{ com basic statement semantics }}
by

%%%%%%%%%%%
% EXTRACT %

%Extract is here referred to as a statement, even though it is in fact a method of the input packet (of type packet_in).
%TODO: This solution only treats fixed-size headers.

%Extract statement, regular case
  size(out,f) = k
  inp = [b1,..,bk,b'1,..,b'n]
  inp' = [b'1,..,b'n]
  out'.f = [b1,..,bk]
  ------------------------------------------------- :: extract_1
  [extract f](pst_id,inp,out,Running) -> (pst_id,inp',out',Running)

%Extract statement, case trying to extract too large header
  size(out,f) = k
  inp = [b1,..,bn]
  n < k
  -------------------------------------------------- :: extract_2
  [extract f](pst_id,inp,out,Running) -> (pst_id,inp,out,TypeError)

%%%%%%%%%%
% VERIFY %

%TODO: Additional case: "b has type error"? How should this be treated?

%Verify, case property b holds
  b = true
  -------------------------------------------------- :: verify_1
  [verify b m](pst_id,inp,out,Running) -> (pst_id,inp,out,Running)

%Verify, case property b does not hold
  b = false
  -------------------------------------------------- :: verify_2
  [verify b m](pst_id,inp,out,Running) -> (pst_id,inp,out,Reject m)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% STRUCTURAL STATEMENT EXECUTION %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
  p4_parser_str_stmt_red :: '' ::=
defn
  [ bstmt ] state -> [ bstmt' ] state' :: :: str_stmt_red :: str_stmt_red_
  {{ com structural statement semantics }}
by

%%%%%%%%%%%%
% SEQUENCE %


%Sequential composition of bstmts, recursive case
  [bstmt1] state -> [bstmt3] state'
  -------------------------------------------------- :: seq_1
  [bstmt1 ; bstmt2]state -> [bstmt3 ; bstmt2]state'

%Sequential composition of bstmts, base case
  [bstmt1] state -> state'
  -------------------------------------------------- :: seq_2
  [bstmt1 ; bstmt2]state -> [bstmt2]state'

%%%%%%%%%%%%%%%%%%%
% BLOCK EXECUTION %
%%%%%%%%%%%%%%%%%%%

defns
  p4_parser_block_red :: '' ::=
defn
  [ ( bstmt , estmt ) ] state -> state' :: :: block_red :: block_red_
  {{ com block transition semantics }}
by

%%%%%%%%%%%%%%
% TRANSITION %

%TODO: Check so that parser state transitions do not jump outside the parser

%Transition, regular case
  pst_id' = Conc name
  [bstmt] (pst_id,inp,out,Running) -> (pst_id,inp',out',Running)
  -------------------------------------------------- :: transition_1
  [(bstmt, transition pst_id')](pst_id,inp,out,Running) -> (pst_id',inp',out',Running)

%Transition, case accept
  pst_id' = accept
  [bstmt] (pst_id,inp,out,Running) -> (pst_id,inp',out',Running)
  -------------------------------------------------- :: transition_2
  [(bstmt, transition pst_id')](pst_id,inp,out,Running) -> (pst_id',inp,out,Accept)

%Transition, case reject
  pst_id' = reject m
  [bstmt] (pst_id,inp,out,Running) -> (pst_id,inp',out',Running)
  -------------------------------------------------- :: transition_3
  [(bstmt, transition pst_id')](pst_id,inp,out,Running) -> (pst_id',inp,out,Reject m)

%%%%%%%%%%%%%%%%%%%%%
% N-BLOCK EXECUTION %
%%%%%%%%%%%%%%%%%%%%%

defns
  p4_parser_nblock_red :: '' ::=
defn
  [ ( parser , nstep ) ] state -> state' :: :: nblock_red :: nblock_red_
  {{ com n-block transition semantics }}
by

%%%%%%%%%%%%%%
% N-BLOCK TRANSITION %

%Transition, base case
%Note that we only define this for status Running, for now...
  -------------------------------------------------- :: n_transition_1
  [(parser, 0)](pst_id,inp,out,Running) -> (pst_id,inp,out,Running)

%Transition, one step
%Note that we only define this for status Running, for now...
  nstep = 1
  pst_id = Conc name
  parser name = (bstmt, estmt)
  [(bstmt, estmt)](pst_id,inp,out,Running) -> (pst_id',inp',out',Running)
  -------------------------------------------------- :: n_transition_2
  [(parser, nstep)](pst_id,inp,out,Running) -> (pst_id',inp',out',Running)

%Transition, inductive case
%Note that we only define this for status Running, for now...
  nstep' = nstep - 1
  [(parser , nstep')] (start,inp,out,Running) -> (pst_id,inp',out',Running)
  pst_id = Conc name
  parser name = (bstmt, estmt)
  [(bstmt, estmt)] (pst_id,inp',out',Running) -> (pst_id',inp'',out'',Running)
  -------------------------------------------------- :: n_transition_3
  [(parser , nstep)](pst_id,inp',out',Running) -> (pst_id',inp'',out'',Running)
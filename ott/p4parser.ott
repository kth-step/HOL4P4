metavar f ::=
 {{ lex alphanum }}
 {{ hol string }}
 {{ com field }}
%TODO Type "m" might need some oversight. errors are a built-in P4 type for holding errors. See 7.1.2 and appendix D.
metavar m ::=
 {{ lex alphanum }}
 {{ hol string }}
 {{ com message }}
metavar name ::=
 {{ lex alphanum }}
 {{ hol string }}
 {{ com parser state name }}
metavar out ::=
 {{ lex alphanum }}
 {{ hol string |-> bool list }}
 {{ com output }}
metavar nstep ::=
 {{ lex numeral }}
 {{ hol num }}
 {{ com number of steps }}
indexvar k, n ::=
 {{ lex numeral }}
 {{ hol num }}
 {{ com index variable }}
grammar
%TODO: Merge bv, b, exp?

bv, inp :: bv_ ::=
 {{ hol bool list }}
 {{ com bit vector }}
| [ b1 , .. , bn ] :: M :: enum
  {{ hol [[b1 .. bn]] }}

b :: b_ ::=
{{ com boolean }}
{{ hol bool }}
| bv = bv' :: M :: bv_eq
  {{ hol ([[bv]] = [[bv']]) }}
| b1 = b2 :: M :: b_eq
  {{ hol ([[b1]] = [[b2]]) }}
| true :: M :: true
  {{ hol T }}
| false :: M :: false
  {{ hol F }}

exp :: exp_ ::=
 {{ com expression }}
| In :: :: input
| Out . f :: :: output
| exp == exp' :: :: eq
| bv :: :: bv_const

%TODO "Start" should also map to some (bstmt, estmt)... Now only names (strings) can.
pst_id :: pst_id_ ::=
 {{ com parser state id }}
| Conc name :: :: conc
| start :: :: start
| accept :: :: accept
| reject m :: :: reject

bstm :: bstm_ ::=
 {{ com basic statement }}
| :: :: empty
| bstm1 ; bstm2 :: :: comp
| extract f :: :: extract
| verify b m :: :: verify

estm :: estm_ ::=
 {{ com ending statement }}
| transition pst_id :: :: transition

prog :: prog_ ::=
 {{ com program }}
 {{ hol name |-> (bstm # estm) }}
| ( name , bstm , estm ) :: :: prog


status :: status_ ::=
 {{ com execution status }}
| Running :: :: running
| Accept ::  :: accept
| TypeError :: :: type_error
| Reject m :: :: reject
| JumpOutside :: :: jump_outside

idx :: '' ::=
    {{ hol num }}
    {{ com pc index }}
  | n :: I :: N 
      {{ hol [[n]] }}
  | idx1 + idx2 :: I :: add 
      {{ hol ([[idx1]] + [[idx2]]) }}

state :: state_ ::=
 {{ com execution state }}
| ( pst_id , inp , out , status ) :: :: ct

%%%%%%%%%%%%%%%%%%%%%%%
% STATEMENT SEMANTICS %
%%%%%%%%%%%%%%%%%%%%%%%

terminals :: terminals_ ::=
| -> :: :: rightarrow {{ tex \rightarrow }}

formula :: formula_ ::=
{{ com formulas }}
| judgement :: :: judgement
  {{ com judgement }}
| out . f = bv :: M :: out_f_eq_bv
  {{ hol (FLOOKUP [[out]] [[f]] = SOME [[bv]]) }}
| k < n :: M :: lt
  {{ hol ([[k]] < [[n]]) }}
| bv = bv' :: M :: bv_eq
  {{ hol ([[bv]] = [[bv']]) }}
| b = b' :: M :: b_eq
  {{ hol ([[b]] = [[b']]) }}
| nstep = 1 :: M :: num_eq
  {{ hol ([[nstep]] = 1) }}
| pst_id = pst_id' :: M :: pst_id_eq
  {{ hol ([[pst_id]] = [[pst_id']]) }}
%TODO: Well-advised to have fields with initialisation flag and sizes
| size ( out , f ) = n :: M :: size_f
  {{ hol (LENGTH (THE (FLOOKUP [[out]] [[f]])) = [[n]]) }}
| prog name = (bstm, estm) :: M :: prog_lookup
  {{ hol (FLOOKUP [[prog]] [[name]] = SOME (bstm, estm)) }}
| nstep' = nstep - 1 :: M :: num_minus
  {{ hol (nstep' = nstep - 1) }}

defns
  p4_parser_exp_red :: '' ::=
defn
  [ exp ] state -> b :: :: exp_red :: exp_red_
  {{ com expression semantics }}
by

  out.f = bv  
  ----------------------------------- :: eq
  [In == Out.f](pst_id,inp,out,status) -> inp = bv

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% BASIC STATEMENT EXECUTION %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
  p4_parser_bstm_red :: '' ::=
defn
  [ bstm ] state -> [ bstm' ] state' :: :: bstm_red :: bstm_red_
  {{ com statement semantics }}
by

%%%%%%%%%%%
% EXTRACT %

%Extract is here referred to as a statement, even though it is in fact a method of the input packet (of type packet_in).
%TODO: This solution only treats fixed-size headers.

%Extract statement, regular case
  size(out,f) = k
  inp = [b1,..,bk,b'1,..,b'n]
  inp' = [b'1,..,b'n]
  out'.f = [b1,..,bk]
  ------------------------------------------------- :: extract_1
  [extract f](pst_id,inp,out,Running) -> [ ](pst_id,inp',out',Running)

%Extract statement, case trying to extract too large header
  size(out,f) = k
  inp = [b1,..,bn]
  n < k
  -------------------------------------------------- :: extract_2
  [extract f](pst_id,inp,out,Running) -> [ ](pst_id,inp,out,TypeError)

%%%%%%%%%%
% VERIFY %

%TODO: Additional case: "b has type error"? How should this be treated?

%Verify, case property b holds
  b = true
  -------------------------------------------------- :: verify_1
  [verify b m](pst_id,inp,out,Running) -> [ ](pst_id,inp,out,Running)

%Verify, case property b does not hold
  b = false
  -------------------------------------------------- :: verify_2
  [verify b m](pst_id,inp,out,Running) -> [ ](pst_id,inp,out,Reject m)

%%%%%%%%%%%%
% SEQUENCE %


%Sequential composition of bstmts, "big-step-in-small-step" style
  [bstm1] state -> [ ]state'
  [bstm2] state' -> [ ]state''
  -------------------------------------------------- :: seq_1
  [bstm1 ; bstm2]state -> [ ]state''

%Sequential composition of bstmts
  [bstm1] state -> [ ]state'
  -------------------------------------------------- :: seq_2
  [bstm1 ; bstm2]state -> [ bstm2 ]state'

%%%%%%%%%%%%%%%%%%%
% BLOCK EXECUTION %
%%%%%%%%%%%%%%%%%%%

defns
  p4_parser_block_red :: '' ::=
defn
  [ ( bstm , estm ) ] state -> state' :: :: block_red :: block_red_
  {{ com block transition semantics }}
by

%%%%%%%%%%%%%%
% TRANSITION %

%TODO: Check so that parser state transitions do not jump outside the parser

%Transition, regular case
  pst_id' = Conc name
  [bstm] (pst_id,inp,out,Running) -> [ ](pst_id,inp',out',Running)
  -------------------------------------------------- :: transition_1
  [(bstm, transition pst_id')](pst_id,inp,out,Running) -> (pst_id',inp',out',Running)

%Transition, case accept
  pst_id' = accept
  [bstm] (pst_id,inp,out,Running) -> [ ](pst_id,inp',out',Running)
  -------------------------------------------------- :: transition_2
  [(bstm, transition pst_id')](pst_id,inp,out,Running) -> (pst_id',inp,out,Accept)

%Transition, case reject
  pst_id' = reject m
  [bstm] (pst_id,inp,out,Running) -> [ ](pst_id,inp',out',Running)
  -------------------------------------------------- :: transition_3
  [(bstm, transition pst_id')](pst_id,inp,out,Running) -> (pst_id',inp,out,Reject m)

%%%%%%%%%%%%%%%%%%%%%
% N-BLOCK EXECUTION %
%%%%%%%%%%%%%%%%%%%%%

defns
  p4_parser_nblock_red :: '' ::=
defn
  [ ( prog , nstep ) ] state -> state' :: :: nblock_red :: nblock_red_
  {{ com n-block transition semantics }}
by

%%%%%%%%%%%%%%
% N-BLOCK TRANSITION %

%Transition, base case
%Note that we only define this for status Running, for now...
  -------------------------------------------------- :: n_transition_1
  [(prog, 0)](pst_id,inp,out,Running) -> (pst_id,inp,out,Running)

%Transition, one step
%Note that we only define this for status Running, for now...
  nstep = 1
  pst_id = Conc name
  prog name = (bstm, estm)
  [(bstm, estm)](pst_id,inp,out,Running) -> (pst_id',inp',out',Running)
  -------------------------------------------------- :: n_transition_2
  [(prog, nstep)](pst_id,inp,out,Running) -> (pst_id',inp',out',Running)

%Transition, inductive case
%Note that we only define this for status Running, for now...
  nstep' = nstep - 1
  [(prog , nstep')] (start,inp,out,Running) -> (pst_id,inp',out',Running)
  pst_id = Conc name
  prog name = (bstm, estm)
  [(bstm, estm)] (pst_id,inp',out',Running) -> (pst_id',inp'',out'',Running)
  -------------------------------------------------- :: n_transition_3
  [(prog , nstep)](pst_id,inp',out',Running) -> (pst_id',inp'',out'',Running)
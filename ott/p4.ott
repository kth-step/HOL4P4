embed
{{ hol
open bitstringTheory;
open wordsTheory;
}}

%%%%%%%%%%%%%%%%%
% P4 base types %
%%%%%%%%%%%%%%%%%

%x denotes variable name, f denotes field name or function name
metavar x, f, a, tbl ::=
      {{ lex alphanum }}
      {{ hol string }}
      {{ tex [[x]] }}
      {{ com string }}

%TODO Numeral or alphanum?
metavar b ::=
      {{ lex numeral }}
      {{ hol bool }}
      {{ tex [[b]] }}
      {{ com boolean }}
metavar bl ::=
      {{ lex numeral }}
      {{ hol bool list }}
      {{ tex [[bl]] }}
      {{ com bit-string }}
    

%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Auxiliary metavariables %
%%%%%%%%%%%%%%%%%%%%%%%%%%%

metavar i ::=
      {{ lex numeral }}
      {{ hol num }}
      {{ tex [[i]] }}
      {{ com natural number }}
indexvar m, n, o ::=
  {{ lex numeral }}
  {{ coq nat }}
  {{ hol num }}
  {{ com indices }}


grammar

num_exp :: num_exp ::=
{{ hol num }}
{{ com expressions with numeric literals }}
| i :: M :: lit
  {{ hol [[i]] }}
| num_exp + 1 :: M :: add1
  {{ hol ([[num_exp]] + 1) }}

%%%%%%%%%%%%%%%%
% Value syntax %
%%%%%%%%%%%%%%%%

boolv :: boolv_ ::=
{{ hol bool }}
{{ com boolean }}
| true :: M :: true
  {{ hol T }}
  {{ tex { \top } }}
| false :: M :: false
  {{ hol F }}
  {{ tex { \bot } }}
| b :: M :: free
  {{ hol [[b]] }}

bitv :: bitv_ ::=
{{ hol (bl # num) }}
{{ com bit-string }}
| bl n :: M :: bl
  {{ hol ([[bl]], [[n]]) }}

%Fence so that ott does not put packet_in before boolv
embed
{{ hol

}}
grammar

packet_in :: packet_in_ ::=
{{ hol (boolv list) }}
{{ com input packet }}
| [ boolv1 , .. , boolvn ] :: M :: list
  {{ hol ([[boolv1 .. boolvn]]) }}

packet_out :: packet_out_ ::=
{{ hol (boolv list) }}
{{ com output packet }}
| [ boolv1 , .. , boolvn ] :: M :: list
  {{ hol ([[boolv1 .. boolvn]]) }}

ipv4_checksum :: ipv4_checksum_ ::= {{ hol (word16) }}
{{ com ipv4 header checksum }}

%TODO: This should be expanded to cover data of all extern objects
%TODO: Only stuff in core.p4, for now... Should this be polymorphic when done for multiple platforms?
ext_obj :: ext_obj_ ::=
{{ com extern object }}
| packet_in :: :: in
  {{ com input packet }}
| packet_out :: :: out
  {{ com input packet }}
| ipv4_checksum :: :: ck
  {{ com ipv4 header checksum }}


%TODO: Add identifiers
%TODO: Add enums
v :: v_ ::=
{{ com constant }}
| boolv :: :: bool
  {{ com boolean value }}
%bitv currently represents both signed and unsigned bit-strings
| bitv :: :: bit
  {{ com bit-string }}
| x :: :: str
  {{ com string literal }} 
| struct { x1 = v1 ; ... ; xn = vn } :: :: struct
  {{ com struct }} %TODO: Ott User Guide 12.2  List comprehension forms
| header boolv { x1 = v1 ; ... ; xn = vn } :: :: header
% A header is like a struct, but with a validity bit.
% Headers also have different well-formedness conditions (for example, headers cannot be nested).
%TODO: We must have the following header methods:
%      isValid()
%      setValid()
%      setInvalid()
%      Should these be modeled as statements, or should they
%      be pre-set in the function map?
  {{ com header }}
| ext_obj :: :: ext
  {{ com extern object }}
| errmsg x :: :: err
  {{ com error message }}
%TODO: Represent uninitialised variables? Default values?
%See https://p4lang.github.io/p4-spec/docs/P4-16-v1.2.2.html#sec-uninitialized-values-and-writing-invalid-headers
| bot :: :: bot
  {{ com no value }}


v_list :: v_list_ ::=
{{ com list of values }}
{{ hol (v list) }}
| empty_vl :: M :: empty
  {{ com empty expression list }}
  {{ hol ([]:v list) }}
| v1 , .. , vn :: M :: vl
  {{ hol ([[v1 .. vn]]) }}


%An abstract function or extern method/function name
funn :: funn_ ::=
| f :: :: name
  {{ com function name }}
| inst f :: :: inst
  {{ com extern object instantiation }}
| f f' :: :: ext
  {{ com extern method call }}
  

varn :: varn_ ::=
| x :: :: name
  {{ com variable name }}
| ( star , funn ) :: :: star 
  {{ com function return placeholder }}
| ext_ret :: :: ext_ret
  {{ com extern return variable }}

%TODO: Add array element
%TODO: Add bitslice
lval :: lval_ ::=
| varn :: :: varname
  {{ com variable name }}
| null :: :: null
  {{ com null variable }} 
| lval . f :: :: field
  {{ com field access }}
| ( lval ) :: X :: paren
  {{ hol ([[lval]]) }}


%%%%%%%%%%%%%%%%%%%
% Execution state %
%%%%%%%%%%%%%%%%%%%
%Note that this is not part of the P4 specification, but made up for verification purposes.

pars_fin {{ tex p_{ \mathrm{fin} } }} :: pars_fin ::=
{{ com final parser states }}
| Accept :: :: accept
  {{ com accepted state }}
  {{ tex { \mathbf{acc} } }}
| Reject :: :: reject
  {{ com rejected state }}
  {{ tex { \mathbf{rej} } }}

status {{ tex t }}:: status_ ::=
{{ com execution status }}
| Running :: I :: running
  {{ tex { \mathbf{run} } }}
| Ret v :: I :: returnv
  {{ tex { \mathbf{ret} \; [[v]] } }}  
| Trans x :: I :: trans
  {{ com transition to parser state }}
  {{ tex { \mathbf{tra} \; [[x]] } }}

scope {{ tex \gamma }} :: scope_ ::=
{{ hol (varn |-> (v # lval option)) }}
{{ com frame/variable environment of current scope }}
| emptyscope :: M :: empty
  {{ com empty stack frame }}
  {{ hol FEMPTY }}
  {{ tex {\gamma}_{ \emptyset } }}
%TODO: This should keep output parameter instead of requiring NONE
| scope + [ varn |-> ( v , NONE ) ] :: M :: update
  {{ com update variable mapping }}
  {{ hol (FUPDATE [[scope]] ([[varn]], ( [[v]] , NONE ))) }}
  {{ tex ([[varn]] \mapsto  [[v]]) [[scope]] }}
%TODO: Update or remove this production
| scope ++ [ varn1 |-> v1 , .. , varnn |-> vn ] :: M :: update_list
  {{ com update variable mapping }}
  {{ hol (FUPDATE_LIST [[scope]] [[varn1 v1 .. varnn vn]]) }}
  %TODO: The below is a hack since LaTeX cannot interpret dot form...
  {{ tex \forall i \leq n. \,\, (x_i \mapsto  \mathit{v}_i) \,\, [[scope]] }}
| ( scope ) :: S :: paren
  {{ hol ([[scope]]) }}
  {{ tex  [[scope]] }}

g_scope {{ tex \gamma_G }} :: g_scope_ ::=
{{ com global scope}}
{{ hol scope}}
| scope :: M :: global
  {{ hol ([[scope]]) }}

mk {{ tex \mathit{mk} }} :: mk_ ::=
{{ com matching kinds }}
| exact :: :: exact
  {{ tex exact }}
| ternary :: :: ternary
  {{ tex ternary }}
| lpm :: :: lpm
  {{ tex lpm }}

embed
{{ hol

}}
grammar

mkl {{ tex \mathit{mkl} }} :: mkl_ ::=
{{ com matching kinds list }}
{{ hol (mk list) }}
| empty :: :: empty
  {{ com empty match kind list }}
  {{ hol ([]:mk list) }}
| [ mk1 , .. , mkn ] :: M :: mks
  {{ com list of match kinds }}
  {{ hol ([[mk1 .. mkn]]) }}
| ( mkl ) :: S :: paren
  {{ hol ([[mkl]]) }}


%Fence so that ott does not re-order expression syntax with state syntax
embed
{{ hol

}}
grammar

%%%%%%%%%%%%%%%%%%%%%
% Expression syntax %
%%%%%%%%%%%%%%%%%%%%%

unop {{ tex \ominus }}:: unop_ ::=
| ! :: :: neg
  {{ com negation }}
  {{ tex ! }}
| ~ :: :: compl
  {{ com bitwise complement }}
  {{ tex \neg }}
| - :: :: neg_signed
  {{ com signed negation }}
| + :: :: un_plus
  %Defined as no-op for all values in P4 spec
  {{ com unary plus }}

%Binary operations
%TODO: Split these up into operations (bv # bv -> bv) and predicates (bv # bv -> bool)?
%TODO: Add saturating addition
%TODO: Add saturating subtraction
binop {{ tex \oplus }} :: binop_ ::=
| * :: :: mul
  {{ com multiplication }}
  {{ tex \times }}
| / :: :: div
  {{ com division }}
| mod :: :: mod
  %Denoted by % in P4 spec
  {{ com modulo }}
  {{ tex \bmod }}
| + :: :: add
  {{ com addition }}
| - :: :: sub
  {{ com subtraction }}
| SHL :: :: shl
  {{ com logical left-shift }}
  {{ tex \ll }}
| SHR :: :: shr
  {{ com logical right-shift }}
  {{ tex \gg }}
| LE :: :: le
  {{ com less or equal }}
  {{ tex \leq }}
| GE :: :: ge
  {{ com greater or equal }}
  {{ tex \geq }}
| < :: :: lt
  {{ com less }}
  {{ tex < }}
| > :: :: gt
  {{ com greater }}
  {{ tex > }}
| NE :: :: neq
  {{ com not equal }}
  {{ tex \neq }}
| EQ :: :: eq
  {{ com equal }}
  {{ tex = }}
| & :: :: and
  {{ com bitwise and }}
| ^ :: :: xor
  {{ com bitwise xor }}
  {{ tex \underline{\vee} }}
| '|' :: :: or
  {{ com bitwise or }}
  {{ tex \mid }}
| AND :: :: bin_and
  {{ com binary and }}
  {{ tex \land }}
| OR :: :: bin_or
  {{ com binary or }}
  {{ tex \lor }}


%TODO: Add casts
%TODO: Add tuples
%TODO: Add conditional operator
e :: e_ ::=
{{ com expression }}
| v :: :: v
  {{ com constant value }}
| var varn :: :: var
  {{ com variable }}
| { e1 , .. , en } :: :: list
  {{ com expression list }}
| e . x :: :: acc
  {{ com field access }}
| unop e :: :: unop
  {{ com unary operation }}
  {{ tex [[unop]] [[e]] }}
| e1 binop e2 :: :: binop
  {{ com binary operation }}
  {{ tex [[e1]] [[binop]] [[e2]] }}
| concat e1 e2 :: :: concat
  {{ com concatenation of bit-strings }}
| e1 [ e2 : e3 ] :: :: slice
  {{ com bit-slice }}
| call funn ( e1 , .. , en ) :: :: call
  {{ com function or extern call }}
| select e { v1 : x1 ; ... ; vn : xn } x :: :: select
  %TODO: x is the default value of select expression, which should be optional
  {{ com select }}
| eStruct { x1 = e1 ; ... ; xn = en } :: :: struct
    {{ com struct expression }}
| eHeader boolv { x1 = e1 ; ... ; xn = en } :: :: header
    {{ com header expression }}  
| ( e ) :: S :: paren
  {{ hol ([[e]]) }}


embed
{{ hol

}}
grammar


%TODO: Trying to make a new definition for expression lists (mainly for function
%      arguments) proved problematic.
%      If all e_list productions are meta, then you get e_list as a type abbreviation of "e list",
%      which is either undefined at the point where the abbreviation is made, or
%      e_list is unknown when defining e (and specifically function call, which would use e_list).
%      In both situations, mutually recursive definitions are not possible.
%
%      If nothing is meta and e_list is not exported to a type abbreviation, you risk the function call semantics not understanding the "e_list" and "e list" correspondence. However, this seems to work currently.
e_list :: e_list_ ::=
{{ com list of expressions }}
{{ hol (e list) }}
| empty_el :: M :: empty
  {{ com empty expression list }}
  {{ hol ([]:e list) }}
| e1 , .. , en :: M :: exps
  {{ com list of expressions }}
  {{ hol ([[e1 .. en]]) }}
| e '::' e_list :: M :: cons
  {{ com cons }}
  {{ hol ([[e]]::[[e_list]]) }}
| tl e_list :: M :: tail
  {{ com tail }}
  {{ hol (TL [[e_list]]) }}
| [ e1 , .. , en ] :: M :: exps2
  {{ com bracketed list of expressions }}
  {{ hol ([[e1 .. en]]) }}
| e_list ++ e_list' :: M :: append
  {{ com append two expression lists }}
  {{ hol ([[e_list]] ++ [[e_list']]) }}
| update ( e , i , e_list ) :: M :: update
  {{ com update entry of expression list }}
  {{ hol (LUPDATE [[e]] [[i]] [[e_list]]) }}
  {{ tex ([[i]] \mapsto  [[e]]) [[e_list]] }}
| ( e_list ) :: S :: paren
  {{ hol ([[e_list]]) }}

init_opt :: init_opt_ ::=
{{ com optional initializer }}
{{ hol (e option) }}
| e :: M :: some
  {{ com initializer }}
  {{ hol (SOME [[e]]) }}
%TODO: Choose notation
| - :: M :: none
  {{ com no initializer }}
  {{ hol (NONE:e option) }}

%%%%%%%%%%%%%%
% Statements %
%%%%%%%%%%%%%%

bt {{ tex \mathit{bt} }} :: bt_ ::=
{{ com base types }}
| bool_t :: :: bool
  {{ tex { \mathrm{bool}_{ \mathrm{t} } } }}
| bit_t :: :: bit
  {{ tex { \mathrm{bit}_{ \mathrm{t} } } }}

t {{ tex t }} :: t_ ::=
{{ com types }}
| bt :: :: base
| struct_t t1 , ... , tn :: :: struct
  {{ tex { \mathrm{struct}_{ \mathrm{t} }\,\, t_1 , \ldots , t_n } }}
| header_t t1 , ... , tn :: :: header
  {{ tex { \mathrm{header}_{ \mathrm{t} }\,\, t_1 , \ldots , t_n } }}
%TODO: are all extern objects that are declared done so using constructors?
| extt :: :: ext
  {{ tex \mathrm{ext} }}

%Fence between ctrl and e_list
embed
{{ hol

}}
grammar

ctrl {{ tex { C } }} :: ctrl_ ::=
{{ com control plane }}
{{ hol ((string # e_list # mkl) -> (string # e_list) option) }}

g_scope_list {{ tex \overrightarrow{\gamma_G} }} :: g_scope_list_ ::=
{{ hol (scope list) }}
{{ com list of the global scope and the block-global scope }}
| [ g_scope ]' :: M :: one
  {{ com only global scope }}
  {{ hol ([ [[g_scope]] ]) }}
  {{ tex [ [[g_scope]] ] }}
| [ g_scope ; g_scope' ] :: M :: two
  {{ com global scope and block-global scope }}
  {{ hol ([ [[g_scope]] ; [[g_scope']] ]) }}
  {{ tex [ [[g_scope]], [[g_scope']] ] }}
| take 1 g_scope_list :: M :: take
  {{ com take first element }}
  {{ hol (TAKE 1 [[g_scope_list]]) }}
  {{ tex \mathrm{take}(1,[[g_scope_list]]) }}

%Fence between ctrl and state
embed
{{ hol

}}
grammar

scopes_stack {{ tex \overrightarrow{\gamma} }} :: scopes_stack_ ::=
{{ hol (scope list) }}
{{ com stack of block scopes }}
| emptyss :: M :: empty
  {{ hol ([]:scope list) }}
  {{ tex {[\;]} }}
| [ scope1 , .. , scopen ] :: M :: list
  {{ hol ([[scope1 .. scopen]]) }}
| tl scopes_stack :: M :: tl
  {{ hol (TL [[scopes_stack]]) }}
  {{ tex \mathrm{tl} [[scopes_stack]] }}
| g_scope '::' scopes_stack' :: M :: cons
  {{ hol ([[g_scope]] :: [[scopes_stack']]) }}
  {{ tex [[g_scope]] :: [[scopes_stack']] }}
| scopes_stack ++ scopes_stack' :: M :: append
  {{ hol ([[scopes_stack]] ++ [[scopes_stack']]) }}
  {{ tex [[scopes_stack]] \mathrel{\mathop+}+ [[scopes_stack']] }}
| rev scopes_stack :: M :: rev
  {{ hol (REVERSE [[scopes_stack]]) }}
  {{ tex \mathrm{rev} ([[scopes_stack]]) }}
| update ( scope , i , scopes_stack ) :: M :: update_scope
  {{ com update a scope in the stack frame }}
  {{ hol ( LUPDATE [[scope]] [[i]] [[scopes_stack]] ) }}
  {{ tex ([[i]] \mapsto [[scope]]) [[scopes_stack]] }}
%TODO: Hack to make you able to concatenate g_scope_lists and scope_stacks
| g_scope_list :: M :: g_scope_list
  {{ com g_scope_list }}
  {{ hol ( [[g_scope_list]] ) }}
  {{ tex [[g_scope_list]] }}
| ( scopes_stack ) :: S :: paren
  {{ hol ([[scopes_stack]]) }}

%ext updates the scope stack, global scope list and ctrl directly.
%Note that at the time this happens, a new frame has already been declared for ext. 
ext_fun {{ tex { \mathit{ext\_fun} } }} :: ext_fun_ ::=
{{ hol ((g_scope_list # scopes_stack # ctrl) -> ((g_scope_list # scopes_stack # ctrl) option)) }}

decl_list {{ tex { \overrightarrow{decl} } }} :: decl_list_ ::=
{{ hol ((varn # t) list) }}
{{ com list of abstract variable name and type tuples to represent declarations }}
| empty :: M :: empty
  {{ com empty list of declarations }}
  {{ hol ([]:(varn # t) list) }}
  {{ tex [ \, ] }}

%Fence between ext and ext_map
embed
{{ hol

}}
grammar

%TODO: Add switch statement
stmt :: stmt_ ::=
{{ com statement }}
| empty_stmt :: :: empty
  {{ com empty statement }}
  {{ tex \emptyset_{ \mathrm{stmt} } }}
| assign lval e :: :: ass
  {{ com assignment }}
  {{ tex [[lval]] \mathrel{\mathop:}= [[e]] }}
| if e then stmt1 else stmt2 :: :: cond
  {{ com conditional }}
| begin decl_list stmt end :: :: block
  {{ com block }}
  {{ tex \{ [[decl_list]] \, [[stmt]] \} }}
| return e :: :: ret
  {{ com return }}
| stmt1 ; stmt2 :: :: seq
  {{ com sequence }}
| verify e e' :: :: verify
  %e is the predicate, e' is the error message
  {{ com verify }}
| transition e :: :: trans
  {{ com transition }}
  {{ tex \mathbf{transition}\, [[e]] }}
| apply tbl ( e1 , .. , en ) :: :: app
  {{ com apply }}
 % {{ tex \mathbf{apply} \, [[tbl]] \, [[e_list]] }}
| ext :: :: ext
  {{ com extern function }}
  {{ tex \blacksquare  }}

ascope {{ tex { {\gamma}_\mathit{A} } }}, ascope_ty :: ascope_ ::=
{{ com architectural scope }}
{{ hol ('a) }}

d {{ tex d }} :: d_ ::=
{{ com parameter direction }}
| 'in :: :: in
  {{ tex \downarrow }}
| out :: :: out
  {{ tex \uparrow }}
| inout :: :: inout
  {{ tex \updownarrow }}
| none :: :: none
  {{ tex \circ }}

%The "fixed function" of a fixed-function block
ff {{ tex { \mathit{ff} } }} :: ff_ ::=
{{ hol (ascope_ty -> ascope_ty option) }}

%Fence between d and d_list
embed
{{ hol

}}
grammar

d_list :: d_list_ ::=
{{ com list of directions }}
{{ hol (d list) }}
| empty_el :: M :: empty
  {{ com empty direction list }}
  {{ hol ([]:d list) }}
| [ d1 , .. , dn ] :: M :: ds
  {{ com list of directions }}
  {{ hol ([[d1 .. dn]]) }}
| ( d_list ) :: S :: paren
  {{ hol ([[d_list]]) }}
| d_list ++ d_list' :: M :: append
  {{ com append two e_lists }}
  {{ hol ([[d_list]] ++ [[d_list']]) }}

func_map {{ tex F_g }} :: func_map_ ::=
{{ com function map for global functions and actions }}
{{ hol (string |-> (stmt # (string # d) list)) }}

b_func_map {{ tex F_b }} :: b_func_map_ ::=
{{ com function map for block-local actions }}
{{ hol (string |-> (stmt # (string # d) list)) }}

%This maps extern function names of an individual object obj to their implementations
%Note the stmt in order to accommodate return by using return statements
ext_fun_map {{ tex X_{ \mathit{obj} } }} :: ext_fun_map_ ::=
{{ com extern function map }}
{{ hol (string |-> (stmt # (string # d) list # ext_fun)) }}

%Fence between ext_fun_map and ext_map
embed
{{ hol

}}
grammar

%This maps extern object names to tuples of optional constructors and the function map of the object in question
ext_map {{ tex X }} :: ext_map_ ::=
{{ com extern object map }}
{{ hol (string |-> (((stmt # (string # d) list # ext_fun) option) # ext_fun_map)) }}

tbl_map {{ tex { \mathit{Tb} } }} :: tbl_map_ ::=
{{ com table map  }}
{{ hol (string |-> (mk list)) }}

pars_map {{ tex P }} :: pars_map_ ::=
{{ com parser state map  }}
{{ hol (string |-> stmt) }}

in_out :: in_out_ ::=
{{ com input and output }}
{{ hol (bl # num) }}
| packet bl i :: M :: packet
  {{ hol ( [[bl]] , [[i]] ) }}

pbl_type :: pbl_type_ ::=
{{ com programmable block type }}
| parser :: :: parser
| control :: :: control

pblock {{ tex { \mathit{pblock} } }} :: pblock_ ::=
{{ com programmable block }}
| pbl_type ( ( x1 , d1 ) , .. , ( xn , dn ) ) b_func_map decl_list stmt pars_map tbl_map :: :: regular

ffblock {{ tex { \mathit{ffblock} } }} :: ffblock_ ::=
{{ com fixed-function block }}
| ff :: :: ff

%Fence so that ott does not re-order ffblock
embed
{{ hol

}}
grammar

arch_block :: arch_block_ ::=
{{ com architectural block }}
| inp :: :: inp
| pbl x ( e1 , .. , en ) :: :: pbl
| ffbl x :: :: ffbl
| out :: :: out

% TODO: Could be just a type abbreviation?
pblock_list {{ tex \overline{pb} }} :: pblock_list_ ::=
{{ com list of programmable blocks }}
{{ hol (pblock list) }}

pblock_map {{ tex B_p }} :: pblock_map_ ::=
{{ com programmable block map }}
{{ hol (string |-> pblock) }}

ffblock_map {{ tex B_{ \mathit{ff} } }} :: ffblock_map_ ::=
{{ com fixed-function block map }}
{{ hol (string |-> ffblock) }}

% TODO: Could be just a type abbreviation?
in_out_list {{ tex \overline{io} }} :: in_out_list_ ::=
{{ com list of input and output }}
{{ hol (in_out list) }}

%Fence between in_out_list and input_f
embed
{{ hol

}}
grammar

ab_list {{ tex \overline{ab} }} :: ab_list_ ::=
{{ com list of architectural blocks }}
{{ hol (arch_block list) }}

%TODO: Unify input_f and output_f?
input_f {{ tex { \mathit{in}_A } }} :: input_f_ ::=
{{ com input function }}
{{ hol ((in_out_list # ascope_ty) -> (in_out_list # ascope_ty) option) }}

output_f {{ tex { \mathit{out}_A } }} :: output_f_ ::=
{{ com output function }}
{{ hol ((in_out_list # ascope_ty) -> (in_out_list # ascope_ty) option) }}

copyin_pbl {{ tex { \mathit{in}_p } }} :: copyin_pbl_ ::=
{{ com copy-in to programmable blocks function }}
{{ hol ((x list # d list # e list # ascope_ty # pbl_type) -> scope option) }}

copyout_pbl {{ tex { \mathit{out}_p } }} :: copyout_pbl_ ::=
{{ com copy-out from programmable blocks function }}
{{ hol ((g_scope list # ascope_ty # d list # x list # pbl_type # status) -> ascope_ty option) }}

%Fence between ab_list and actx
embed
{{ hol

}}
grammar

actx {{ tex { \mathit{ctx}_A } }} :: actx_ ::=
{{ com architectural context }}
{{ hol (ab_list # pblock_map # ffblock_map # input_f # output_f # copyin_pbl # copyout_pbl # ext_map # func_map) }}
| ( ab_list , pblock_map , ffblock_map , input_f , output_f , copyin_pbl , copyout_pbl , ext_map , func_map ) :: M :: tup
  {{ com tuple }}
  {{ hol ([[ab_list]], [[pblock_map]], [[ffblock_map]], [[input_f]], [[output_f]], [[copyin_pbl]], [[copyout_pbl]], [[ext_map]], [[func_map]]) }}

ctx {{ tex \mathit{ctx} }} :: ctx_ ::=
{{ com context }}
{{ hol (ext_map # func_map # b_func_map # pars_map # tbl_map) }}
| ( ext_map , func_map , b_func_map , pars_map , tbl_map ) :: M :: tup
  {{ com tuple }}
  {{ hol ([[ext_map]], [[func_map]], [[b_func_map]] , [[pars_map]], [[tbl_map]]) }}

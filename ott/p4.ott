embed
{{ hol
open wordsTheory;
}}
metavar x ::=
      {{ lex alphanum }}
      {{ hol string }}
      {{ tex [[x]] }}
      {{ com string }}
metavar num ::=
      {{ lex numeral }}
      {{ hol num }}
      {{ com natural number }}
%TODO Numeral or alphanum?
metavar b ::=
      {{ lex numeral }}
      {{ hol bool }}
      {{ tex [[b]] }}
      {{ com boolean }}
%TODO Ideally, one should have different word lengths
metavar n ::=
      {{ lex numeral }}
      {{ hol word64 }}
%TODO Causes problems with double subscript in LaTeX...
%      {{ tex [[n]]_{64} }}
      {{ tex [[n]] }}
      {{ com integer }}
indexvar i, j, k, l ::=
  {{ lex numeral }}
  {{ coq nat }}
  {{ hol num }}
  {{ com indices }}
grammar

%Statement semantics
%TODO: Add directed arguments (in, out, inout)

%%%%%%%%%%%%%%%
% Expressions %
%%%%%%%%%%%%%%%

%Unary operations
unop {{ tex \ominus }}:: unop_ ::=
| ! :: :: neg_bool
  {{ com boolean negation }}
  {{ tex ! }}
| ~ :: :: compl
  {{ com bitwise complement }}
  {{ tex \neg }}
| - :: :: neg_signed
  {{ com signed negation }}
| + :: :: un_plus
  %Defined as no-op for all values?
  {{ com unary plus }}

%Binary operations
%TODO: Saturating addition?
%TODO: Saturating subtraction?
binop {{ tex \oplus }} :: binop_ ::=
| * :: :: mul
  {{ com multiplication }}
  {{ tex \times }}
| / :: :: div
  {{ com division }}
| mod :: :: mod
  {{ com modulo }}
  {{ tex \bmod }}
  %Denoted by % in P4 specification
| + :: :: add
  {{ com addition }}
| - :: :: sub
  {{ com subtraction }}
| SHL :: :: shl
  {{ com left-shift }}
  {{ tex \ll }}
| SHR :: :: shr
  {{ com right-shift }}
  {{ tex \gg }}
| LE :: :: le
  {{ com less or equal }}
  {{ tex \leq }}
| GE :: :: ge
  {{ com greater or equal }}
  {{ tex \geq }}
| < :: :: ls
  {{ com less }}
  {{ tex < }}
| > :: :: gt
  {{ com greater }}
  {{ tex > }}
| NE :: :: neq
  {{ com not equal }}
  {{ tex \neq }}
| EQ :: :: eq
  {{ com equal }}
  {{ tex = }}
| & :: :: and
  {{ com bitwise and }}
| ^ :: :: xor
  {{ com bitwise xor }}
  {{ tex \underline{\vee} }}
| '|' :: :: or
  {{ com bitwise or }}
  {{ tex \mid }}
| AND :: :: bin_and
  {{ com binary and }}
  {{ tex \land }}
| OR :: :: bin_or
  {{ com binary or }}
  {{ tex \lor }}

%TODO: Members (dot)
%TODO: String literal
%TODO: L-values and identifiers
%TODO: ERROR
%TODO: Casts
%TODO: Structure-valued expressions
%TODO: Lists
%TODO: Tuples
%TODO: Enums
%TODO: Conditional operator
exp :: exp_ ::=
{{ com expression }}
| b :: :: bool
  {{ com boolean value }}
%  {{ hol [[b]] }}
| n :: :: int
  {{ com integer value }}
%  {{ hol [[n]] }}
| x :: :: var
  {{ com variable/function name }}
| unop exp :: :: unop
  {{ com unary operation }}
  {{ tex \ominus [[exp]] }}
| exp1 binop exp2 :: :: binop
  {{ com binary operation }}
  {{ tex [[exp1]] [[binop]] [[exp2]] }}
| call x ( exp1 , .. , expi ) :: :: func_call
  {{ com function call }}
| exec stmt :: :: func_exec
  {{ com function execution }}
| ( exp ) :: S :: paren
  {{ hol ([[exp]]) }}

%TODO: Trying to make a new definition for expression lists (mainly for function
%      arguments) proved problematic.
%      If all productions are meta, then you get args as a type abbreviation of "exp",
%      which is either undefined at the point where the abbreviation is made, or
%      exp_list is unknown when defining exp. Either way, mutually recursive definitions
%      are not possible. If nothing is meta and exp_list is not exported to a type
%      abbreviation, the function call semantics will not understand the "exp_list" and "exp list" correspondence.
exp_list :: exp_list_ ::=
{{ com list of expressions }}
{{ hol (exp list) }}
| empty_el :: M :: empty
  {{ com empty expression list }}
  {{ hol ([]:exp list) }}
| exp1 , .. , expi :: M :: list
  {{ com list of expressions }}
  {{ hol ([[exp1 .. expi]]) }}
%  {{ tex \mathit{expl}_i }}
| exp_list ++ exp_list' :: M :: append
  {{ com append two exp_lists }}
  {{ hol ([[exp_list]] ++ [[exp_list']]) }}
| update ( exp , num , ( exp_list ) ) :: M :: update
  {{ com update entry of expression list }}
  {{ hol (LUPDATE [[exp]] [[num]] [[exp_list]]) }}
  {{ tex ([[num]] \mapsto  [[exp]]) [[exp_list]] }}


%%%%%%%%%%%%%%
% Statements %
%%%%%%%%%%%%%%

decl :: decl_ ::=
{{ com declaration }}
| empty_decl :: :: empty
  {{ com empty declaration }}
| declare x exp :: :: stmt
  {{ com declaration }}
  {{ tex [[x]] \mathrel{\mathop:}:= [[exp]] }}
| decl1 ; decl2 :: :: seq
  {{ com sequence }}

%TODO: Switch statement
stmt :: stmt_ ::=
{{ com statement }}
| empty_stmt :: :: empty
  {{ com empty statement }}
  {{ tex \emptyset_{ \mathrm{stmt} } }}
| assign x exp :: :: ass
  {{ com assignment }}
  {{ tex [[x]] \mathrel{\mathop:}= [[exp]] }}
| if exp then stmt1 else stmt2 :: :: cond
  {{ com conditional }}
| begin decl stmt end :: :: block 
  {{ com block }}
  {{ tex \{ [[decl]] \,\, [[stmt]] \} }}
| begin' decl stmt end' :: :: block_ip
  {{ com block in progress }}
  {{ tex [ [[decl]] \,\, [[stmt]] ] }}
| return exp :: :: ret
  {{ com return }}
| stmt1 ; stmt2 :: :: seq
  {{ com sequence }}

func_map {{ tex F }} :: func_map_ ::=
{{ com function map  }}
{{ hol (string |-> (stmt # (string list))) }}
| empty :: M :: empty
  {{ com empty function map }}
  {{ hol FEMPTY }}
| func_map + [ x |-> stmt ] :: M :: update
  {{ com update variable mapping }}
  {{ hol (FUPDATE [[func_map]] ([[x]], [[stmt]])) }}


%%%%%%%%%%%%%%%%%%%
% Execution state %
%%%%%%%%%%%%%%%%%%%
%Note that this is not part of the P4 specification, but made up for verification purposes.

%Execution status.
status :: status_ ::=
 {{ com execution status }}
| Running :: :: running
| Return exp :: :: return
| TypeError :: :: type_error

scope :: scope_ ::=
{{ hol (string |-> exp) }}
{{ com frame/variable environment of current scope }}
| emptyscope :: M :: empty
  {{ com empty stack frame }}
  {{ hol FEMPTY }}
  {{ tex {\emptyset}_{ \mathrm{scope} } }}
| scope + [ x |-> exp ] :: M :: update
  {{ com update variable mapping }}
  {{ hol (FUPDATE [[scope]] ([[x]], [[exp]])) }}
  {{ tex ([[x]] \mapsto  [[exp]]) [[scope]] }}
| scope ++ [ x1 |-> exp1 , .. , xi |-> expi ] :: M :: update_list
  {{ com update variable mapping }}
  {{ hol (FUPDATE_LIST [[scope]] [[x1 exp1 .. xi expi]]) }}
  {{ tex \forall i . (x_i \mapsto  \mathit{exp}_i) [[scope]] }}
| ( scope ) :: S :: paren
  {{ hol ([[scope]]) }}

embed
{{ hol

}}
grammar

curr_stack_frame {{ tex \varepsilon }} :: curr_stack_frame_ ::=
{{ hol (scope list) }}
{{ com current stack frame - stack of block scopes }}
| emptycsf :: M :: empty
  {{ hol ([]:scope list) }}
  {{ tex {\emptyset}_{\varepsilon} }}
| [ scope1 , .. , scopei ] :: M :: list
  {{ hol ([[scope1 .. scopei]]) }}
| tl curr_stack_frame :: M :: tl
  {{ hol (TL [[curr_stack_frame]]) }}
  {{ tex \mathrm{tl} ([[curr_stack_frame]]) }}
| scope '::' curr_stack_frame' :: M :: cons
  {{ hol ([[scope]] :: [[curr_stack_frame']]) }}
  {{ tex [[scope]] \mathrel{\mathop:}: [[curr_stack_frame']] }}
| curr_stack_frame ++ curr_stack_frame' :: M :: append
  {{ hol ([[curr_stack_frame]] ++ [[curr_stack_frame']]) }}
  {{ tex [[curr_stack_frame]] \mathrel{\mathop+}+ [[curr_stack_frame']] }}
| update ( scope , num , curr_stack_frame ) :: M :: update
  {{ hol (LUPDATE [[scope]] [[num]] [[curr_stack_frame]]) }}
  {{ tex ([[num]] \mapsto  [[scope]]) [[curr_stack_frame]] }}
| ( curr_stack_frame ) :: S :: paren
  {{ hol ([[curr_stack_frame]]) }}

call_stack {{ tex E }} :: call_stack_ ::=
{{ com stack of caller stack frames }}
{{ hol (curr_stack_frame list) }}
| emptycs :: M :: empty
  {{ hol ([]:curr_stack_frame list) }}
  {{ tex {\emptyset}_{E} }}
| [ curr_stack_frame1 , .. , curr_stack_framei ] :: M :: list
  {{ hol ([[curr_stack_frame1 .. curr_stack_framei]]) }}
| curr_stack_frame '::' call_stack :: M :: cons
  {{ hol ([[curr_stack_frame]] :: [[call_stack]]) }}
  {{ tex [[curr_stack_frame]] \mathrel{\mathop:}: [[call_stack]] }}
| ( call_stack ) :: S :: paren
  {{ hol ([[call_stack]]) }}

stacks {{ tex \sigma }} :: stacks_ ::=
 {{ com stacks in execution state }}
| ( curr_stack_frame , call_stack ) :: :: tup

state {{ tex \Sigma }} :: state_ ::=
 {{ com execution state }}
| ( stacks , status ) :: :: tup


%%%%%%%%%%%%%%%%%%%%%%%%
% Expression semantics %
%%%%%%%%%%%%%%%%%%%%%%%%

terminals :: terminals_ ::=
| -> :: :: rightarrow {{ tex \rightarrow }}
| ~> :: :: rightsquigarrow {{ tex \rightsquigarrow }}

formula :: formula_ ::=
{{ com formulas }}
| judgement :: :: judgement
  {{ com judgement }}
%Expressions
| ! b = b' :: M :: neg_bool
  {{ hol (~[[b]] = [[b']]) }}
| ~ n = n' :: M :: compl
  %TODO
  {{ hol (~ [[n]] = [[n']]) }}
| - n = n' :: M :: neg_signed
  %TODO
  {{ hol (~ [[n]] = [[n']]) }}
| + n = n' :: M :: un_plus
  %TODO: Read specification...
  {{ hol ([[n]] = [[n']]) }}
| n * n' = n'' :: M :: mul
  {{ hol (word_mul [[n]] [[n']] = [[n'']]) }}
| n / n' = n'' :: M :: div
  {{ hol (word_div [[n]] [[n']] = [[n'']]) }}
| n mod n' = n'' :: M :: mod
  {{ hol (word_mod [[n]] [[n']] = [[n'']]) }}
| n + n' = n'' :: M :: add
  {{ hol (word_add [[n]] [[n']] = [[n'']]) }}
| n - n' = n'' :: M :: sub
  {{ hol (word_sub [[n]] [[n']] = [[n'']]) }}
%TODO: EQ for const?
| n EQ n' = b :: M :: eq_word
  {{ hol ([[n]] = [[n']] <=> [[b]]) }}
| b EQ b' = b'' :: M :: eq_bool
  {{ hol ([[b]] = [[b']] <=> [[b'']]) }}
| n SHL n' = n'' :: M :: shl
  {{ hol (word_lsl_bv [[n]] [[n']] = [[n'']]) }}
  %TODO: Double-check
| n SHR n' = n'' :: M :: shr
  {{ hol (word_asr_bv [[n]] [[n']] = [[n'']]) }}
  %TODO: Double-check
| n LE n' = b :: M :: le
  {{ hol ([[n]] <= [[n']] <=> [[b]]) }}
| n GE n' = b :: M :: ge
  {{ hol ([[n]] >= [[n']] <=> [[b]]) }}
| n < n' = b :: M :: lt
  {{ hol ([[n]] < [[n']] <=> [[b]]) }}
| n > n' = b :: M :: gt
  {{ hol ([[n]] > [[n']] <=> [[b]]) }}
| n NE n' = b :: M :: neq_word
  {{ hol ([[n]] <> [[n']] <=> [[b]]) }}
| n & n' = n'' :: M :: and_word
  {{ hol (word_and [[n]] [[n']] = [[n'']]) }}
| n ^ n' = n'' :: M :: xor_word
  {{ hol (word_xor [[n]] [[n']] = [[n'']]) }}
  %TODO: LaTeX XOR
| n '|' n' = n'' :: M :: or_word
  {{ hol (word_or [[n]] [[n']] = [[n'']]) }}
| b AND b' = b'' :: M :: and_bool
  {{ hol ([[b]] /\ [[b']] = [[b'']]) }}
| b OR b' = b'' :: M :: or_bool
  {{ hol ([[b]] \/ [[b']] = [[b'']]) }}

%Type-transforming operations
| curr_stack_frame = hd call_stack :: M :: call_stack_hd
  {{ hol ([[curr_stack_frame]] = HD [[call_stack]]) }}
  {{ tex [[curr_stack_frame]] = \mathrm{hd} [[call_stack]] }}
| scope = curr_stack_frame [ num ] :: M :: curr_stack_frame_index
  {{ hol ([[scope]] = EL [[num]] [[curr_stack_frame]]) }}
| ( stmt , x1 , .. , xi ) = func_map ( x ) :: M :: func_lookup
  {{ com function lookup }}
  {{ hol (FLOOKUP [[func_map]] [[x]] = SOME ([[stmt]], [[x1 .. xi]])) }}
| find_index ( curr_stack_frame , x ) = num :: M :: find_index_scope
  {{ com find index of variable's scope }}
  %INDEX_FIND finds the first occurrence, starting from head and going backwards in list
  {{ hol (FST (THE (INDEX_FIND 0 (\sf. IS_SOME (FLOOKUP sf [[x]])) [[curr_stack_frame]])) = [[num]]) }}
  {{ tex [[x]] \in \mathrm{dom}([[curr_stack_frame]][ [[num]] ]) \land \forall j . \,\, j > [[num]] \Rightarrow [[x]] \notin \mathrm{dom}([[curr_stack_frame]][j]) }}
| exp = scope ( x ) :: M :: lookup
  {{ com look-up of variable in scope }}
  {{ hol (FLOOKUP [[scope]] [[x]] = SOME [[exp]]) }}
| exp = exp_list [ num ] :: M :: args_index
  {{ hol ([[exp]] = EL [[num]] [[exp_list]]) }}
| exp = hd exp_list :: M :: args_hd
  {{ hol ([[exp]] = HD [[exp_list]]) }}
  {{ hol ([[exp]] = \mathrm{hd} [[exp_list]]) }}

%Function argument resolution
%TODO: Replace with expression list
| exp'1 , .. , exp'j ++ exp''1 , .. , exp''k = exp1 , .. , expi :: M :: func_args_append
  {{ com pattern match on constant and non-constant function arguments }}
  {{ hol (([[exp'1 .. exp'j]] ++ [[exp''1 .. exp''k]]) = [[exp1 .. expi]]) }}

%Conditions
| b = true :: M :: is_true
  {{ com condition true }}
  {{ hol ([[b]] = T) }}
  {{ tex [[b]] = \mathrm{True} }}
| b = false :: M :: is_false
  {{ com condition false }}
  {{ hol ([[b]] = F) }}
  {{ tex [[b]] = \mathrm{False} }}
| is_empty ( exp_list ) :: M :: args_empty
  {{ com function arguments empty }}
  {{ hol (NULL [[exp_list]]) }}
  {{ tex \mathit{exp}_1 , .. , \mathit{exp}_i = \{ \} }}

%Equalities
| scope = scope' :: M :: scope_eq
  {{ com scope equality }}
  {{ hol ([[scope]] = [[scope']]) }}
| curr_stack_frame = curr_stack_frame' :: M :: curr_stack_frame_eq
  {{ com curr_stack_frame equality }}
  {{ hol ([[curr_stack_frame]] = [[curr_stack_frame']]) }}
| call_stack = call_stack' :: M :: call_stack_eq
  {{ com call_stack equality }}
  {{ hol ([[call_stack]] = [[call_stack']]) }}
%TODO: This can cause confusion with the judgements with binary expression equalities, hencec the '...
| exp_list =' exp_list' :: M :: args_eq
  {{ com args equality }}
  {{ hol ([[exp_list]] = [[exp_list']]) }}
  {{ tex ([[exp_list]] = [[exp_list']]) }}

%MISC (TODO)
%TODO: Equalities and inequalities on numerals
| num' = num + 1 :: M :: num_inc
  {{ com numeral increment }}
  {{ hol ([[num']] = [[num]] + 1) }}
  {{ tex [[num']] = [[num]] + 1 }}
| num = length ( exp1 , .. , expi ) :: M :: num_len
  {{ com length of list }}
  {{ hol ([[num]] = LENGTH [[exp1 .. expi]]) }}
%  {{ tex [[num]] = \mathrm{len}(\mathit{exp}_1 , .. , \mathit{exp}_i) }}
| num < length ( exp_list ) :: M :: num_in_rg
  {{ com numeral in range }}
  {{ hol ([[num]] < LENGTH [[exp_list]]) }}
  {{ tex [[num]] < \mathrm{len}(\mathit{exp}) }}
| is_const ( exp ) :: M :: exp_const
  {{ com expression constant }}
  {{ hol (is_const [[exp]]) }}
  {{ tex \mathrm{is\_const} ([[exp]]) }}
| is_consts ( exp1 , .. , expi ) :: M :: args_const
  {{ com function arguments constant }}
  {{ hol (is_consts [[exp1 .. expi]]) }}
  %TODO: Fix typesetting
  {{ tex \mathrm{is\_consts} (\mathit{exp}_1 , .. , \mathit{exp}_i) }}

embed
{{ hol
val is_const_def = Define `
    ( is_const (exp_bool b) = T)
/\  ( is_const (exp_int n) = T)
/\  ( is_const _ = F)
`;
val is_consts_def = Define `
    (is_consts exp_list = ~(EXISTS (\el. ~(is_const el)) exp_list))
`;
}}
grammar

defns
  exp_sem :: '' ::=
defn
  [ exp ] ( stacks , status ) ~> [ exp' ] ( stacks' , status' ) :: :: exp_red :: exp_
  {{ com expression semantics }}
  %Uses different export homs for LaTeX and HOL4 so that LaTeX hides unnecessary status
  {{ tex [ [[exp]] ] [[stacks]] \rightsquigarrow [ [[exp']] ] [[stacks']] }}
by

%%%%%%%%%%%%%%
%Function call + exec (in expression)

  %Resolving arguments to function call - reduction
  %TODO: force exp'1 , .. , exp'j to be non-empty?
  exp'1 , .. , exp'j ++ exp''1 , .. , exp''k = exp1 , .. , expi
  is_consts ( exp'1 , .. , exp'j )
  exp = hd exp''1 , .. , exp''k
  [ exp ] ( stacks , Running ) ~> [ exp' ] ( stacks' , Running )
  %TODO: length plus 1 if indexing from 1
  num = length ( exp'1 , .. , exp'j )
  exp'''1 , .. , exp'''l =' update ( exp' , num , ( exp1 , .. , expi ) )
  ----------------------------------- :: func_call_args1
  [call x ( exp1 , .. , expi )] ( stacks , Running ) ~> [call x ( exp'''1 , .. , exp'''l )] ( stacks , Running )

  %Resolving arguments to function call - assigning arguments to new stack frame
  is_consts ( exp1 , .. , expi )
  ( stmt , x1 , .. , xi ) = func_map ( x )
  scope' = emptyscope ++ [ x1 |->  exp1 , .. , xi |-> expi ]
  scope = curr_stack_frame[0]
  curr_stack_frame' = scope' :: [scope]
  call_stack' = tl curr_stack_frame :: call_stack
  ----------------------------------- :: func_call_args2
  [call x ( exp1 , .. , expi )] ( ( curr_stack_frame , call_stack ) , Running ) ~> [ exec stmt ] ( ( curr_stack_frame' , call_stack' ) , Running )

  [stmt] ( stacks , Running ) -> [stmt'] ( stacks' , Running )
  ----------------------------------- :: func_exec
  [exec stmt] ( stacks , Running ) ~> [exec stmt'] ( stacks' , Running )

  is_const ( exp )
  ----------------------------------- :: func_ret_exp
  [exec empty_stmt] ( stacks , Return exp ) ~> [exp] ( stacks' , Running )

%%%%%%%%%%%%%%%%%
%Variable look-up

  find_index ( curr_stack_frame, x ) = num
  scope = curr_stack_frame [ num ]
  exp = scope ( x )
  is_const ( exp )
  ----------------------------------- :: lookup
  [x] ( ( curr_stack_frame, call_stack ) , Running ) ~> [exp] ( ( curr_stack_frame, call_stack ) , Running )


%%%%%%%%%%%%%%%%%%%
%Unary expressions%
%%%%%%%%%%%%%%%%%%%


  [exp] ( stacks , Running ) ~> [exp'] ( stacks' , Running )
  ----------------------------------- :: unop
  [unop exp] ( stacks , Running ) ~> [unop exp'] ( stacks' , Running )

%%%%%%%%%%%%%%%%%
%Boolean negation

  ! b = b'
  ----------------------------------- :: neg_bool
  [! b] ( stacks , Running ) ~> [b'] ( stacks , Running )

%%%%%%%%%%%%%%%%%%%
%Bitwise complement

  ~ n = n'
  ----------------------------------- :: compl
  [~ n] ( stacks , Running ) ~> [n'] ( stacks , Running )

%%%%%%%%%%%%%%%%
%Signed negation

  - n = n'
  ----------------------------------- :: neg_signed
  [- n] ( stacks , Running ) ~> [n'] ( stacks , Running )

%%%%%%%%%%%
%Unary plus

  + n = n'
  ----------------------------------- :: un_plus
  [+ n] ( stacks , Running ) ~> [n'] ( stacks , Running )


%%%%%%%%%%%%%%%%%%%%
%Binary expressions%
%%%%%%%%%%%%%%%%%%%%

%Reduce 1st operand
%Reduce 2nd operand, given 1st has been completely reduced
%Evaluate expression on 2 completely reduced operands

%%%%%%%%%%%%
%Binary operations - general reductions

  [exp] ( stacks , Running ) ~> [exp''] ( stacks' , Running )
  ----------------------------------- :: binop1
  [exp binop exp'] ( stacks , Running ) ~> [exp'' binop exp'] ( stacks' , Running )

  is_const ( exp )
  [exp'] ( stacks , Running ) ~> [exp''] ( stacks' , Running )
  ----------------------------------- :: binop2
  [exp binop exp'] ( stacks , Running ) ~> [exp binop exp''] ( stacks' , Running )


%%%%%%%%%%%%%%%
%Multiplication

  n * n' = n''
  ----------------------------------- :: mul
  [n * n'] ( stacks , Running ) ~> [n''] ( stacks , Running )

%%%%%%%%%%%%%%%
%Division

  n / n' = n''
  ----------------------------------- :: div
  [n / n'] ( stacks , Running ) ~> [n''] ( stacks , Running )

%%%%%%%%%%%%%%%
%Modulo

  n mod n' = n''
  ----------------------------------- :: mod
  [n mod n'] ( stacks , Running ) ~> [n''] ( stacks , Running )

%%%%%%%%%%%%
%Addition

  n + n' = n''
  ----------------------------------- :: add
  [n + n'] ( stacks , Running ) ~> [n''] ( stacks , Running )

%%%%%%%%%%%%
%Subtraction

  n - n' = n''
  ----------------------------------- :: sub
  [n - n'] ( stacks , Running ) ~> [n''] ( stacks , Running )

%%%%%%%%%%%%
%Left shift

  n SHL n' = n''
  ----------------------------------- :: shl
  [n SHL n'] ( stacks , Running ) ~> [n''] ( stacks , Running )

%%%%%%%%%%%%
%Right shift

  n SHR n' = n''
  ----------------------------------- :: shr
  [n SHR n'] ( stacks , Running ) ~> [n''] ( stacks , Running )

%%%%%%%%%%%%%%%%%%%
%Less than or equal

  n LE n' = b
  ----------------------------------- :: le
  [n LE n'] ( stacks , Running ) ~> [b] ( stacks , Running )

%%%%%%%%%%%%%%%%%%%%%%
%Greater than or equal

  n GE n' = b
  ----------------------------------- :: ge
  [n GE n'] ( stacks , Running ) ~> [b] ( stacks , Running )

%%%%%%%%%%
%Less than

  n < n' = b
  ----------------------------------- :: lt
  [n < n'] ( stacks , Running ) ~> [b] ( stacks , Running )

%%%%%%%%%%%%%
%Greater than

  n > n' = b
  ----------------------------------- :: gt
  [n > n'] ( stacks , Running ) ~> [b] ( stacks , Running )

%%%%%%%%%%%%%
%Not equal

  n NE n' = b
  ----------------------------------- :: neq
  [n NE n'] ( stacks , Running ) ~> [b] ( stacks , Running )

%%%%%%%%%%%%%
%Equal

  n EQ n' = b
  ----------------------------------- :: eq
  [n EQ n'] ( stacks , Running ) ~> [b] ( stacks , Running )

%%%%%%%%%%%%%
%Bitwise and

  n & n' = n''
  ----------------------------------- :: and
  [n & n'] ( stacks , Running ) ~> [n''] ( stacks , Running )

%%%%%%%%%%%%%
%Bitwise xor

  n ^ n' = n''
  ----------------------------------- :: xor
  [n ^ n'] ( stacks , Running ) ~> [n''] ( stacks , Running )

%%%%%%%%%%%%%
%Bitwise or

  n | n' = n''
  ----------------------------------- :: or
  [n | n'] ( stacks , Running ) ~> [n''] ( stacks , Running )

%%%%%%%%%%%%%
%Binary and

  b AND b' = b''
  ----------------------------------- :: bin_and
  [b AND b'] ( stacks , Running ) ~> [b''] ( stacks , Running )

%%%%%%%%%%%%%
%Binary or

  b OR b' = b''
  ----------------------------------- :: bin_or
  [b OR b'] ( stacks , Running ) ~> [b''] ( stacks , Running )


%%%%%%%%%%%%%%%%%%%%%%%%%
% Declaration semantics %
%%%%%%%%%%%%%%%%%%%%%%%%%

defns
  decl_sem :: '' ::=
defn
  [ decl ] state -> [ decl' ] state' :: :: decl_red :: decl_
  {{ com declaration semantics }}
by

  %Declare a variable and assign a value - reduction step
  [exp] ( stacks , Running ) ~> [exp'] ( stacks' , Running )
  ----------------------------------- :: decl_exp
  [declare x exp] ( stacks , Running ) -> [declare x exp'] ( stacks' , Running )

  scope :: curr_stack_frame' = curr_stack_frame
  scope' = scope + [ x |-> n ]
  curr_stack_frame'' = scope' :: curr_stack_frame'
  ----------------------------------- :: decl_const
  [declare x n] ( ( curr_stack_frame , call_stack ) , Running ) -> [empty_decl] ( ( curr_stack_frame'' , call_stack ) , Running )

  [decl1] ( stacks , Running ) -> [decl1'] ( stacks' , Running )
  ----------------------------------- :: seq1
  [decl1 ; decl2] ( stacks , Running ) -> [decl1' ; decl2] ( stacks' , Running )

  ----------------------------------- :: seq2
  [empty_decl ; decl] ( stacks , Running ) -> [decl] ( stacks , Running )


%%%%%%%%%%%%%%%%%%%%%%%
% Statement semantics %
%%%%%%%%%%%%%%%%%%%%%%%

%TODO: Block
%TODO: Exit
%TODO: Switch

defns
  stmt_sem :: '' ::=
defn
  [ stmt ] state -> [ stmt' ] state' :: :: stmt_red :: stmt_
  {{ com statement semantics }}
by

%%%%%%%%%%%%%%
%Return

  %Return with an expression - reduction step
  [exp] ( stacks , Running ) ~> [exp'] ( stacks' , Running )
  ----------------------------------- :: ret_exp
  [return exp] ( stacks , Running ) -> [return exp'] ( stacks' , Running )

  %Return with a constant
  is_const ( exp )
  scope = curr_stack_frame [ 0 ]
  curr_stack_frame' :: call_stack' = call_stack
  curr_stack_frame'' = ( curr_stack_frame' ) ++ ( [ scope ] )
  ----------------------------------- :: ret_const
  [return exp] ( ( curr_stack_frame , call_stack ) , Running ) -> [empty_stmt] ( ( curr_stack_frame'' , call_stack' ) , Return exp )

%%%%%%%%%%%%%%
%Assignment

  %Assign a constant to a variable
  is_const ( exp )
  find_index ( curr_stack_frame , x ) = num
  scope = curr_stack_frame [ num ]
  scope' = scope + [ x |-> exp ]
  curr_stack_frame' = update ( scope' , num , curr_stack_frame )
  ----------------------------------- :: ass_const
  [assign x exp] ( ( curr_stack_frame , call_stack ) , Running ) -> [empty_stmt] ( ( curr_stack_frame' , call_stack ) , Running )

  %Assign an expression to a variable - reduction step
  [exp] ( stacks , Running ) ~> [exp'] ( stacks' , Running )
  ----------------------------------- :: ass_exp
  [assign x exp] ( stacks , Running ) -> [assign x exp'] ( stacks' , Running )

%%%%%%%%%%%%%%
%Sequence

  [stmt1] ( stacks , Running ) -> [stmt1'] ( stacks' , Running )
  ----------------------------------- :: seq1
  [stmt1 ; stmt2] ( stacks , Running ) -> [stmt1' ; stmt2] ( stacks' , Running )

  ----------------------------------- :: seq2
  [empty_stmt ; stmt] ( stacks , Running ) -> [stmt] ( stacks , Running )

  [stmt1] ( stacks , Running ) -> [stmt1'] ( stacks' , Return exp )
  ----------------------------------- :: seq3
  [stmt1 ; stmt2] ( stacks , Running ) -> [ empty_stmt ] ( stacks' , Return exp )

%%%%%%%%%%%%%%
%Conditional

  [exp] ( stacks , Running ) ~> [exp'] ( stacks' , Running )
  ----------------------------------- :: cond1
  [if exp then stmt1 else stmt2] ( stacks , Running ) -> [if exp' then stmt1 else stmt2] ( stacks' , Running )

  b = true
  ----------------------------------- :: cond2
  [if b then stmt1 else stmt2] ( stacks , Running ) -> [stmt1] ( stacks , Running )

  b = false
  ----------------------------------- :: cond3
  [if b then stmt1 else stmt2] ( stacks , Running ) -> [stmt2] ( stacks , Running )

%%%%%%%%%%%%%%
%Block
 
  curr_stack_frame' = emptyscope :: curr_stack_frame
  ----------------------------------- :: block_enter
  [begin decl stmt end] ( ( curr_stack_frame , call_stack ) , Running ) -> [begin' decl stmt end'] ( ( curr_stack_frame' , call_stack ) , Running )


  [decl] ( stacks , Running ) -> [decl'] ( stacks' , Running )
  ----------------------------------- :: block_declare
  [begin' decl stmt end'] ( stacks , Running ) -> [begin' decl' stmt end'] ( stacks' , Running )


  [stmt] ( stacks , Running ) -> [stmt'] ( stacks' , Running )
  ----------------------------------- :: block_stmt
  [begin' empty_decl stmt end'] ( stacks , Running ) -> [begin' empty_decl stmt' end'] ( stacks' , Running )


  curr_stack_frame' = tl curr_stack_frame
  ----------------------------------- :: block_exit
  [begin' empty_decl empty_stmt end'] ( ( curr_stack_frame , call_stack ) , Running ) -> [empty_stmt] ( ( curr_stack_frame' , call_stack ) , Running )


%%%%%%%%%%%%%%
%Exit

  %TODO: exit semantics might require to have a specific "function-in-progress" statement
  %      in order to know what to reduce to nothing.
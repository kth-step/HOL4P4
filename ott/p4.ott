embed
{{ hol
open wordsTheory;
}}

%%%%%%%%%%%%%%%%%
% P4 base types %
%%%%%%%%%%%%%%%%%

%x denotes variable name, f denotes field name or function name
%msg denotes error message
metavar x, f, msg ::=
      {{ lex alphanum }}
      {{ hol string }}
      {{ tex [[x]] }}
      {{ com string }}
%TODO Numeral or alphanum?
metavar b ::=
      {{ lex numeral }}
      {{ hol bool }}
      {{ tex [[b]] }}
      {{ com boolean }}
%TODO Ideally, one should have different word lengths
metavar nw ::=
      {{ lex numeral }}
      {{ hol word64 }}
%TODO Causes problems with double subscript in LaTeX...
%      {{ tex [[n]]_{64} }}
      {{ tex {n_w} }}
      {{ com integer }}

%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Auxiliary metavariables %
%%%%%%%%%%%%%%%%%%%%%%%%%%%

metavar i ::=
      {{ lex numeral }}
      {{ hol num }}
      {{ tex [[i]] }}
      {{ com natural number }}
indexvar m, n, o ::=
  {{ lex numeral }}
  {{ coq nat }}
  {{ hol num }}
  {{ com indices }}
grammar 

%Statement semantics
%TODO: Add directed arguments (in, out, inout)

%%%%%%%%%%%%%%%
% Expressions %
%%%%%%%%%%%%%%%

%Unary operations
unop {{ tex \ominus }}:: unop_ ::=
| ! :: :: neg_bool
  {{ com boolean negation }}
  {{ tex ! }}
| ~ :: :: compl
  {{ com bitwise complement }}
  {{ tex \neg }}
| - :: :: neg_signed
  {{ com signed negation }}
| + :: :: un_plus
  %Defined as no-op for all values?
  {{ com unary plus }}

%Binary operations
%TODO: Saturating addition?
%TODO: Saturating subtraction?
binop {{ tex \oplus }} :: binop_ ::=
| * :: :: mul
  {{ com multiplication }}
  {{ tex \times }}
| / :: :: div
  {{ com division }}
| mod :: :: mod
  {{ com modulo }}
  {{ tex \bmod }}
  %Denoted by % in P4 specification
| + :: :: add
  {{ com addition }}
| - :: :: sub
  {{ com subtraction }}
| SHL :: :: shl
  {{ com left-shift }}
  {{ tex \ll }}
| SHR :: :: shr
  {{ com right-shift }}
  {{ tex \gg }}
| LE :: :: le
  {{ com less or equal }}
  {{ tex \leq }}
| GE :: :: ge
  {{ com greater or equal }}
  {{ tex \geq }}
| < :: :: ls
  {{ com less }}
  {{ tex < }}
| > :: :: gt
  {{ com greater }}
  {{ tex > }}
| NE :: :: neq
  {{ com not equal }}
  {{ tex \neq }}
| EQ :: :: eq
  {{ com equal }}
  {{ tex = }}
| & :: :: and
  {{ com bitwise and }}
| ^ :: :: xor
  {{ com bitwise xor }}
  {{ tex \underline{\vee} }}
| '|' :: :: or
  {{ com bitwise or }}
  {{ tex \mid }}
| AND :: :: bin_and
  {{ com binary and }}
  {{ tex \land }}
| OR :: :: bin_or
  {{ com binary or }}
  {{ tex \lor }}

% Can't be called "bool" since this already exists in HOL4
boolv :: boolv_ ::=
{{ hol bool }}
{{ com boolean }}
| b :: M :: free
  {{ hol [[b]] }}
| true :: M :: true
  {{ hol T }}
| false :: M :: false
  {{ hol F }}

%Base types
bt {{ tex bt }} :: bt_ ::=
{{ com base types }}
| bool_t :: :: bool
  {{ tex { \mathrm{bool}_{ \mathrm{t} } } }}
| int_t :: :: int
  {{ tex { \mathrm{int}_{ \mathrm{t} } } }}

%Types
t {{ tex t }} :: t_ ::=
{{ com types }}
| bt :: :: base
| struct_t t1 , ... , tn :: :: struct
  {{ tex { \mathrm{struct}_{ \mathrm{t} }\,\, t_1 , \ldots , t_n } }}

%TODO: String literal
%TODO: L-values and identifiers
%TODO: Enums
%Constants should be thought of as "values of variables we look up"
v :: v_ ::=
{{ com constant }}
| boolv :: :: bool
  {{ com boolean value }}
| nw :: :: int
  {{ com integer }}
| struct { x1 = v1 ; ... ; xn = vn } :: :: struct
  {{ com struct }} %TODO: Ott User Guide 12.2  List comprehension forms
%| header { x1 = v1 ; ... ; xn = vn } :: :: header
%  % A header is like a struct, but has different well-formedness conditions
%  {{ com header }}
%  {{ tex header }} %TODO
%%TODO: An extern should contain an internally visible list of mappings between variable names and constants,
%%      and a map from function names to their bodies and arguments
%% See https://github.com/p4lang/p4c/blob/main/p4include/core.p4 , e.g. packet_in definition
| errmsg x :: :: err
  {{ com error message }}
%TODO: Represent uninitialised variables? Default values?
%See https://p4lang.github.io/p4-spec/docs/P4-16-v1.2.2.html#sec-uninitialized-values-and-writing-invalid-headers
| uninit :: :: uninit
  {{ com uninitialized value }}
  {{ tex ? }}
  {{ hol (ARB) }}

%TODO: Array element
%TODO: Bitslice
lval :: lval_ ::=
| x :: :: varname
  {{ com variable name }}
| lval . f :: :: field
  {{ com field access }}
| ( lval ) :: X :: paren
  {{ hol ([[lval]]) }}

%TODO: Casts
%TODO: Lists
%TODO: Tuples
%TODO: Conditional operator
e :: e_ ::=
{{ com expression }}
| v :: :: v
 {{com constant value}}
| x :: :: var
  {{ com variable name }}
| { e1 , .. , en } :: :: list
  {{ com expression list }}
| e . e' :: :: acc
  {{ com field access }}
%TODO: Struct field manipulation (does not exist in P4, solely meta) now among judgments
%| v with f := e :: I :: with
%  {{ com struct field manipulation }}
| unop e :: :: unop
  {{ com unary operation }}
  {{ tex [[unop]] [[e]] }}
| e1 binop e2 :: :: binop
  {{ com binary operation }}
  {{ tex [[e1]] [[binop]] [[e2]] }}
| call f ( e1 , .. , en ) :: :: func_call
  {{ com function call }}
  {{ hol (exp_func_call [[f]] [[e1 .. en]]) }}
| exec stmt :: I :: func_exec
  {{ com function execution }}
| ( e ) :: X :: paren
  {{ hol ([[e]]) }}

%TODO: Trying to make a new definition for expression lists (mainly for function
%      arguments) proved problematic.
%      If all e_list productions are meta, then you get e_list as a type abbreviation of "e list",
%      which is either undefined at the point where the abbreviation is made, or
%      e_list is unknown when defining e (and specifically function call, which would use e_list).
%      In both situations, mutually recursive definitions are not possible.
%
%      If nothing is meta and e_list is not exported to a type abbreviation, you risk the function call semantics not understanding the "e_list" and "e list" correspondence. However, this seems to work currently.
e_list :: e_list_ ::=
{{ com list of expressions }}
{{ hol (e list) }}
| empty_el :: M :: empty
  {{ com empty expression list }}
  {{ hol ([]:e list) }}
| e1 , .. , en :: M :: exps
  {{ com list of expressions }}
  {{ hol ([[e1 .. en]]) }}
| e_list ++ e_list' :: M :: append
  {{ com append two e_lists }}
  {{ hol ([[e_list]] ++ [[e_list']]) }}
| update ( e , i , e_list ) :: M :: update
  {{ com update entry of expression list }}
  {{ hol (LUPDATE [[e]] [[i]] [[e_list]]) }}
  {{ tex ([[i]] \mapsto  [[e]]) [[e_list]] }}
| ( e_list ) :: S :: paren
  {{ hol ([[e_list]]) }}


%%%%%%%%%%%%%%
% Statements %
%%%%%%%%%%%%%%

%decl :: decl_ ::=
%{{ com declaration }}
%| empty_decl :: :: empty
%  {{ com empty declaration }}
%  {{ tex \emptyset_{ \mathrm{decl} } }}
%| declare x e :: :: stmt
%  {{ com declaration }}
%  {{ tex [[x]] \mathrel{\mathop:}:= [[e]] }}
%| decl1 ; decl2 :: :: seq
%  {{ com sequence }}

pars_fin {{ tex p_{ \mathrm{fin} } }} :: pars_fin ::=
{{ com final parser states }}
| Accept :: :: accept
  {{ com accepted state }}
| Reject x :: :: reject
  {{ com rejected state }}

pars_next {{ tex p }} :: pars_next_ ::=
{{ com parser next state }}
| Trans x :: :: trans
  {{ com transition to named state }}
| pars_fin :: :: pars_fin
  {{ com final state }}

%TODO: Switch statement
stmt :: stmt_ ::=
{{ com statement }}
| empty_stmt :: :: empty
  {{ com empty statement }}
  {{ tex \emptyset_{ \mathrm{stmt} } }}
| assign lval e :: :: ass
  {{ com assignment }}
  {{ tex [[lval]] \mathrel{\mathop:}= [[e]] }}
| if e then stmt1 else stmt2 :: :: cond
  {{ com conditional }}
| decl x t :: :: declare
  {{ com declaration }}
| begin stmt end :: :: block 
  {{ com block }}
  {{ tex \{ [[stmt]] \} }}
| begin' stmt end' :: I :: block_ip
  {{ com block in progress }}
  {{ tex [ [[stmt]] ] }}
| return e :: :: ret
  {{ com return }}
| stmt1 ; stmt2 :: :: seq
  {{ com sequence }}
| verify e e' :: :: verify
  % e is predicate, e' is error message
  {{ com verify }}
| transition pars_next :: :: trans
  % x is the parser state name
  {{ com transition }}
  {{ tex \mathbf{transition}\, [[pars_next]] }}

func_map {{ tex F }} :: func_map_ ::=
{{ com function map  }}
{{ hol (string |-> (stmt # (string list))) }}
| empty :: M :: empty
  {{ com empty function map }}
  {{ hol FEMPTY }}
| func_map + [ x |-> stmt ] :: M :: update
  {{ com update variable mapping }}
  {{ hol (FUPDATE [[func_map]] ([[x]], [[stmt]])) }}

% TODO: Could be just an abbreviation, since it's never changed...
pars_map {{ tex P }} :: pars_map_ ::=
{{ com parser state map  }}
{{ hol (string |-> stmt) }}
| empty :: M :: empty
  {{ com empty parser state map }}
  {{ hol FEMPTY }}

% TODO: Could be just an abbreviation, since it's never changed...
type_map {{ tex T }} :: type_map_ ::=
{{ com type environment  }}
{{ hol (string |-> ((string # t) list)) }}
| empty :: M :: empty
  {{ com empty type environment }}
  {{ hol FEMPTY }}

%%%%%%%%%%%%%%%%%%%
% Execution state %
%%%%%%%%%%%%%%%%%%%
%Note that this is not part of the P4 specification, but made up for verification purposes.

%Execution status.
status {{ tex t }}:: status_ ::=
 {{ com execution status }}
| Running :: I :: running
  {{ tex { \mathbf{R} } }}
| Return v :: I :: return
  {{ tex { \mathbf{Ret} \,\, [[v]]} }}
| pars_next :: I :: pars_next
| TypeError :: I :: type_error
  {{ tex { \bot } }}

scope {{ tex \gamma }} :: scope_ ::=
{{ hol (string |-> v) }}
{{ com frame/variable environment of current scope }}
| emptyscope :: M :: empty
  {{ com empty stack frame }}
  {{ hol FEMPTY }}
  {{ tex {\gamma}_{ \emptyset } }}
| scope + [ x |-> v ] :: M :: update
  {{ com update variable mapping }}
  {{ hol (FUPDATE [[scope]] ([[x]], [[v]])) }}
  {{ tex ([[x]] \mapsto  [[v]]) [[scope]] }}
| scope ++ [ x1 |-> v1 , .. , xn |-> vn ] :: M :: update_list
  {{ com update variable mapping }}
  {{ hol (FUPDATE_LIST [[scope]] [[x1 v1 .. xn vn]]) }}
%TODO LaTeX cannot have dot form...
  {{ tex \forall i \leq n. \,\, (x_i \mapsto  \mathit{v}_i) \,\, [[scope]] }}
| ( scope ) :: S :: paren
  {{ hol ([[scope]]) }}
| G scope :: M :: global
  {{ com global scope }}
  {{ tex {[[scope]]}_G }}
  {{ hol [[scope]] }}
  

%Fence so that ott does not re-order curr_stack_frame
embed
{{ hol

}}
grammar

curr_stack_frame {{ tex \varepsilon }} :: curr_stack_frame_ ::=
{{ hol (scope list) }}
{{ com current stack frame - stack of block scopes }}
| emptycsf :: M :: empty
  {{ hol ([]:scope list) }}
  {{ tex {\emptyset}_{\varepsilon} }}
| [ scope1 , .. , scopen ] :: M :: list
  {{ hol ([[scope1 .. scopen]]) }}
| tl curr_stack_frame :: M :: tl
  {{ hol (TL [[curr_stack_frame]]) }}
  {{ tex \mathrm{tl} ([[curr_stack_frame]]) }}
| scope '::' curr_stack_frame' :: M :: cons
  {{ hol ([[scope]] :: [[curr_stack_frame']]) }}
  {{ tex [[scope]] :: [[curr_stack_frame']] }}
| curr_stack_frame ++ curr_stack_frame' :: M :: append
  {{ hol ([[curr_stack_frame]] ++ [[curr_stack_frame']]) }}
  {{ tex [[curr_stack_frame]] \mathrel{\mathop+}+ [[curr_stack_frame']] }}
| update ( scope , i , curr_stack_frame ) :: M :: update
  {{ hol (LUPDATE [[scope]] [[i]] [[curr_stack_frame]]) }}
  {{ tex ([[i]] \mapsto [[scope]]) [[curr_stack_frame]] }}
| ( curr_stack_frame ) :: S :: paren
  {{ hol ([[curr_stack_frame]]) }}

%Fence so that ott does not re-order curr_stack_frame
embed
{{ hol

}}
grammar

call_stack {{ tex E }} :: call_stack_ ::=
{{ com stack of caller stack frames }}
{{ hol (curr_stack_frame list) }}
| emptycs :: M :: empty
  {{ hol ([]:curr_stack_frame list) }}
  {{ tex {\emptyset}_{E} }}
| [ curr_stack_frame1 , .. , curr_stack_framen ] :: M :: list
  {{ hol ([[curr_stack_frame1 .. curr_stack_framen]]) }}
| curr_stack_frame '::' call_stack :: M :: cons
  {{ hol ([[curr_stack_frame]] :: [[call_stack]]) }}
  {{ tex [[curr_stack_frame]] :: [[call_stack]] }}
| ( call_stack ) :: S :: paren
  {{ hol ([[call_stack]]) }}

stacks {{ tex \sigma }} :: stacks_ ::=
 {{ com stacks in execution state }}
| ( curr_stack_frame , call_stack ) :: :: tup

state {{ tex s}} :: state_ ::=
 {{ com execution state }}
| ( stacks , status ) :: :: tup


%%%%%%%%%%%%%%%%%%%%%%%%
% Expression semantics %
%%%%%%%%%%%%%%%%%%%%%%%%

terminals :: terminals_ ::=
%Statement reduction
| -> :: :: rightarrow {{ tex \rightarrow }}
%Expression reduction
| ~> :: :: rightsquigarrow {{ tex \rightsquigarrow }}
%Parser state reduction
| --> :: :: longrightarrow {{ tex \longrightarrow }}

formula :: formula_ ::=
{{ com formulas }}
| judgement :: :: judgement
  {{ com judgement }}
%Expressions
| ! b = b' :: M :: neg_bool
  {{ hol (~[[b]] = [[b']]) }}
| ~ nw = nw' :: M :: compl
  %TODO
  {{ hol (~ [[nw]] = [[nw']]) }}
| - nw = nw' :: M :: neg_signed
  %TODO
  {{ hol (~ [[nw]] = [[nw']]) }}
| + nw = nw' :: M :: un_plus
  %TODO: Read specification...
  {{ hol ([[nw]] = [[nw']]) }}
| nw * nw' = nw'' :: M :: mul
  {{ hol (word_mul [[nw]] [[nw']] = [[nw'']]) }}
| nw / nw' = nw'' :: M :: div
  {{ hol (word_div [[nw]] [[nw']] = [[nw'']]) }}
| nw mod nw' = nw'' :: M :: mod
  {{ hol (word_mod [[nw]] [[nw']] = [[nw'']]) }}
| nw + nw' = nw'' :: M :: add
  {{ hol (word_add [[nw]] [[nw']] = [[nw'']]) }}
| nw - nw' = nw'' :: M :: sub
  {{ hol (word_sub [[nw]] [[nw']] = [[nw'']]) }}
%TODO: EQ for v?
| nw EQ nw' = b :: M :: eq_word
  {{ hol ([[nw]] = [[nw']] <=> [[b]]) }}
| b EQ b' = b'' :: M :: eq_bool
  {{ hol ([[b]] = [[b']] <=> [[b'']]) }}
| nw SHL nw' = nw'' :: M :: shl
  {{ hol (word_lsl_bv [[nw]] [[nw']] = [[nw'']]) }}
  %TODO: Double-check
| nw SHR nw' = nw'' :: M :: shr
  {{ hol (word_asr_bv [[nw]] [[nw']] = [[nw'']]) }}
  %TODO: Double-check
| nw LE nw' = b :: M :: le
  {{ hol ([[nw]] <= [[nw']] <=> [[b]]) }}
| nw GE nw' = b :: M :: ge
  {{ hol ([[nw]] >= [[nw']] <=> [[b]]) }}
| nw < nw' = b :: M :: lt
  {{ hol ([[nw]] < [[nw']] <=> [[b]]) }}
| nw > nw' = b :: M :: gt
  {{ hol ([[nw]] > [[nw']] <=> [[b]]) }}
| nw NE nw' = b :: M :: neq_word
  {{ hol ([[nw]] <> [[nw']] <=> [[b]]) }}
| nw & nw' = nw'' :: M :: and_word
  {{ hol (word_and [[nw]] [[nw']] = [[nw'']]) }}
| nw ^ nw' = nw'' :: M :: xor_word
  {{ hol (word_xor [[nw]] [[nw']] = [[nw'']]) }}
  %TODO: LaTeX XOR
| nw '|' nw' = nw'' :: M :: or_word
  {{ hol (word_or [[nw]] [[nw']] = [[nw'']]) }}
| b AND b' = b'' :: M :: and_bool
  {{ hol ([[b]] /\ [[b']] = [[b'']]) }}
| b OR b' = b'' :: M :: or_bool
  {{ hol ([[b]] \/ [[b']] = [[b'']]) }}

%Type-transforming operations
| curr_stack_frame = hd call_stack :: M :: call_stack_hd
  {{ hol ([[curr_stack_frame]] = HD [[call_stack]]) }}
  {{ tex [[curr_stack_frame]] = \mathrm{hd} [[call_stack]] }}
| scope = curr_stack_frame [ i ] :: M :: curr_stack_frame_index
  {{ hol ([[scope]] = EL [[i]] [[curr_stack_frame]]) }}
| ( stmt , x1 , .. , xn ) = func_map ( f ) :: M :: func_lookup
  {{ com function lookup }}
  {{ hol (FLOOKUP [[func_map]] [[f]] = SOME ([[stmt]], [[x1 .. xn]])) }}
| find_index_max ( curr_stack_frame , x ) = i :: M :: find_index_scope_max
  {{ com find max index of variable's scope }}
  %INDEX_FIND finds the first occurrence, starting from head and going backwards in list
  {{ hol (FST (THE (INDEX_FIND 0 (\sf. IS_SOME (FLOOKUP sf [[x]])) [[curr_stack_frame]])) = [[i]]) }}
  {{ tex i = \mathrm{max} \, \{ j . \,\, [[x]]  \in \mathrm{dom} ( [[curr_stack_frame]] [j] )   \} }}
%  {{ tex [[x]] \in \mathrm{dom}([[curr_stack_frame]][ [[i]] ]) \land \forall j . \,\, j > [[i]] \Rightarrow [[x]] \notin \mathrm{dom}([[curr_stack_frame]][j]) }}
| length ( curr_stack_frame ) = i :: M :: find_length
  {{ com find the current stack frame length }}
  {{ tex [[i]] = length ([[curr_stack_frame]])}}
  {{ hol ([[i]] = LENGTH [[curr_stack_frame]]) }}
| v = scope ( x ) :: M :: lookup
  {{ com look-up of variable in scope }}
  {{ hol (FLOOKUP [[scope]] [[x]] = SOME [[v]]) }}
| v = struct { x1 = v1 ; ... ; xn = vn } ( x ) :: M :: access
  {{ com access of field in struct }}
  {{ hol (FIND (\(k, v). k = [[x]]) [[x1 v1 ... xn vn]] = SOME ([[x]], [[v]])) }}
%| v'' = ( v' with f := v ) :: M :: set_field
%  {{ com set field of struct }}
| e = e_list [ i ] :: M :: args_index
  {{ hol ([[e]] = EL [[i]] [[e_list]]) }}
| e = hd e_list :: M :: args_hd
  {{ hol ([[e]] = HD [[e_list]]) }}
  {{ tex [[e]] = \mathrm{hd} \,\, [[e_list]] }}

%Function argument resolution
%TODO: Replace with expression list
%| v_list ++ e_list' = e_list :: M :: func_args_append
%  {{ com pattern match on constant and non-constant function arguments }}
%  {{ hol (([[v_list]] ++ [[e_list']]) = [[e_list]]) }}

%Conditions
%TODO: Remove, with new separate "bool" definition?
| b = true :: M :: is_true
  {{ com condition true }}
  {{ hol ([[b]] = T) }}
  {{ tex [[b]] = \mathrm{True} }}
| b = false :: M :: is_false
  {{ com condition false }}
  {{ hol ([[b]] = F) }}
  {{ tex [[b]] = \mathrm{False} }}
| is_empty ( e_list ) :: M :: args_empty
  {{ com function arguments empty }}
  {{ hol (NULL [[e_list]]) }}
  {{ tex \mathit{e}_1 , .. , \mathit{e}_n = \{ \} }}

%Equalities
| scope = scope' :: M :: scope_eq
  {{ com scope equality }}
  {{ hol ([[scope]] = [[scope']]) }}
| curr_stack_frame = curr_stack_frame' :: M :: curr_stack_frame_eq
  {{ com curr_stack_frame equality }}
  {{ hol ([[curr_stack_frame]] = [[curr_stack_frame']]) }}
| call_stack = call_stack' :: M :: call_stack_eq
  {{ com call_stack equality }}
  {{ hol ([[call_stack]] = [[call_stack']]) }}
%Note the modified equality signs in the below.
%These help to distinguish between e and e_list, as well as provide a single parse
%considering some equalities between expressions are explicitly typeset
| e_list =' e_list' :: M :: args_eq
  {{ com args equality }}
  {{ hol ([[e_list]] = [[e_list']]) }}
  {{ tex [[e_list]] = [[e_list']] }}

%MISC (TODO)
%TODO: Equalities and inequalities on numerals
| i' = i + 1 :: M :: num_inc
  {{ com numeral increment }}
  {{ hol ([[i']] = [[i]] + 1) }}
  {{ tex [[i']] = [[i]] + 1 }}
| i = length ( e_list ) :: M :: num_len
  {{ com length of list }}
  {{ hol ([[i]] = LENGTH [[e_list]]) }}
  {{ tex [[i]] = \mathrm{len} \,\, [[e_list]] }}
| i < length ( e_list ) :: M :: num_in_rg
  {{ com numeral in range }}
  {{ hol ([[i]] < LENGTH [[e_list]]) }}
  {{ tex [[i]] < \mathrm{len}(\mathit{e}) }}
| is_consts ( e_list ) :: M :: args_const
  {{ com function arguments constant }}
  {{ hol (is_consts [[e_list]]) }}
  %TODO: Fix typesetting
  {{ tex \mathrm{is\_consts} \,\, [[e_list]] }}
| stmt = pars_map ( x ) :: M :: pars_lookup
  {{ com parser state map lookup }}
  {{ hol (FLOOKUP [[pars_map]] [[x]] = SOME ([[stmt]])) }}
| x = empty_err_msg :: M :: empty_err_msg
  {{ com empty error message }}
  {{ hol ([[x]] = "ParserStateEnd") }}
  {{ tex [[x]] = \mathrm{ParserStateEnd} }}
| v = lookup_lval ( curr_stack_frame , lval ) :: M :: lookup_lval
  {{ com instantaneous lookup of lvals }}
  {{ hol ([[v]] = lookup_lval [[curr_stack_frame]]  [[lval]]) }}
| v'' = ( struct { x1 = v1 ; ... ; xn = vn } with f := v ) :: M :: struct_fld_upd
  {{ com update of struct field }}
  {{ hol ([[v'']] = v_struct (LUPDATE ([[f]], [[v]]) (THE (INDEX_OF [[f]] (MAP FST [[x1 v1 ... xn vn]]))) [[x1 v1 ... xn vn]])) }}
%  find_index_max ( curr_stack_frame, x ) = i
%    (FST (THE (INDEX_FIND 0 (\sf. IS_SOME (FLOOKUP sf [[x]])) [[curr_stack_frame]])) = [[i]])
%  scope = curr_stack_frame [ i ]
%    ([[scope]] = EL [[i]] [[curr_stack_frame]])
%  v = scope ( x )
%    (FLOOKUP [[scope]] [[x]] = SOME [[v]])
%
%
%    (SOME [[v]] = FLOOKUP (EL (FST (THE (INDEX_FIND 0 (\sf. IS_SOME (FLOOKUP sf [[x]])) [[curr_stack_frame]]))) [[curr_stack_frame]]) [[x]])

%TODO: Review if "is_const" is needed...
embed
{{ hol
val is_const_def = Define `
    ( is_const (e_v _) = T)
/\  ( is_const _ = F)
`;
val is_consts_def = Define `
    (is_consts el = ~(EXISTS (\e. ~(is_const e)) el))
`;
(* Access the field f of a struct (v_struct s) *)
val str_acc_def = Define `
    (str_acc (v_struct s) f = SOME (SND (THE (FIND (\(f', v). f' = f) s))))
/\  (str_acc _ f = NONE)
`;
(*
val get_lval_root_def = Define `
    (get_lval_root (lval_varname x) = x)
/\  (get_lval_root (lval_field lval f) = get_lval_root lval)
`;
val get_lval_fields_rev_def = Define `
    (get_lval_fields_rev (lval_varname x) = [])
/\  (get_lval_fields_rev (lval_field lval f) = f::(get_lval_fields_rev lval))
`;
val get_lval_fields_def = Define `
    (get_lval_fields lval = REVERSE (get_lval_fields_rev lval))
`;
*)
(* Look up the value of a variable x in the current stack frame sf *)
val lookup_def = Define `
    (lookup (sf:scope list) x = THE (FLOOKUP (EL (FST (THE (INDEX_FIND 0 (\sc. IS_SOME (FLOOKUP sc x)) sf))) sf) x)
    )
`;
(* Look up the value of a l-value (variables + fields of struct-valued variables) in
 * the current stack frame sf. *)
val lookup_lval_def = Define `
    (lookup_lval (sf:scope list) (lval_varname x) = (lookup sf x))
/\  (lookup_lval (sf:scope list) (lval_field lval f) = THE (str_acc (lookup_lval sf lval) f))
`;
}}
grammar

defns
  e_sem :: '' ::=
defn
  [ e ] ( stacks , status ) ~> [ e' ] ( stacks' , status' ) :: :: e_red :: e_
  {{ com expression semantics }}
  %TODO Should use different export homs for LaTeX and HOL4 so that LaTeX hides unnecessary status?
  %{{ tex [ [[e]] ] [[stacks]] \rightsquigarrow [ [[e']] ] [[stacks']] }}
by

%%%%%%%%%%%%%%%%%
%Variable look-up

  find_index_max ( curr_stack_frame, x ) = i
  scope = curr_stack_frame [ i ]
  v = scope ( x )
  ----------------------------------- :: lookup
  [x] ( ( curr_stack_frame, call_stack ) , Running ) ~> [v] ( ( curr_stack_frame, call_stack ) , Running )

%%%%%%%%%%%%%%
%Function call + exec (in expression)

  %Resolving arguments to function call - assigning arguments to new stack frame
  ( stmt , x1 , .. , xn ) = func_map ( f )
  scope' = emptyscope ++ [ x1 |->  v1 , .. , xn |-> vn ]
  G scope = curr_stack_frame[0]
  curr_stack_frame' = scope' :: [G scope]
  call_stack' = tl curr_stack_frame :: call_stack
  ----------------------------------- :: func_call_newframe
  [call f ( v1 , .. , vn )] ( ( curr_stack_frame , call_stack ) , Running ) ~> [ exec stmt ] ( ( curr_stack_frame' , call_stack' ) , Running )

  [stmt] ( stacks , Running ) -> [stmt'] ( stacks' , Running )
  ----------------------------------- :: func_exec
  [exec stmt] ( stacks , Running ) ~> [exec stmt'] ( stacks' , Running )

%TODO: Note that this is a simplification of the return mechanism
  ----------------------------------- :: func_ret
  [exec empty_stmt] ( stacks , Return v ) ~> [v] ( stacks' , Running )

%%%%%%%%%%%%%%%%%%%%
%Struct field access

  v = struct { x1 = v1 ; ... ; xn = vn } ( x )
  ----------------------------------- :: acc
  [ struct { x1 = v1 ; ... ; xn = vn } . x] ( stacks , Running ) ~> [v] ( stacks , Running )

%%%%%%%%%%%%%
%"Reduction of argument" rules

%Resolving arguments to function call - reduction
  %TODO: force e_list'' to be non-empty?
  e_list' ++ e_list'' =' e1 , .. , en
  is_consts ( e_list' )
  e = hd e_list''
  [ e ] ( stacks , Running ) ~> [ e' ] ( stacks' , Running )
  %TODO: length plus 1 if indexing from 1
  i = length ( e_list' )
  e'1 , .. , e'm =' update ( e' , i , ( e1 , .. , en ) )
  ----------------------------------- :: func_call_args
  [call f ( e1 , .. , en )] ( stacks , Running ) ~> [call f ( e'1 , .. , e'm )] ( stacks , Running )

%Structs
%(looks nicer with left-to-right, since we avoid writing out an explicit struct)
  [e'] ( stacks , Running ) ~> [e''] ( stacks' , Running )
  ----------------------------------- :: acc_arg2
  [e . e'] ( stacks , Running ) ~> [e . e''] ( stacks' , Running )

  [e] ( stacks , Running ) ~> [e'] ( stacks' , Running )
  ----------------------------------- :: acc_arg1
  [e . x] ( stacks , Running ) ~> [e' . x] ( stacks' , Running )

%Unary operations
  [e] ( stacks , Running ) ~> [e'] ( stacks' , Running )
  ----------------------------------- :: unop_arg
  [unop e] ( stacks , Running ) ~> [unop e'] ( stacks' , Running )

%Binary operations
  [e] ( stacks , Running ) ~> [e''] ( stacks' , Running )
  ----------------------------------- :: binop_arg1
  [e binop e'] ( stacks , Running ) ~> [e'' binop e'] ( stacks' , Running )

  [e'] ( stacks , Running ) ~> [e''] ( stacks' , Running )
  ----------------------------------- :: binop_arg2
  [v binop e'] ( stacks , Running ) ~> [e binop e''] ( stacks' , Running )


%%%%%%%%%%%%%%%%%%%
%Unary expressions%
%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%
%Boolean negation

  ! b = b'
  ----------------------------------- :: neg_bool
  [! b] ( stacks , Running ) ~> [b'] ( stacks , Running )

%%%%%%%%%%%%%%%%%%%
%Bitwise complement

  ~ nw = nw'
  ----------------------------------- :: compl
  [~ nw] ( stacks , Running ) ~> [nw'] ( stacks , Running )

%%%%%%%%%%%%%%%%
%Signed negation

  - nw = nw'
  ----------------------------------- :: neg_signed
  [- nw] ( stacks , Running ) ~> [nw'] ( stacks , Running )

%%%%%%%%%%%
%Unary plus

  + nw = nw'
  ----------------------------------- :: un_plus
  [+ nw] ( stacks , Running ) ~> [nw'] ( stacks , Running )


%%%%%%%%%%%%%%%%%%%%
%Binary expressions%
%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%
%Multiplication

  nw * nw' = nw''
  ----------------------------------- :: mul
  [nw * nw'] ( stacks , Running ) ~> [nw''] ( stacks , Running )

%%%%%%%%%%%%%%%
%Division

  nw / nw' = nw''
  ----------------------------------- :: div
  [nw / nw'] ( stacks , Running ) ~> [nw''] ( stacks , Running )

%%%%%%%%%%%%%%%
%Modulo

  nw mod nw' = nw''
  ----------------------------------- :: mod
  [nw mod nw'] ( stacks , Running ) ~> [nw''] ( stacks , Running )

%%%%%%%%%%%%
%Addition

  nw + nw' = nw''
  ----------------------------------- :: add
  [nw + nw'] ( stacks , Running ) ~> [nw''] ( stacks , Running )

%%%%%%%%%%%%
%Subtraction

  nw - nw' = nw''
  ----------------------------------- :: sub
  [nw - nw'] ( stacks , Running ) ~> [nw''] ( stacks , Running )

%%%%%%%%%%%%
%Left shift

  nw SHL nw' = nw''
  ----------------------------------- :: shl
  [nw SHL nw'] ( stacks , Running ) ~> [nw''] ( stacks , Running )

%%%%%%%%%%%%
%Right shift

  nw SHR nw' = nw''
  ----------------------------------- :: shr
  [nw SHR nw'] ( stacks , Running ) ~> [nw''] ( stacks , Running )

%%%%%%%%%%%%%%%%%%%
%Less than or equal

  nw LE nw' = b
  ----------------------------------- :: le
  [nw LE nw'] ( stacks , Running ) ~> [b] ( stacks , Running )

%%%%%%%%%%%%%%%%%%%%%%
%Greater than or equal

  nw GE nw' = b
  ----------------------------------- :: ge
  [nw GE nw'] ( stacks , Running ) ~> [b] ( stacks , Running )

%%%%%%%%%%
%Less than

  nw < nw' = b
  ----------------------------------- :: lt
  [nw < nw'] ( stacks , Running ) ~> [b] ( stacks , Running )

%%%%%%%%%%%%%
%Greater than

  nw > nw' = b
  ----------------------------------- :: gt
  [nw > nw'] ( stacks , Running ) ~> [b] ( stacks , Running )

%%%%%%%%%%%%%
%Not equal

  nw NE nw' = b
  ----------------------------------- :: neq
  [nw NE nw'] ( stacks , Running ) ~> [b] ( stacks , Running )

%%%%%%%%%%%%%
%Equal

  nw EQ nw' = b
  ----------------------------------- :: eq
  [nw EQ nw'] ( stacks , Running ) ~> [b] ( stacks , Running )

%%%%%%%%%%%%%
%Bitwise and

  nw & nw' = nw''
  ----------------------------------- :: and
  [nw & nw'] ( stacks , Running ) ~> [nw''] ( stacks , Running )

%%%%%%%%%%%%%
%Bitwise xor

  nw ^ nw' = nw''
  ----------------------------------- :: xor
  [nw ^ nw'] ( stacks , Running ) ~> [nw''] ( stacks , Running )

%%%%%%%%%%%%%
%Bitwise or

  nw | nw' = nw''
  ----------------------------------- :: or
  [nw | nw'] ( stacks , Running ) ~> [nw''] ( stacks , Running )

%%%%%%%%%%%%%
%Binary and

  b AND b' = b''
  ----------------------------------- :: bin_and
  [b AND b'] ( stacks , Running ) ~> [b''] ( stacks , Running )

%%%%%%%%%%%%%
%Binary or

  b OR b' = b''
  ----------------------------------- :: bin_or
  [b OR b'] ( stacks , Running ) ~> [b''] ( stacks , Running )


%%%%%%%%%%%%%%%%%%%%%%%%%
% Declaration semantics %
%%%%%%%%%%%%%%%%%%%%%%%%%

%defns
%  decl_sem :: '' ::=
%defn
%  [ decl ] state -> [ decl' ] state' :: :: decl_red :: decl_
%  {{ com declaration semantics }}
%by

  %Declare a variable and assign a value - reduction step
%  [e] ( stacks , Running ) ~> [e'] ( stacks' , Running )
%  ----------------------------------- :: decl_e
%  [declare x e] ( stacks , Running ) -> [declare x e'] ( stacks' , Running )

%  scope :: curr_stack_frame' = curr_stack_frame
%  scope' = scope + [ x |-> n ]
%  curr_stack_frame'' = scope' :: curr_stack_frame'
%  ----------------------------------- :: decl_const
%  [declare x n] ( ( curr_stack_frame , call_stack ) , Running ) -> [empty_decl] ( ( curr_stack_frame'' , call_stack ) , Running )

 % [decl1] ( stacks , Running ) -> [decl1'] ( stacks' , Running )
 % ----------------------------------- :: seq1
 % [decl1 ; decl2] ( stacks , Running ) -> [decl1' ; decl2] ( stacks' , Running )

 % ----------------------------------- :: seq2
 % [empty_decl ; decl] ( stacks , Running ) -> [decl] ( stacks , Running )


%%%%%%%%%%%%%%%%%%%%%%%
% Statement semantics %
%%%%%%%%%%%%%%%%%%%%%%%

%TODO: Block
%TODO: Exit
%TODO: Switch

defns
  stmt_sem :: '' ::=
defn
  [ stmt ] state -> [ stmt' ] state' :: :: stmt_red :: stmt_
  {{ com statement semantics }}
by

%%%%%%%%%%%%%%
%Return

  G scope = curr_stack_frame [ 0 ]
  curr_stack_frame' :: call_stack' = call_stack
  curr_stack_frame'' = ( curr_stack_frame' ) ++ ( [ G scope ] )
  ----------------------------------- :: ret
  [return v] ( ( curr_stack_frame , call_stack ) , Running ) -> [empty_stmt] ( ( curr_stack_frame'' , call_stack' ) , Return v )

%%%%%%%%%%%%%%
%Assignment

  %Assign a constant to a variable
  find_index_max ( curr_stack_frame , x ) = i
  scope = curr_stack_frame [ i ]
  curr_stack_frame' = update ( scope + [ x |-> v ] , i , curr_stack_frame )
  ----------------------------------- :: ass_v
  [assign x v] ( ( curr_stack_frame , call_stack ) , Running ) -> [empty_stmt] ( ( curr_stack_frame' , call_stack ) , Running )

  %TODO: Assign to a struct field
  struct { x1 = v1 ; ... ; xn = vn } = lookup_lval ( curr_stack_frame , lval )
  v'' = ( struct { x1 = v1 ; ... ; xn = vn } with f := v )
  ----------------------------------- :: ass_str
  [assign ( lval . f ) v] ( ( curr_stack_frame , call_stack ) , Running ) -> [assign lval  v''] ( ( curr_stack_frame , call_stack ) , Running )

%%%%%%%%%%%%%%
%Sequence

  [stmt1] ( stacks , Running ) -> [stmt1'] ( stacks' , Running )
  ----------------------------------- :: seq1
  [stmt1 ; stmt2] ( stacks , Running ) -> [stmt1' ; stmt2] ( stacks' , Running )

  ----------------------------------- :: seq2
  [empty_stmt ; stmt] ( stacks , Running ) -> [stmt] ( stacks , Running )

  [stmt1] ( stacks , Running ) -> [stmt1'] ( stacks' , Return v )
  ----------------------------------- :: seq3
  [stmt1 ; stmt2] ( stacks , Running ) -> [ empty_stmt ] ( stacks' , Return v )

%%%%%%%%%%%%%%
%Conditional

  ----------------------------------- :: cond2
  [if true then stmt1 else stmt2] ( stacks , Running ) -> [stmt1] ( stacks , Running )

  ----------------------------------- :: cond3
  [if false then stmt1 else stmt2] ( stacks , Running ) -> [stmt2] ( stacks , Running )

%%%%%%%%%%%%%%
%declaration

  length ( curr_stack_frame ) = i
  scope = curr_stack_frame [ i ]
  curr_stack_frame' = update ( scope + [ x |-> uninit ] , i , curr_stack_frame )
  ----------------------------------- :: decl
  [decl x t] ( ( curr_stack_frame , call_stack ) , Running ) -> [empty_stmt] ( ( curr_stack_frame' , call_stack ) , Running )


%%%%%%%%%%%%%%
%Block

  curr_stack_frame' = emptyscope :: curr_stack_frame
  ----------------------------------- :: block_enter
  [begin stmt end] ( ( curr_stack_frame , call_stack ) , Running ) -> [begin' stmt end'] ( ( curr_stack_frame' , call_stack ) , Running )

  [stmt] ( stacks , Running ) -> [stmt'] ( stacks' , Running )
  ----------------------------------- :: block_exec
  [begin' stmt end'] ( stacks , Running ) -> [begin' stmt' end'] ( stacks' , Running )

  curr_stack_frame' = tl curr_stack_frame
  ----------------------------------- :: block_exit
  [begin' empty_stmt end'] ( ( curr_stack_frame , call_stack ) , Running ) -> [empty_stmt] ( ( curr_stack_frame' , call_stack ) , Running )

%%%%%%%%%%%%%%
%Verify

%Case predicate holds
  ------------------------------------------------- :: verify_3
  [verify true ( errmsg x )]( stacks , Running ) -> [empty_stmt]( stacks' , Running )

%Case predicate does not hold
  ------------------------------------------------- :: verify_4
  [verify false ( errmsg x )]( stacks , Running ) -> [empty_stmt]( stacks' , Reject x )

%%%%%%%%%%%%%%
%Transition

  ------------------------------------------------- :: transition
  [transition pars_next]( stacks , Running ) -> [empty_stmt]( stacks , pars_next )

%Transition to named state
%NOTE: This assumes transition is last statement
%TODO: Requires statement to be found in pars_map
%  ------------------------------------------------- :: transition_1
%  [transition x]( stacks , Running ) -> [empty_stmt]( stacks , Trans x )

%Transition to accept
%NOTE: This assumes transition is last statement
%  ------------------------------------------------- :: transition_2
%  [transition accept]( stacks , Running ) -> [empty_stmt]( stacks , Accept )

%Transition to reject
%NOTE: This assumes transition is last statement
%  ------------------------------------------------- :: transition_3
%  [transition reject x]( stacks , Running ) -> [empty_stmt]( stacks , Reject x )


%%%%%%%%%%%%%%
%Exit

  %TODO: exit semantics might require to have a specific "function-in-progress" statement
  %      in order to know what to reduce to nothing.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Reduction of expression rules %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%Reduction step of return expression
  [e] ( stacks , Running ) ~> [e'] ( stacks' , Running )
  ----------------------------------- :: ret_e
  [return e] ( stacks , Running ) -> [return e'] ( stacks' , Running )

%Reduction step of assign expression
  [e] ( stacks , Running ) ~> [e'] ( stacks' , Running )
  ----------------------------------- :: ass_e
  [assign x e] ( stacks , Running ) -> [assign x e'] ( stacks' , Running )

%Reduction step of condition
  [e] ( stacks , Running ) ~> [e'] ( stacks' , Running )
  ----------------------------------- :: cond_e
  [if e then stmt1 else stmt2] ( stacks , Running ) -> [if e' then stmt1 else stmt2] ( stacks' , Running )

%Reduction step of verify predicate
  [e] ( stacks , Running ) ~> [e''] ( stacks' , Running )
  ------------------------------------------------- :: verify_e1
  [verify e e' ]( stacks , Running ) -> [verify e'' e']( stacks' , Running )

%Reduction step of error message
  [e] ( stacks , Running ) ~> [e'] ( stacks' , Running )
  ------------------------------------------------- :: verify_e2
  [verify b e]( stacks , Running ) -> [verify b e']( stacks' , Running )


%%%%%%%%%%%%%%%%%%%%
% Parser semantics %
%%%%%%%%%%%%%%%%%%%%
%This isolates the unstructured parser semantics into a set of rules defined in terms
%of the regular statement semantics.

defns
  pars_sem :: '' ::=
defn
  [ stmt ] state --> [ stmt' ] state' :: :: pars_red :: pars_
  {{ com parser semantics }}
by

  [stmt]( stacks , Running ) -> [stmt']( stacks' , Running )
  ------------------------------------------------- :: stmt
  [stmt]( stacks , Running ) --> [stmt']( stacks' , Running )

  [stmt]( stacks , Running ) -> [stmt']( stacks' , Trans x )
  stmt'' = pars_map ( x )
  ------------------------------------------------- :: state
  [stmt]( stacks , Running ) --> [stmt'']( stacks' , Running )


defns
  pars_t_sem :: '' ::=
defn
  [ stmt ] state --> state' :: :: pars_t_red :: pars_t_
  {{ com parser semantics, final step }}
by

  [stmt]( stacks , Running ) -> [stmt']( stacks , pars_fin )
  ------------------------------------------------- :: fin
  [stmt]( stacks , Running ) --> ( stacks , pars_fin )

%If the end of some parser state is reached without status change, we reject
  [stmt]( stacks , Running ) -> [empty_stmt]( stacks' , Running )
  x = empty_err_msg
  ------------------------------------------------- :: empty
  [stmt]( stacks , Running ) --> ( stacks' , Reject x )
embed
{{ hol
open bitstringTheory;
open wordsTheory;
}}

%%%%%%%%%%%%%%%%%
% P4 base types %
%%%%%%%%%%%%%%%%%

%x denotes variable name, f denotes field name or function name
%msg denotes error message
metavar x, f, msg, a, table_name ::=
      {{ lex alphanum }}
      {{ hol string }}
      {{ tex [[x]] }}
      {{ com string }}
%TODO Numeral or alphanum?
metavar b ::=
      {{ lex numeral }}
      {{ hol bool }}
      {{ tex [[b]] }}
      {{ com boolean }}
metavar bl ::=
      {{ lex numeral }}
      {{ hol bool list }}
      {{ tex [[bl]] }}
      {{ com bit-string }}

%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Auxiliary metavariables %
%%%%%%%%%%%%%%%%%%%%%%%%%%%

metavar i ::=
      {{ lex numeral }}
      {{ hol num }}
      {{ tex [[i]] }}
      {{ com natural number }}
indexvar m, n, o ::=
  {{ lex numeral }}
  {{ coq nat }}
  {{ hol num }}
  {{ com indices }}
grammar

%%%%%%%%%%%%%%%%%%%%%
% Expression syntax %
%%%%%%%%%%%%%%%%%%%%%

unop {{ tex \ominus }}:: unop_ ::=
| ! :: :: neg
  {{ com negation }}
  {{ tex ! }}
| ~ :: :: compl
  {{ com bitwise complement }}
  {{ tex \neg }}
| - :: :: neg_signed
  {{ com signed negation }}
| + :: :: un_plus
  %Defined as no-op for all values in P4 spec
  {{ com unary plus }}

%Binary operations
%Split these up into operations (bv # bv -> bv) and predicates (bv # bv -> bool)?
%TODO: Add saturating addition
%TODO: Add saturating subtraction
binop {{ tex \oplus }} :: binop_ ::=
| * :: :: mul
  {{ com multiplication }}
  {{ tex \times }}
| / :: :: div
  {{ com division }}
| mod :: :: mod
  %Denoted by % in P4 spec
  {{ com modulo }}
  {{ tex \bmod }}
| + :: :: add
  {{ com addition }}
| - :: :: sub
  {{ com subtraction }}
| SHL :: :: shl
  {{ com logical left-shift }}
  {{ tex \ll }}
| SHR :: :: shr
  {{ com logical right-shift }}
  {{ tex \gg }}
| LE :: :: le
  {{ com less or equal }}
  {{ tex \leq }}
| GE :: :: ge
  {{ com greater or equal }}
  {{ tex \geq }}
| < :: :: lt
  {{ com less }}
  {{ tex < }}
| > :: :: gt
  {{ com greater }}
  {{ tex > }}
| NE :: :: neq
  {{ com not equal }}
  {{ tex \neq }}
| EQ :: :: eq
  {{ com equal }}
  {{ tex = }}
| & :: :: and
  {{ com bitwise and }}
| ^ :: :: xor
  {{ com bitwise xor }}
  {{ tex \underline{\vee} }}
| '|' :: :: or
  {{ com bitwise or }}
  {{ tex \mid }}
| AND :: :: bin_and
  {{ com binary and }}
  {{ tex \land }}
| OR :: :: bin_or
  {{ com binary or }}
  {{ tex \lor }}

boolv :: boolv_ ::=
{{ hol bool }}
{{ com boolean }}
| true :: M :: true
  {{ hol T }}
| false :: M :: false
  {{ hol F }}
| b :: M :: free
  {{ hol [[b]] }}

bitv :: bitv_ ::=
{{ hol (bl # num) }}
{{ com bit-string }}
| bl n :: M :: bl
  {{ hol ([[bl]], [[n]]) }}

bt {{ tex bt }} :: bt_ ::=
{{ com base types }}
| bool_t :: :: bool
  {{ tex { \mathrm{bool}_{ \mathrm{t} } } }}
| bit_t :: :: bit
  {{ tex { \mathrm{bit}_{ \mathrm{t} } } }}

t {{ tex t }} :: t_ ::=
{{ com types }}
| bt :: :: base
| struct_t t1 , ... , tn :: :: struct
  {{ tex { \mathrm{struct}_{ \mathrm{t} }\,\, t_1 , \ldots , t_n } }}
| header_t t1 , ... , tn :: :: header
  {{ tex { \mathrm{header}_{ \mathrm{t} }\,\, t_1 , \ldots , t_n } }}

%TODO: Add string literal separate from variable name?
%TODO: Add identifiers
%TODO: Add enums
v :: v_ ::=
{{ com constant }}
| boolv :: :: bool
  {{ com boolean value }}
%bitv currently represents both signed and unsigned bit-strings
| bitv :: :: bit
  {{ com bit-string }}
| struct { x1 = v1 ; ... ; xn = vn } :: :: struct
  {{ com struct }} %TODO: Ott User Guide 12.2  List comprehension forms
| header boolv { x1 = v1 ; ... ; xn = vn } :: :: header
% A header is like a struct, but with a validity bit.
% Headers also have different well-formedness conditions (for example, headers cannot be nested).
%TODO: We must have the following header methods:
%      isValid()
%      setValid()
%      setInvalid()
%      Should these be modeled as statements, or should they
%      be pre-set in the function map?
  {{ com header }}
%%TODO: An extern should contain an internally visible list of mappings between variable names and constants,
%%      and a map from function names to their bodies and arguments
%% See https://github.com/p4lang/p4c/blob/main/p4include/core.p4 , e.g. packet_in definition
| errmsg x :: :: err
  {{ com error message }}
%TODO: Represent uninitialised variables? Default values?
%See https://p4lang.github.io/p4-spec/docs/P4-16-v1.2.2.html#sec-uninitialized-values-and-writing-invalid-headers
| uninit :: :: uninit
  {{ com uninitialized value }}
  {{ tex ? }}
  {{ hol (ARB) }}
| bot :: :: bot
  {{ com no value }}

%TODO: Add array element
%TODO: Add bitslice
lval :: lval_ ::=
| x :: :: varname
  {{ com variable name }}
| null :: :: null
  {{ com null variable }} 
| lval . f :: :: field
  {{ com field access }}
| ( lval ) :: X :: paren
  {{ hol ([[lval]]) }}

%TODO: Add casts
%TODO: Add lists
%TODO: Add tuples
%TODO: Add conditional operator
e :: e_ ::=
{{ com expression }}
| v :: :: v
 {{com constant value}}
| x :: :: var
  {{ com variable or parser state name }}
| { e1 , .. , en } :: :: list
  {{ com expression list }}
| e . e' :: :: acc
  {{ com field access }}
| unop e :: :: unop
  {{ com unary operation }}
  {{ tex [[unop]] [[e]] }}
| e1 binop e2 :: :: binop
  {{ com binary operation }}
  {{ tex [[e1]] [[binop]] [[e2]] }}
| e1 ++ e2 :: :: concat
  {{ com concatenation of bit-strings }}
| e1 [ e2 : e3 ] :: :: slice
  {{ com bit-slice }}
| call f ( e1 , .. , en ) :: :: func_call
  {{ com function call }}
| exec stmt :: I :: func_exec
  {{ com function execution }}
| select e { v1 : x1 ; ... ; vn : xn } x :: :: select
  % TODO: x is the default value of select expression, which should be optional
  {{ com select }}
| ( e ) :: X :: paren
  {{ hol ([[e]]) }}

%TODO: Trying to make a new definition for expression lists (mainly for function
%      arguments) proved problematic.
%      If all e_list productions are meta, then you get e_list as a type abbreviation of "e list",
%      which is either undefined at the point where the abbreviation is made, or
%      e_list is unknown when defining e (and specifically function call, which would use e_list).
%      In both situations, mutually recursive definitions are not possible.
%
%      If nothing is meta and e_list is not exported to a type abbreviation, you risk the function call semantics not understanding the "e_list" and "e list" correspondence. However, this seems to work currently.
e_list :: e_list_ ::=
{{ com list of expressions }}
{{ hol (e list) }}
| empty_el :: M :: empty
  {{ com empty expression list }}
  {{ hol ([]:e list) }}
| e1 , .. , en :: M :: exps
  {{ com list of expressions }}
  {{ hol ([[e1 .. en]]) }}
| [ e1 , .. , en ] :: M :: exps2
  {{ com bracketed list of expressions }}
  {{ hol ([[e1 .. en]]) }}
| e_list ++ e_list' :: M :: append
  {{ com append two expression lists }}
  {{ hol ([[e_list]] ++ [[e_list']]) }}
| update ( e , i , e_list ) :: M :: update
  {{ com update entry of expression list }}
  {{ hol (LUPDATE [[e]] [[i]] [[e_list]]) }}
  {{ tex ([[i]] \mapsto  [[e]]) [[e_list]] }}
| ( e_list ) :: S :: paren
  {{ hol ([[e_list]]) }}



%%%%%%%%%%%%%%
% Statements %
%%%%%%%%%%%%%%

%decl :: decl_ ::=
%{{ com declaration }}
%| empty_decl :: :: empty
%  {{ com empty declaration }}
%  {{ tex \emptyset_{ \mathrm{decl} } }}
%| declare x e :: :: stmt
%  {{ com declaration }}
%  {{ tex [[x]] \mathrel{\mathop:}:= [[e]] }}
%| decl1 ; decl2 :: :: seq
%  {{ com sequence }}

pars_fin {{ tex p_{ \mathrm{fin} } }} :: pars_fin ::=
{{ com final parser states }}
| Accept :: :: accept
  {{ com accepted state }}
| Reject :: :: reject
  {{ com rejected state }}

match_kind {{ tex \mathit{match\_kind} }} :: match_kind_ ::=
{{ com matching kinds }}
| exact :: :: exact
  {{ tex exact }}
| ternary :: :: ternary
  {{ tex ternary }}
| lpm :: :: lpm
  {{ tex lpm }}


pars_next {{ tex p }} :: pars_next_ ::=
{{ com parser next state }}
| Trans x :: :: trans
  {{ com transition to named state }}
| pars_fin :: :: pars_fin
  {{ com final state }}

%TODO: Add switch statement
stmt :: stmt_ ::=
{{ com statement }}
| empty_stmt :: :: empty
  {{ com empty statement }}
  {{ tex \emptyset_{ \mathrm{stmt} } }}
| assign lval e :: :: ass
  {{ com assignment }}
  {{ tex [[lval]] \mathrel{\mathop:}= [[e]] }}
| if e then stmt1 else stmt2 :: :: cond
  {{ com conditional }}
| decl x t :: :: declare
  %TODO: This should have a type name instead of a type t, which is then looked up in the type environment.
  {{ com declaration }}
| begin stmt end :: :: block 
  {{ com block }}
  {{ tex \{ [[stmt]] \} }}
| begin' stmt end' :: I :: block_ip
  {{ com block in progress }}
  {{ tex [ [[stmt]] ] }}
| return e :: :: ret
  {{ com return }}
| stmt1 ; stmt2 :: :: seq
  {{ com sequence }}
| verify e e' :: :: verify
  %e is predicate, e' is error message
  {{ com verify }}
| transition e :: :: trans
  %e should evaluate to a parser state name
  {{ com transition }}
  {{ tex \mathbf{transition}\, [[e]] }}
| apply table_name e :: :: app
  %table_name is the table name that should be applied
  {{ com apply }}
  {{ tex \mathbf{apply} \, [[table_name]] \, [[e]] }}

d {{ tex d }} :: d_ ::=
{{ com parameter direction }}
| in :: :: in
  {{ tex \downarrow }}
| out :: :: out
  {{ tex \uparrow }}
| inout :: :: inout
  {{ tex \updownarrow }}
| none :: :: none
  {{ tex \circ }}

%Fence between d and d_list
embed
{{ hol

}}
grammar 

d_list :: d_list_ ::=
{{ com list of directions }}
{{ hol (d list) }}
| empty_el :: M :: empty
  {{ com empty direction list }}
  {{ hol ([]:d list) }}
| [ d1 , .. , dn ] :: M :: ds
  {{ com list of directions }}
  {{ hol ([[d1 .. dn]]) }}
| ( d_list ) :: S :: paren
  {{ hol ([[d_list]]) }}
| d_list ++ d_list' :: M :: append
  {{ com append two e_lists }}
  {{ hol ([[d_list]] ++ [[d_list']]) }}

func_map {{ tex F }} :: func_map_ ::=
{{ com function map  }}
{{ hol (string |-> (stmt # (string # d) list)) }}
| empty :: M :: empty
  {{ com empty function map }}
  {{ hol FEMPTY }}
| func_map + [ x |-> stmt ] :: M :: update
  {{ com update variable mapping }}
  {{ hol (FUPDATE [[func_map]] ([[x]], [[stmt]])) }}

% TODO: Could be just a type abbreviation?
ctrl {{ tex { \mathrm{ctrl} } }} :: ctrl_ ::=
{{ com control plane }}
{{ hol ((string # v # match_kind) |-> (string # e_list)) }}
| empty :: M :: empty
  {{ com empty table map }}
  {{ hol FEMPTY }}

% TODO: Could be just a type abbreviation?
t_map {{ tex {Tb} }} :: t_map_ ::=
{{ com table map  }}
{{ hol (string |-> (e # match_kind)) }}
| empty :: M :: empty
  {{ com empty table map }}
  {{ hol FEMPTY }}

% TODO: Could be just a type abbreviation?
pars_map {{ tex P }} :: pars_map_ ::=
{{ com parser state map  }}
{{ hol (string |-> stmt) }}
| empty :: M :: empty
  {{ com empty parser state map }}
  {{ hol FEMPTY }}

% TODO: Could be just a type abbreviation?
type_map {{ tex T }} :: type_map_ ::=
{{ com type environment  }}
{{ hol (string |-> ((string # t) list)) }}
| empty :: M :: empty
  {{ com empty type environment }}
  {{ hol FEMPTY }}

%%%%%%%%%%%%%%%%%%%
% Execution state %
%%%%%%%%%%%%%%%%%%%
%Note that this is not part of the P4 specification, but made up for verification purposes.

%Execution status
status {{ tex t }}:: status_ ::=
{{ com execution status }}
| Running :: I :: running
  {{ tex { \mathbf{R} } }}
| Return v :: I :: return
  {{ tex { \mathbf{Ret} \,\, [[v]]} }}
| pars_next :: I :: pars_next
| TypeError :: I :: type_error
  {{ tex { \bot } }}

scope {{ tex \gamma }} :: scope_ ::=
{{ hol (string |-> (v # string option)) }}
{{ com frame/variable environment of current scope }}
| emptyscope :: M :: empty
  {{ com empty stack frame }}
  {{ hol FEMPTY }}
  {{ tex {\gamma}_{ \emptyset } }}
| scope + [ x |-> v ] :: M :: update
  {{ com update variable mapping }}
  {{ hol (FUPDATE [[scope]] ([[x]], [[v]])) }}
  {{ tex ([[x]] \mapsto  [[v]]) [[scope]] }}
| scope ++ [ x1 |-> v1 , .. , xn |-> vn ] :: M :: update_list
  {{ com update variable mapping }}
  {{ hol (FUPDATE_LIST [[scope]] [[x1 v1 .. xn vn]]) }}
  %TODO: The below is a hack since LaTeX cannot interpret dot form...
  {{ tex \forall i \leq n. \,\, (x_i \mapsto  \mathit{v}_i) \,\, [[scope]] }}
| ( scope ) :: S :: paren
  {{ hol ([[scope]]) }}
| G scope :: M :: global
  {{ com global scope }}
  {{ tex {[[scope]]}_G }}
  {{ hol [[scope]] }}

%Fence so that ott does not re-order curr_stack_frame
embed
{{ hol

}}
grammar

curr_stack_frame {{ tex \varepsilon }} :: curr_stack_frame_ ::=
{{ hol (scope list) }}
{{ com current stack frame - stack of block scopes }}
| emptycsf :: M :: empty
  {{ hol ([]:scope list) }}
  {{ tex {\emptyset}_{\varepsilon} }}
| [ scope1 , .. , scopen ] :: M :: list
  {{ hol ([[scope1 .. scopen]]) }}
| tl curr_stack_frame :: M :: tl
  {{ hol (TL [[curr_stack_frame]]) }}
  {{ tex \mathrm{tl} ([[curr_stack_frame]]) }}
| scope '::' curr_stack_frame' :: M :: cons
  {{ hol ([[scope]] :: [[curr_stack_frame']]) }}
  {{ tex [[scope]] :: [[curr_stack_frame']] }}
| curr_stack_frame ++ curr_stack_frame' :: M :: append
  {{ hol ([[curr_stack_frame]] ++ [[curr_stack_frame']]) }}
  {{ tex [[curr_stack_frame]] \mathrel{\mathop+}+ [[curr_stack_frame']] }}
| update ( scope , i , curr_stack_frame ) :: M :: update_scope
  {{ com update a scope in the stack frame }}
  {{ hol (LUPDATE [[scope]] [[i]] [[curr_stack_frame]]) }}
  {{ tex ([[i]] \mapsto [[scope]]) [[curr_stack_frame]] }}
| assign ( curr_stack_frame , v , x ) :: M :: assign
  {{ com assign to a variable in the stack frame }}
  {{ hol (assign [[curr_stack_frame]] [[v]] [[x]]) }}
  {{ tex [[curr_stack_frame]] [ [[x]] \longmapsto [[v]] ] }}
| update_return ( curr_stack_frame , curr_stack_frame' , d_list , ( x1 , .. , xn ) ) :: M :: update_return
  %curr_stack_frame is function's stack frame, curr_stack_frame' is caller's stack frame
  {{ com update caller's stack frame upon function return }}
  %TODO: fix the \varepsilon and e list in the latex output. 
  {{ tex \mathrm{FOLD} (\lambda \, \overline{\varepsilon} \, i . \,
	                  \mathrm{if}  [[d_list]] [i] \in \{ \downarrow , \circ \} \, \mathrm{then} \, \overline{\varepsilon} \\
                          \mathrm{else} \, \overline{\varepsilon} \, [a \longmapsto v] \mathit{where} \; (\mathit{v}, a) = \mathrm{lookup_t}( [[curr_stack_frame]] , [x_1 , ... , x_n] [i]) ) ( [[curr_stack_frame']] ) [1 ... n] }}
  {{ hol (update_return_frame [[x1 .. xn]] [[d_list]] [[curr_stack_frame']] [[curr_stack_frame]]) }}
| ( curr_stack_frame ) :: S :: paren
  {{ hol ([[curr_stack_frame]]) }}

%Fence so that ott does not re-order called_function_name
embed
{{ hol

}}
grammar

called_function_name {{ tex F_n }} :: called_function_name_ ::=
{{ com called function name  }}
| bot :: :: bot
  {{ tex \bot }}
| f :: :: function_name
  {{ tex [[f]] }}

%Fence so that ott does not re-order called_function_name
embed
{{ hol

}}
grammar  

call_stack {{ tex E }} :: call_stack_ ::=
{{ com stack of caller stack frames }}
{{ hol ((curr_stack_frame # called_function_name) list) }}
| emptycs :: M :: empty
  {{ hol ([]:((curr_stack_frame # called_function_name) list)) }}
  {{ tex {\emptyset}_{E} }}
| [ ( curr_stack_frame1 , called_function_name1 ) , .. , ( curr_stack_framen , called_function_namen ) ] :: M :: list
  {{ hol ([[curr_stack_frame1 called_function_name1 .. curr_stack_framen called_function_namen]]) }}
| ( curr_stack_frame , called_function_name ) '::' call_stack :: M :: cons
  {{ hol (([[curr_stack_frame]], [[called_function_name]]) :: [[call_stack]]) }}
  {{ tex ([[curr_stack_frame]], [[called_function_name]]) :: [[call_stack]] }}
| ( call_stack ) :: S :: paren
  {{ hol ([[call_stack]]) }}

stacks {{ tex \sigma }} :: stacks_ ::=
{{ com stacks in execution state }}
| ( curr_stack_frame , call_stack ) :: :: tup

state {{ tex s }} :: state_ ::=
{{ com execution state }}
| ( stacks , status ) :: :: tup

%%%%%%%%%%%%%%%%%%%%%%%%
% Expression semantics %
%%%%%%%%%%%%%%%%%%%%%%%%

terminals :: terminals_ ::=
%Statement reduction
| -> :: :: rightarrow {{ tex \rightarrow }}
%Expression reduction
| ~> :: :: rightsquigarrow {{ tex \rightsquigarrow }}
%Parser state reduction
| --> :: :: longrightarrow {{ tex \longrightarrow }}

formula :: formula_ ::=
{{ com formulas }}
| judgement :: :: judgement
  {{ com judgement }}
%Expressions
| ! b = b' :: M :: neg_bool
  {{ hol (~[[b]] = [[b']]) }}
| ~ bitv = bitv' :: M :: compl
  {{ hol (bitv_bl_unop bnot [[bitv]] = [[bitv']]) }}
| - bitv = bitv' :: M :: neg_signed
  {{ hol (bitv_unop unop_neg_signed [[bitv]] = [[bitv']]) }}
| + bitv = bitv' :: M :: un_plus
  %Note P4 spec says this is a noop
  {{ hol ([[bitv]] = [[bitv']]) }}
| bitv * bitv' = bitv'' :: M :: mul
  {{ hol (bitv_binop binop_mul [[bitv]] [[bitv']] = SOME [[bitv'']]) }}
| bitv / bitv' = bitv'' :: M :: div
  {{ hol (bitv_binop binop_div [[bitv]] [[bitv']] = SOME [[bitv'']]) }}
| bitv mod bitv' = bitv'' :: M :: mod
  {{ hol (bitv_binop binop_mod [[bitv]] [[bitv']] = SOME [[bitv'']]) }}
| bitv + bitv' = bitv'' :: M :: add
  {{ hol (bitv_binop binop_add [[bitv]] [[bitv']] = SOME [[bitv'']]) }}
| bitv - bitv' = bitv'' :: M :: sub
  {{ hol (bitv_binop binop_sub [[bitv]] [[bitv']] = SOME [[bitv'']]) }}
%TODO: Unify the below eq_ to equality over values?
| bitv EQ bitv' = b :: M :: eq_word
  {{ hol (([[bitv]] = [[bitv']]) <=> [[b]]) }}
| b EQ b' = b'' :: M :: eq_bool
  {{ hol ([[b]] = [[b']] <=> [[b'']]) }}
| ( x EQ x' ) = b :: M :: eq_error
  {{ com equality over errors }}
  {{ hol (([[x]] = [[x']]) = [[b]]) }}
  {{ tex ([[x]] = [[x']]) = [[b]] }}
| bitv SHL bitv' = bitv'' :: M :: shl
  %TODO: Put fixwidth here instead?
  {{ hol (bitv_bl_binop shiftl [[bitv]] ((\(bl, n). (v2n bl, n)) [[bitv']]) = [[bitv'']]) }}
| bitv SHR bitv' = bitv'' :: M :: shr
  %TODO: Put fixwidth here instead?
  {{ hol (bitv_bl_binop shiftr [[bitv]] ((\(bl, n). (v2n bl, n)) [[bitv']]) = [[bitv'']]) }}
| bitv LE bitv' = b :: M :: le
  {{ hol ((bitv_binpred binop_le [[bitv]] [[bitv']]) = SOME [[b]]) }}
| bitv GE bitv' = b :: M :: ge
  {{ hol ((bitv_binpred binop_ge [[bitv]] [[bitv']]) = SOME [[b]]) }}
| bitv < bitv' = b :: M :: lt
  {{ hol ((bitv_binpred binop_lt [[bitv]] [[bitv']]) = SOME [[b]]) }}
| bitv > bitv' = b :: M :: gt
  {{ hol ((bitv_binpred binop_gt [[bitv]] [[bitv']]) = SOME [[b]]) }}
%TODO: Unify the below neq_ to inequality over values?
| bitv NE bitv' = b :: M :: neq_word
  {{ hol (([[bitv]] <> [[bitv']]) <=> [[b]]) }}
| ( x <> x' ) = b :: M :: neq_error
  {{ com inequality over errors }}
  {{ hol (([[x]] <> [[x']]) = [[b]]) }}
  {{ tex ([[x]] \neq [[x']]) = [[b]] }}
| bitv & bitv' = bitv'' :: M :: and_word
  {{ hol (bitv_bl_binop band [[bitv]] [[bitv']] = [[bitv'']]) }}
| bitv ^ bitv' = bitv'' :: M :: xor_word
  %TODO: Decide LaTeX XOR representation
  {{ hol (bitv_bl_binop bxor [[bitv]] [[bitv']] = [[bitv'']]) }}
| bitv '|' bitv' = bitv'' :: M :: or_word
  {{ hol (bitv_bl_binop bor [[bitv]] [[bitv']] = [[bitv'']]) }}
| b AND b' = b'' :: M :: and_bool
  {{ hol ([[b]] /\ [[b']] = [[b'']]) }}
| b OR b' = b'' :: M :: or_bool
  {{ hol ([[b]] \/ [[b']] = [[b'']]) }}

%Type-transforming operations
| curr_stack_frame = hd call_stack :: M :: call_stack_hd
  {{ hol ([[curr_stack_frame]] = HD [[call_stack]]) }}
  {{ tex [[curr_stack_frame]] = \mathrm{hd} [[call_stack]] }}
| scope = curr_stack_frame [ i ] :: M :: curr_stack_frame_index
  {{ hol ([[scope]] = EL [[i]] [[curr_stack_frame]]) }}
| ( stmt , ( x1 , d1 ) , .. , ( xn , dn ) ) = func_map ( f ) :: M :: func_lookup
  {{ com function signature lookup }}
  {{ hol (FLOOKUP [[func_map]] [[f]] = SOME ([[stmt]], [[x1 d1 .. xn dn]])) }}
| find_index_max ( curr_stack_frame , x ) = i :: M :: find_index_scope_max
  {{ com find max index of variable's scope }}
  %INDEX_FIND finds the first occurrence, starting from head and going backwards in list
  {{ hol (FST (THE (INDEX_FIND 0 (\sf. IS_SOME (FLOOKUP sf [[x]])) [[curr_stack_frame]])) = [[i]]) }}
  {{ tex i = \mathrm{max} \, \{ j . \,\, [[x]]  \in \mathrm{dom} ( [[curr_stack_frame]] [j] )   \} }}
%  {{ tex [[x]] \in \mathrm{dom}([[curr_stack_frame]][ [[i]] ]) \land \forall j . \,\, j > [[i]] \Rightarrow [[x]] \notin \mathrm{dom}([[curr_stack_frame]][j]) }}
| length ( curr_stack_frame ) = i :: M :: find_length
  {{ com find the current stack frame length }}
  {{ tex [[i]] = length ([[curr_stack_frame]])}}
  {{ hol ([[i]] = LENGTH [[curr_stack_frame]]) }}
| v = scope ( x ) :: M :: lookup
  {{ com look-up of variable in scope }}
  {{ hol (FLOOKUP [[scope]] [[x]] = SOME [[v]]) }}
| v = struct { x1 = v1 ; ... ; xn = vn } ( x ) :: M :: s_access
  {{ com access of field in struct }}
  {{ hol (FIND (\(k, v). k = [[x]]) [[x1 v1 ... xn vn]] = SOME ([[x]], [[v]])) }}
| v = header boolv { x1 = v1 ; ... ; xn = vn } ( x ) :: M :: h_access
  {{ com access of field in header }}
  {{ hol (FIND (\(k, v). k = [[x]]) [[x1 v1 ... xn vn]] = SOME ([[x]], [[v]])) }}
| e = e_list [ i ] :: M :: args_index
  {{ hol ([[e]] = EL [[i]] [[e_list]]) }}
| e = hd e_list :: M :: args_hd
  {{ hol ([[e]] = HD [[e_list]]) }}
  {{ tex [[e]] = \mathrm{hd} \,\, [[e_list]] }}
| v = lookup_vexp ( curr_stack_frame , e ) :: :: lookup_v
  {{ tex [[v]] = \mathrm{lookup_v} ([[curr_stack_frame]], [[e]]) }}
  {{ hol [[v]] =  lookup_vexp [[curr_stack_frame]] [[e]]}}
| ( v , a ) = lookup_tup ( curr_stack_frame , x ) :: :: lookup_tup
  {{ tex ([[v]] , [[a]]) = \mathrm{lookup_tup} ([[curr_stack_frame]], [[x]]) }}
| x' = { v1 : x1 ; ... ; vn : xn } x ( v ) :: M :: sel_access
  {{ com access of string in select key-value list }}
  {{ hol (FIND (\(ks, s). ks = [[v]]) [[v1 x1 ... vn xn]] = SOME ([[v]], [[x']])) }}
  %TODO: Hack due to lack of list comprehension for tex
  {{ tex [[x']] = \{ v_1 : x_1 ; ... ; v_n : x_n ; \_ : x \} (v) }}
| v notin { v1 : x1 ; ... ; vn : xn } :: M :: sel_def
  {{ com default string in select key-value list }}
  {{ hol (FIND (\(ks, s). ks = [[v]]) [[v1 x1 ... vn xn]] = NONE) }}
  %TODO: Hack due to lack of list comprehension for tex
  {{ tex [[v]] \notin \mathrm{dom}(\{ v_1 : x_1 ; ... ; v_n : x_n \}) }}
| check_args_red d_list e_list :: M :: signature_check  
  {{ com check if parameters are isvar or isconst }}
  {{ tex \forall d ,\, e ,\, i \leqslant n. \, d = [[d_list]] [i] \, \land \, e = [[e_list]] [i] \, \implies  
         ((d \in \{\circ , \downarrow\} \implies \mathrm{is\_const} \, e ) \land (d \in \{\updownarrow , \uparrow\} \implies \mathrm{is\_var} \, e)) }}
  {{ hol (check_args_red [[d_list]] [[e_list]]) }}

%some operations on the direction list
| d = d_list [ i ] :: M :: d_index
  {{ hol ([[d]] = EL [[i]] [[d_list]]) }}
  {{ tex [[d]] = [[d_list]] [[i]] }}  
| d = hd d_list :: M :: d_hd
  {{ hol ([[d]] = HD [[d_list]]) }}
  {{ tex [[d]] = \mathrm{hd} \,\, [[d_list]] }} 
| unred_arg_index d_list e_list = i :: M :: parameter_index
  {{ tex i = \mathrm{min} \, \{ j . \,\, [[d_list]] [j]  \in \{\circ , \downarrow\} \wedge \neg ( \mathrm{is\_const} \, [[e_list]] [j] ) \} }}
  {{ hol (unred_arg_index [[d_list]] [[e_list]] = i) }}

%Equalities
| scope = scope' :: M :: scope_eq
  {{ com scope equality }}
  {{ hol ([[scope]] = [[scope']]) }}
| curr_stack_frame = curr_stack_frame' :: M :: curr_stack_frame_eq
  {{ com curr_stack_frame equality }}
  {{ hol ([[curr_stack_frame]] = [[curr_stack_frame']]) }}
| call_stack = call_stack' :: M :: call_stack_eq
  {{ com call_stack equality }}
  {{ hol ([[call_stack]] = [[call_stack']]) }}
%Note the modified equality sign in the below.
%This help to distinguish between e and e_list, as well as provide a single parse
%considering some equalities between expressions are explicitly typeset
| e_list =' e_list' :: M :: args_eq
  {{ com args equality }}
  {{ hol ([[e_list]] = [[e_list']]) }}
  {{ tex [[e_list]] = [[e_list']] }}

%Apply table
| t_map ( table_name ) = ( e , match_kind ) :: :: find_key
  {{ com find keys and the matching kind in the table map }}
  {{ tex \mathrm{t\_map}\, [[table_name]]\, =\, ( [[e]] \, , [[match_kind]] ) }}
  {{ hol ( FLOOKUP [[t_map]] [[table_name]] = SOME ( [[e]] , [[match_kind]] ) ) }}
| ctrl ( table_name , v , match_kind ) = ( f , e_list ) :: :: ctrl_plane  
  {{ com fetch the function name and parameters from the ctrl plane }}
  {{ tex \mathrm{ctrl}\, ( [[table_name]] , \, [[v]], \, [[match_kind]]\, ) = \,( [[f]] , [[e_list]] ) }}
  {{ hol ( FLOOKUP [[ctrl]] ( [[table_name]] , [[v]] , [[match_kind]] ) = SOME ( [[f]] , [[e_list]] ) ) }}

%MISC (TODO: Sort these)
%TODO: Equalities and inequalities on numerals
| i' = i + 1 :: M :: num_inc
  {{ com numeral increment }}
  {{ hol ([[i']] = [[i]] + 1) }}
  {{ tex [[i']] = [[i]] + 1 }}
| i = length ( e_list ) :: M :: num_len
  {{ com length of list }}
  {{ hol ([[i]] = LENGTH [[e_list]]) }}
  {{ tex [[i]] = \mathrm{len} \,\, [[e_list]] }}
| i < length ( e_list ) :: M :: num_in_rg
  {{ com numeral in range }}
  {{ hol ([[i]] < LENGTH [[e_list]]) }}
  {{ tex [[i]] < \mathrm{len}(\mathit{e}) }}
| is_consts ( e_list ) :: M :: args_const
  {{ com function arguments constant }}
  {{ hol (is_consts [[e_list]]) }}
  %TODO: Fix typesetting
  {{ tex \mathrm{is\_consts} \,\, [[e_list]] }}
| stmt = pars_map ( x ) :: M :: pars_lookup
  {{ com parser state map lookup }}
  {{ hol (FLOOKUP [[pars_map]] [[x]] = SOME ([[stmt]])) }}
| x = parseError :: M :: pars_err
  {{ com parser error literal }}
  {{ hol ([[x]] = "parseError") }}
  {{ tex [[x]] = ``\mathit{parseError}" }}
  %Dummy to keep syntax highlighting from freaking out: "
| v = lookup_lval ( curr_stack_frame , lval ) :: M :: lookup_lval
  {{ com instantaneous lookup of lvals }}
  {{ hol ([[v]] = lookup_lval [[curr_stack_frame]]  [[lval]]) }}
  {{ tex [[v]] = { \mathrm{lookup} }_{ \mathrm{lval} } ([[curr_stack_frame]], [[lval]]) }}
| v'' = ( struct { x1 = v1 ; ... ; xn = vn } with x := v ) :: M :: s_fld_upd
  {{ com update of struct field }}
  {{ hol ([[v'']] = v_struct (LUPDATE ([[x]], [[v]]) (THE (INDEX_OF [[x]] (MAP FST [[x1 v1 ... xn vn]]))) [[x1 v1 ... xn vn]])) }}
| v'' = ( header boolv { x1 = v1 ; ... ; xn = vn } with x := v ) :: M :: h_fld_upd
  {{ com update of struct field }}
  {{ hol ([[v'']] = v_header [[boolv]] (LUPDATE ([[x]], [[v]]) (THE (INDEX_OF [[x]] (MAP FST [[x1 v1 ... xn vn]]))) [[x1 v1 ... xn vn]])) }}
| not_final_state ( x ) :: M :: not_final
  {{ com x is not name of final state }}
  {{ hol (([[x]] <> "accept") /\ ([[x]] <> "reject")) }}
| x = "accept" :: M :: is_accept
  {{ com x is accept }}
  {{ hol ([[x]] = "accept") }}
  {{ tex [[x]] = ``\mathit{accept}" }}
  %Dummy to keep syntax highlighting from freaking out: "
| x = "reject" :: M :: is_reject
  {{ com x is reject }}
  {{ hol ([[x]] = "reject") }}
  {{ tex [[x]] = ``\mathit{reject}" }}
  %Dummy to keep syntax highlighting from freaking out: "
| scope = all_arg_update_for_newscope ( ( x1 , .. , xn ) , d_list , e_list , curr_stack_frame ) :: M :: build_scope
  {{ com build new scope }}
  {{ tex \forall d,\, e,\, x,\, i \leqslant n . \, x = [x_1 , ... , x_n] [i] \land 
         \, e = [e_1 , ... , e_n] [i] \land 
         \, d = [d_1 , ... , d_n] [i] 
         \implies [[scope]](x) = 
	   \begin{cases}
	     (\mathrm{lookup_v}( \varepsilon , e), e) & \mathrm{if} \; d \in \{ \uparrow , \updownarrow \} \\
             (e, \bot) & \mathrm{if} \; d \in \{ \downarrow , \circ \}
	   \end{cases} }}
  {{ hol ([[scope]] = all_arg_update_for_newscope [[x1 .. xn]] [[d_list]] [[e_list]] [[curr_stack_frame]]) }}

embed
{{ hol
val is_const_def = Define `
  (is_const (e_v _) = T) /\
  (is_const _ = F)
`;
val is_consts_def = Define `
  is_consts el = ~(EXISTS (\e. ~(is_const e)) el)
`;

(* Access the field f of a struct or a header *)
val acc_f_def = Define `
  (acc_f (v_struct s) f = SOME (SND (THE (FIND (\(f', v). f' = f) s)))) /\
  (acc_f (v_header _ s) f = SOME (SND (THE (FIND (\(f', v). f' = f) s)))) /\
  (acc_f _ f = NONE)
`;

val bitv_bl_unop_def = Define `
  bitv_bl_unop unop (bl, n) = (unop bl, n)
`;

val bitv_bl_binop_def = Define `
  bitv_bl_binop binop (bl, n) (bl', n') = (fixwidth n (binop bl bl'), n)
`;

val get_word_unop_def = Define `
  (get_word_unop unop_compl = word_1comp) /\
  (get_word_unop unop_neg_signed = word_2comp) /\
  (get_word_unop unop_un_plus = (\w. w))
`;
val bitv_unop_def = Define `
    (bitv_unop unop (v, 1) = (w2v ((get_word_unop unop) ((v2w v): 1 word)), 1) )
/\  (bitv_unop unop (v, 2) = (w2v ((get_word_unop unop) ((v2w v): 2 word)), 2) )
/\  (bitv_unop unop (v, 3) = (w2v ((get_word_unop unop) ((v2w v): 3 word)), 3) )
/\  (bitv_unop unop (v, 4) = (w2v ((get_word_unop unop) ((v2w v): 4 word)), 4) )
/\  (bitv_unop unop (v, 5) = (w2v ((get_word_unop unop) ((v2w v): 5 word)), 5) )
/\  (bitv_unop unop (v, 6) = (w2v ((get_word_unop unop) ((v2w v): 6 word)), 6) )
/\  (bitv_unop unop (v, 7) = (w2v ((get_word_unop unop) ((v2w v): 7 word)), 7) )
/\  (bitv_unop unop (v, 8) = (w2v ((get_word_unop unop) ((v2w v): 8 word)), 8) )
/\  (bitv_unop unop (v, 9) = (w2v ((get_word_unop unop) ((v2w v): 9 word)), 9) )
/\  (bitv_unop unop (v, 10) = (w2v ((get_word_unop unop) ((v2w v): 10 word)), 10) )
/\  (bitv_unop unop (v, 11) = (w2v ((get_word_unop unop) ((v2w v): 11 word)), 11) )
/\  (bitv_unop unop (v, 12) = (w2v ((get_word_unop unop) ((v2w v): 12 word)), 12) )
/\  (bitv_unop unop (v, 13) = (w2v ((get_word_unop unop) ((v2w v): 13 word)), 13) )
/\  (bitv_unop unop (v, 14) = (w2v ((get_word_unop unop) ((v2w v): 14 word)), 14) )
/\  (bitv_unop unop (v, 15) = (w2v ((get_word_unop unop) ((v2w v): 15 word)), 15) )
/\  (bitv_unop unop (v, 16) = (w2v ((get_word_unop unop) ((v2w v): 16 word)), 16) )
/\  (bitv_unop unop (v, 17) = (w2v ((get_word_unop unop) ((v2w v): 17 word)), 17) )
/\  (bitv_unop unop (v, 18) = (w2v ((get_word_unop unop) ((v2w v): 18 word)), 18) )
/\  (bitv_unop unop (v, 19) = (w2v ((get_word_unop unop) ((v2w v): 19 word)), 19) )
/\  (bitv_unop unop (v, 20) = (w2v ((get_word_unop unop) ((v2w v): 20 word)), 20) )
/\  (bitv_unop unop (v, 21) = (w2v ((get_word_unop unop) ((v2w v): 21 word)), 21) )
/\  (bitv_unop unop (v, 22) = (w2v ((get_word_unop unop) ((v2w v): 22 word)), 22) )
/\  (bitv_unop unop (v, 23) = (w2v ((get_word_unop unop) ((v2w v): 23 word)), 23) )
/\  (bitv_unop unop (v, 24) = (w2v ((get_word_unop unop) ((v2w v): 24 word)), 24) )
/\  (bitv_unop unop (v, 25) = (w2v ((get_word_unop unop) ((v2w v): 25 word)), 25) )
/\  (bitv_unop unop (v, 26) = (w2v ((get_word_unop unop) ((v2w v): 26 word)), 26) )
/\  (bitv_unop unop (v, 27) = (w2v ((get_word_unop unop) ((v2w v): 27 word)), 27) )
/\  (bitv_unop unop (v, 28) = (w2v ((get_word_unop unop) ((v2w v): 28 word)), 28) )
/\  (bitv_unop unop (v, 29) = (w2v ((get_word_unop unop) ((v2w v): 29 word)), 29) )
/\  (bitv_unop unop (v, 30) = (w2v ((get_word_unop unop) ((v2w v): 30 word)), 30) )
/\  (bitv_unop unop (v, 31) = (w2v ((get_word_unop unop) ((v2w v): 31 word)), 31) )
/\  (bitv_unop unop (v, 32) = (w2v ((get_word_unop unop) ((v2w v): 32 word)), 32) )
/\  (bitv_unop unop (v, 33) = (w2v ((get_word_unop unop) ((v2w v): 33 word)), 33) )
/\  (bitv_unop unop (v, 34) = (w2v ((get_word_unop unop) ((v2w v): 34 word)), 34) )
/\  (bitv_unop unop (v, 35) = (w2v ((get_word_unop unop) ((v2w v): 35 word)), 35) )
/\  (bitv_unop unop (v, 36) = (w2v ((get_word_unop unop) ((v2w v): 36 word)), 36) )
/\  (bitv_unop unop (v, 37) = (w2v ((get_word_unop unop) ((v2w v): 37 word)), 37) )
/\  (bitv_unop unop (v, 38) = (w2v ((get_word_unop unop) ((v2w v): 38 word)), 38) )
/\  (bitv_unop unop (v, 39) = (w2v ((get_word_unop unop) ((v2w v): 39 word)), 39) )
/\  (bitv_unop unop (v, 40) = (w2v ((get_word_unop unop) ((v2w v): 40 word)), 40) )
/\  (bitv_unop unop (v, 41) = (w2v ((get_word_unop unop) ((v2w v): 41 word)), 41) )
/\  (bitv_unop unop (v, 42) = (w2v ((get_word_unop unop) ((v2w v): 42 word)), 42) )
/\  (bitv_unop unop (v, 43) = (w2v ((get_word_unop unop) ((v2w v): 43 word)), 43) )
/\  (bitv_unop unop (v, 44) = (w2v ((get_word_unop unop) ((v2w v): 44 word)), 44) )
/\  (bitv_unop unop (v, 45) = (w2v ((get_word_unop unop) ((v2w v): 45 word)), 45) )
/\  (bitv_unop unop (v, 46) = (w2v ((get_word_unop unop) ((v2w v): 46 word)), 46) )
/\  (bitv_unop unop (v, 47) = (w2v ((get_word_unop unop) ((v2w v): 47 word)), 47) )
/\  (bitv_unop unop (v, 48) = (w2v ((get_word_unop unop) ((v2w v): 48 word)), 48) )
/\  (bitv_unop unop (v, 49) = (w2v ((get_word_unop unop) ((v2w v): 49 word)), 49) )
/\  (bitv_unop unop (v, 50) = (w2v ((get_word_unop unop) ((v2w v): 50 word)), 50) )
/\  (bitv_unop unop (v, 51) = (w2v ((get_word_unop unop) ((v2w v): 51 word)), 51) )
/\  (bitv_unop unop (v, 52) = (w2v ((get_word_unop unop) ((v2w v): 52 word)), 52) )
/\  (bitv_unop unop (v, 53) = (w2v ((get_word_unop unop) ((v2w v): 53 word)), 53) )
/\  (bitv_unop unop (v, 54) = (w2v ((get_word_unop unop) ((v2w v): 54 word)), 54) )
/\  (bitv_unop unop (v, 55) = (w2v ((get_word_unop unop) ((v2w v): 55 word)), 55) )
/\  (bitv_unop unop (v, 56) = (w2v ((get_word_unop unop) ((v2w v): 56 word)), 56) )
/\  (bitv_unop unop (v, 57) = (w2v ((get_word_unop unop) ((v2w v): 57 word)), 57) )
/\  (bitv_unop unop (v, 58) = (w2v ((get_word_unop unop) ((v2w v): 58 word)), 58) )
/\  (bitv_unop unop (v, 59) = (w2v ((get_word_unop unop) ((v2w v): 59 word)), 59) )
/\  (bitv_unop unop (v, 60) = (w2v ((get_word_unop unop) ((v2w v): 60 word)), 60) )
/\  (bitv_unop unop (v, 61) = (w2v ((get_word_unop unop) ((v2w v): 61 word)), 61) )
/\  (bitv_unop unop (v, 62) = (w2v ((get_word_unop unop) ((v2w v): 62 word)), 62) )
/\  (bitv_unop unop (v, 63) = (w2v ((get_word_unop unop) ((v2w v): 63 word)), 63) )
/\  (bitv_unop unop (v, 64) = (w2v ((get_word_unop unop) ((v2w v): 64 word)), 64) )
`;
val get_word_binop_def = Define `
    (get_word_binop binop_mul = word_mul)
/\  (get_word_binop binop_div = word_div)
/\  (get_word_binop binop_mod = word_mod)
/\  (get_word_binop binop_add = word_add)
/\  (get_word_binop binop_sub = word_sub)
/\  (get_word_binop binop_shl = word_lsl_bv)
/\  (get_word_binop binop_shr = word_lsr_bv)
/\  (get_word_binop binop_and = word_and)
/\  (get_word_binop binop_xor = word_xor)
/\  (get_word_binop binop_or = word_or)
`;

val bitv_binop_inner_def = Define `
    (bitv_binop_inner binop v v' 1 = SOME (w2v ((get_word_binop binop) ((v2w v): 1 word) ((v2w v'): 1 word)), 1) )
/\  (bitv_binop_inner binop v v' 2 = SOME (w2v ((get_word_binop binop) ((v2w v): 2 word) ((v2w v'): 2 word)), 2) )
/\  (bitv_binop_inner binop v v' 3 = SOME (w2v ((get_word_binop binop) ((v2w v): 3 word) ((v2w v'): 3 word)), 3) )
/\  (bitv_binop_inner binop v v' 4 = SOME (w2v ((get_word_binop binop) ((v2w v): 4 word) ((v2w v'): 4 word)), 4) )
/\  (bitv_binop_inner binop v v' 5 = SOME (w2v ((get_word_binop binop) ((v2w v): 5 word) ((v2w v'): 5 word)), 5) )
/\  (bitv_binop_inner binop v v' 6 = SOME (w2v ((get_word_binop binop) ((v2w v): 6 word) ((v2w v'): 6 word)), 6) )
/\  (bitv_binop_inner binop v v' 7 = SOME (w2v ((get_word_binop binop) ((v2w v): 7 word) ((v2w v'): 7 word)), 7) )
/\  (bitv_binop_inner binop v v' 8 = SOME (w2v ((get_word_binop binop) ((v2w v): 8 word) ((v2w v'): 8 word)), 8) )
/\  (bitv_binop_inner binop v v' 9 = SOME (w2v ((get_word_binop binop) ((v2w v): 9 word) ((v2w v'): 9 word)), 9) )
/\  (bitv_binop_inner binop v v' 10 = SOME (w2v ((get_word_binop binop) ((v2w v): 10 word) ((v2w v'): 10 word)), 10) )
/\  (bitv_binop_inner binop v v' 11 = SOME (w2v ((get_word_binop binop) ((v2w v): 11 word) ((v2w v'): 11 word)), 11) )
/\  (bitv_binop_inner binop v v' 12 = SOME (w2v ((get_word_binop binop) ((v2w v): 12 word) ((v2w v'): 12 word)), 12) )
/\  (bitv_binop_inner binop v v' 13 = SOME (w2v ((get_word_binop binop) ((v2w v): 13 word) ((v2w v'): 13 word)), 13) )
/\  (bitv_binop_inner binop v v' 14 = SOME (w2v ((get_word_binop binop) ((v2w v): 14 word) ((v2w v'): 14 word)), 14) )
/\  (bitv_binop_inner binop v v' 15 = SOME (w2v ((get_word_binop binop) ((v2w v): 15 word) ((v2w v'): 15 word)), 15) )
/\  (bitv_binop_inner binop v v' 16 = SOME (w2v ((get_word_binop binop) ((v2w v): 16 word) ((v2w v'): 16 word)), 16) )
/\  (bitv_binop_inner binop v v' 17 = SOME (w2v ((get_word_binop binop) ((v2w v): 17 word) ((v2w v'): 17 word)), 17) )
/\  (bitv_binop_inner binop v v' 18 = SOME (w2v ((get_word_binop binop) ((v2w v): 18 word) ((v2w v'): 18 word)), 18) )
/\  (bitv_binop_inner binop v v' 19 = SOME (w2v ((get_word_binop binop) ((v2w v): 19 word) ((v2w v'): 19 word)), 19) )
/\  (bitv_binop_inner binop v v' 20 = SOME (w2v ((get_word_binop binop) ((v2w v): 20 word) ((v2w v'): 20 word)), 20) )
/\  (bitv_binop_inner binop v v' 21 = SOME (w2v ((get_word_binop binop) ((v2w v): 21 word) ((v2w v'): 21 word)), 21) )
/\  (bitv_binop_inner binop v v' 22 = SOME (w2v ((get_word_binop binop) ((v2w v): 22 word) ((v2w v'): 22 word)), 22) )
/\  (bitv_binop_inner binop v v' 23 = SOME (w2v ((get_word_binop binop) ((v2w v): 23 word) ((v2w v'): 23 word)), 23) )
/\  (bitv_binop_inner binop v v' 24 = SOME (w2v ((get_word_binop binop) ((v2w v): 24 word) ((v2w v'): 24 word)), 24) )
/\  (bitv_binop_inner binop v v' 25 = SOME (w2v ((get_word_binop binop) ((v2w v): 25 word) ((v2w v'): 25 word)), 25) )
/\  (bitv_binop_inner binop v v' 26 = SOME (w2v ((get_word_binop binop) ((v2w v): 26 word) ((v2w v'): 26 word)), 26) )
/\  (bitv_binop_inner binop v v' 27 = SOME (w2v ((get_word_binop binop) ((v2w v): 27 word) ((v2w v'): 27 word)), 27) )
/\  (bitv_binop_inner binop v v' 28 = SOME (w2v ((get_word_binop binop) ((v2w v): 28 word) ((v2w v'): 28 word)), 28) )
/\  (bitv_binop_inner binop v v' 29 = SOME (w2v ((get_word_binop binop) ((v2w v): 29 word) ((v2w v'): 29 word)), 29) )
/\  (bitv_binop_inner binop v v' 30 = SOME (w2v ((get_word_binop binop) ((v2w v): 30 word) ((v2w v'): 30 word)), 30) )
/\  (bitv_binop_inner binop v v' 31 = SOME (w2v ((get_word_binop binop) ((v2w v): 31 word) ((v2w v'): 31 word)), 31) )
/\  (bitv_binop_inner binop v v' 32 = SOME (w2v ((get_word_binop binop) ((v2w v): 32 word) ((v2w v'): 32 word)), 32) )
/\  (bitv_binop_inner binop v v' 33 = SOME (w2v ((get_word_binop binop) ((v2w v): 33 word) ((v2w v'): 33 word)), 33) )
/\  (bitv_binop_inner binop v v' 34 = SOME (w2v ((get_word_binop binop) ((v2w v): 34 word) ((v2w v'): 34 word)), 34) )
/\  (bitv_binop_inner binop v v' 35 = SOME (w2v ((get_word_binop binop) ((v2w v): 35 word) ((v2w v'): 35 word)), 35) )
/\  (bitv_binop_inner binop v v' 36 = SOME (w2v ((get_word_binop binop) ((v2w v): 36 word) ((v2w v'): 36 word)), 36) )
/\  (bitv_binop_inner binop v v' 37 = SOME (w2v ((get_word_binop binop) ((v2w v): 37 word) ((v2w v'): 37 word)), 37) )
/\  (bitv_binop_inner binop v v' 38 = SOME (w2v ((get_word_binop binop) ((v2w v): 38 word) ((v2w v'): 38 word)), 38) )
/\  (bitv_binop_inner binop v v' 39 = SOME (w2v ((get_word_binop binop) ((v2w v): 39 word) ((v2w v'): 39 word)), 39) )
/\  (bitv_binop_inner binop v v' 40 = SOME (w2v ((get_word_binop binop) ((v2w v): 40 word) ((v2w v'): 40 word)), 40) )
/\  (bitv_binop_inner binop v v' 41 = SOME (w2v ((get_word_binop binop) ((v2w v): 41 word) ((v2w v'): 41 word)), 41) )
/\  (bitv_binop_inner binop v v' 42 = SOME (w2v ((get_word_binop binop) ((v2w v): 42 word) ((v2w v'): 42 word)), 42) )
/\  (bitv_binop_inner binop v v' 43 = SOME (w2v ((get_word_binop binop) ((v2w v): 43 word) ((v2w v'): 43 word)), 43) )
/\  (bitv_binop_inner binop v v' 44 = SOME (w2v ((get_word_binop binop) ((v2w v): 44 word) ((v2w v'): 44 word)), 44) )
/\  (bitv_binop_inner binop v v' 45 = SOME (w2v ((get_word_binop binop) ((v2w v): 45 word) ((v2w v'): 45 word)), 45) )
/\  (bitv_binop_inner binop v v' 46 = SOME (w2v ((get_word_binop binop) ((v2w v): 46 word) ((v2w v'): 46 word)), 46) )
/\  (bitv_binop_inner binop v v' 47 = SOME (w2v ((get_word_binop binop) ((v2w v): 47 word) ((v2w v'): 47 word)), 47) )
/\  (bitv_binop_inner binop v v' 48 = SOME (w2v ((get_word_binop binop) ((v2w v): 48 word) ((v2w v'): 48 word)), 48) )
/\  (bitv_binop_inner binop v v' 49 = SOME (w2v ((get_word_binop binop) ((v2w v): 49 word) ((v2w v'): 49 word)), 49) )
/\  (bitv_binop_inner binop v v' 50 = SOME (w2v ((get_word_binop binop) ((v2w v): 50 word) ((v2w v'): 50 word)), 50) )
/\  (bitv_binop_inner binop v v' 51 = SOME (w2v ((get_word_binop binop) ((v2w v): 51 word) ((v2w v'): 51 word)), 51) )
/\  (bitv_binop_inner binop v v' 52 = SOME (w2v ((get_word_binop binop) ((v2w v): 52 word) ((v2w v'): 52 word)), 52) )
/\  (bitv_binop_inner binop v v' 53 = SOME (w2v ((get_word_binop binop) ((v2w v): 53 word) ((v2w v'): 53 word)), 53) )
/\  (bitv_binop_inner binop v v' 54 = SOME (w2v ((get_word_binop binop) ((v2w v): 54 word) ((v2w v'): 54 word)), 54) )
/\  (bitv_binop_inner binop v v' 55 = SOME (w2v ((get_word_binop binop) ((v2w v): 55 word) ((v2w v'): 55 word)), 55) )
/\  (bitv_binop_inner binop v v' 56 = SOME (w2v ((get_word_binop binop) ((v2w v): 56 word) ((v2w v'): 56 word)), 56) )
/\  (bitv_binop_inner binop v v' 57 = SOME (w2v ((get_word_binop binop) ((v2w v): 57 word) ((v2w v'): 57 word)), 57) )
/\  (bitv_binop_inner binop v v' 58 = SOME (w2v ((get_word_binop binop) ((v2w v): 58 word) ((v2w v'): 58 word)), 58) )
/\  (bitv_binop_inner binop v v' 59 = SOME (w2v ((get_word_binop binop) ((v2w v): 59 word) ((v2w v'): 59 word)), 59) )
/\  (bitv_binop_inner binop v v' 60 = SOME (w2v ((get_word_binop binop) ((v2w v): 60 word) ((v2w v'): 60 word)), 60) )
/\  (bitv_binop_inner binop v v' 61 = SOME (w2v ((get_word_binop binop) ((v2w v): 61 word) ((v2w v'): 61 word)), 61) )
/\  (bitv_binop_inner binop v v' 62 = SOME (w2v ((get_word_binop binop) ((v2w v): 62 word) ((v2w v'): 62 word)), 62) )
/\  (bitv_binop_inner binop v v' 63 = SOME (w2v ((get_word_binop binop) ((v2w v): 63 word) ((v2w v'): 63 word)), 63) )
/\  (bitv_binop_inner binop v v' 64 = SOME (w2v ((get_word_binop binop) ((v2w v): 64 word) ((v2w v'): 64 word)), 64) )
/\  (bitv_binop_inner binop v v' _ = NONE )
`;
val bitv_binop_def = Define `
  bitv_binop binop (v, n) (v', n') =
    if n = n'
    then bitv_binop_inner binop v v' n
    else NONE
`;

val get_word_binpred_def = Define `
    (get_word_binpred binop_le = word_le)
/\  (get_word_binpred binop_ge = word_ge)
/\  (get_word_binpred binop_lt = word_lt)
/\  (get_word_binpred binop_gt = word_gt)
/\  (get_word_binpred binop_neq = (\w1 w2. ~(w1 = w2)))
/\  (get_word_binpred binop_eq = (\w1 w2. w1 = w2))
`;

val bitv_binpred_inner_def = Define `
    (bitv_binpred_inner binpred v v' 1 = SOME (((get_word_binpred binpred) ((v2w v): 1 word) ((v2w v'): 1 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 2 = SOME (((get_word_binpred binpred) ((v2w v): 2 word) ((v2w v'): 2 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 3 = SOME (((get_word_binpred binpred) ((v2w v): 3 word) ((v2w v'): 3 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 4 = SOME (((get_word_binpred binpred) ((v2w v): 4 word) ((v2w v'): 4 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 5 = SOME (((get_word_binpred binpred) ((v2w v): 5 word) ((v2w v'): 5 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 6 = SOME (((get_word_binpred binpred) ((v2w v): 6 word) ((v2w v'): 6 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 7 = SOME (((get_word_binpred binpred) ((v2w v): 7 word) ((v2w v'): 7 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 8 = SOME (((get_word_binpred binpred) ((v2w v): 8 word) ((v2w v'): 8 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 9 = SOME (((get_word_binpred binpred) ((v2w v): 9 word) ((v2w v'): 9 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 10 = SOME (((get_word_binpred binpred) ((v2w v): 10 word) ((v2w v'): 10 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 11 = SOME (((get_word_binpred binpred) ((v2w v): 11 word) ((v2w v'): 11 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 12 = SOME (((get_word_binpred binpred) ((v2w v): 12 word) ((v2w v'): 12 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 13 = SOME (((get_word_binpred binpred) ((v2w v): 13 word) ((v2w v'): 13 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 14 = SOME (((get_word_binpred binpred) ((v2w v): 14 word) ((v2w v'): 14 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 15 = SOME (((get_word_binpred binpred) ((v2w v): 15 word) ((v2w v'): 15 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 16 = SOME (((get_word_binpred binpred) ((v2w v): 16 word) ((v2w v'): 16 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 17 = SOME (((get_word_binpred binpred) ((v2w v): 17 word) ((v2w v'): 17 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 18 = SOME (((get_word_binpred binpred) ((v2w v): 18 word) ((v2w v'): 18 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 19 = SOME (((get_word_binpred binpred) ((v2w v): 19 word) ((v2w v'): 19 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 20 = SOME (((get_word_binpred binpred) ((v2w v): 20 word) ((v2w v'): 20 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 21 = SOME (((get_word_binpred binpred) ((v2w v): 21 word) ((v2w v'): 21 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 22 = SOME (((get_word_binpred binpred) ((v2w v): 22 word) ((v2w v'): 22 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 23 = SOME (((get_word_binpred binpred) ((v2w v): 23 word) ((v2w v'): 23 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 24 = SOME (((get_word_binpred binpred) ((v2w v): 24 word) ((v2w v'): 24 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 25 = SOME (((get_word_binpred binpred) ((v2w v): 25 word) ((v2w v'): 25 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 26 = SOME (((get_word_binpred binpred) ((v2w v): 26 word) ((v2w v'): 26 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 27 = SOME (((get_word_binpred binpred) ((v2w v): 27 word) ((v2w v'): 27 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 28 = SOME (((get_word_binpred binpred) ((v2w v): 28 word) ((v2w v'): 28 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 29 = SOME (((get_word_binpred binpred) ((v2w v): 29 word) ((v2w v'): 29 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 30 = SOME (((get_word_binpred binpred) ((v2w v): 30 word) ((v2w v'): 30 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 31 = SOME (((get_word_binpred binpred) ((v2w v): 31 word) ((v2w v'): 31 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 32 = SOME (((get_word_binpred binpred) ((v2w v): 32 word) ((v2w v'): 32 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 33 = SOME (((get_word_binpred binpred) ((v2w v): 33 word) ((v2w v'): 33 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 34 = SOME (((get_word_binpred binpred) ((v2w v): 34 word) ((v2w v'): 34 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 35 = SOME (((get_word_binpred binpred) ((v2w v): 35 word) ((v2w v'): 35 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 36 = SOME (((get_word_binpred binpred) ((v2w v): 36 word) ((v2w v'): 36 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 37 = SOME (((get_word_binpred binpred) ((v2w v): 37 word) ((v2w v'): 37 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 38 = SOME (((get_word_binpred binpred) ((v2w v): 38 word) ((v2w v'): 38 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 39 = SOME (((get_word_binpred binpred) ((v2w v): 39 word) ((v2w v'): 39 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 40 = SOME (((get_word_binpred binpred) ((v2w v): 40 word) ((v2w v'): 40 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 41 = SOME (((get_word_binpred binpred) ((v2w v): 41 word) ((v2w v'): 41 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 42 = SOME (((get_word_binpred binpred) ((v2w v): 42 word) ((v2w v'): 42 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 43 = SOME (((get_word_binpred binpred) ((v2w v): 43 word) ((v2w v'): 43 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 44 = SOME (((get_word_binpred binpred) ((v2w v): 44 word) ((v2w v'): 44 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 45 = SOME (((get_word_binpred binpred) ((v2w v): 45 word) ((v2w v'): 45 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 46 = SOME (((get_word_binpred binpred) ((v2w v): 46 word) ((v2w v'): 46 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 47 = SOME (((get_word_binpred binpred) ((v2w v): 47 word) ((v2w v'): 47 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 48 = SOME (((get_word_binpred binpred) ((v2w v): 48 word) ((v2w v'): 48 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 49 = SOME (((get_word_binpred binpred) ((v2w v): 49 word) ((v2w v'): 49 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 50 = SOME (((get_word_binpred binpred) ((v2w v): 50 word) ((v2w v'): 50 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 51 = SOME (((get_word_binpred binpred) ((v2w v): 51 word) ((v2w v'): 51 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 52 = SOME (((get_word_binpred binpred) ((v2w v): 52 word) ((v2w v'): 52 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 53 = SOME (((get_word_binpred binpred) ((v2w v): 53 word) ((v2w v'): 53 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 54 = SOME (((get_word_binpred binpred) ((v2w v): 54 word) ((v2w v'): 54 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 55 = SOME (((get_word_binpred binpred) ((v2w v): 55 word) ((v2w v'): 55 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 56 = SOME (((get_word_binpred binpred) ((v2w v): 56 word) ((v2w v'): 56 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 57 = SOME (((get_word_binpred binpred) ((v2w v): 57 word) ((v2w v'): 57 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 58 = SOME (((get_word_binpred binpred) ((v2w v): 58 word) ((v2w v'): 58 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 59 = SOME (((get_word_binpred binpred) ((v2w v): 59 word) ((v2w v'): 59 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 60 = SOME (((get_word_binpred binpred) ((v2w v): 60 word) ((v2w v'): 60 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 61 = SOME (((get_word_binpred binpred) ((v2w v): 61 word) ((v2w v'): 61 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 62 = SOME (((get_word_binpred binpred) ((v2w v): 62 word) ((v2w v'): 62 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 63 = SOME (((get_word_binpred binpred) ((v2w v): 63 word) ((v2w v'): 63 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 64 = SOME (((get_word_binpred binpred) ((v2w v): 64 word) ((v2w v'): 64 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' _ = NONE )
`;
val bitv_binpred_def = Define `
  bitv_binpred binpred (v, n) (v', n') =
    if n = n'
    then bitv_binpred_inner binpred v v' n
    else NONE
`;
val bitv_concat_def = Define `
  bitv_concat (v, n) (v', n') = (v ++ v', n + n')
`;
(* TODO: Check big-endianness vs. little-endianness (order of arguments of SEG) *)
val bitv_bitslice_def = Define `
  bitv_bitslice (v, n) m l = (SEG m l v, m - l + 1)
`;

val is_var_def = Define `
  (is_var (e_var _) = T) /\
  (is_var _ = F)
`;

(* Extracts the string that represents the variable name from the expression form *)
val extract_string_def = Define `
  extract_string (e_var x) = x
`;

val extract_value_def = Define `
  extract_value (e_v x) = x
`;

(* Finds the topmost scope where the variable x is mapped and its index, as a tuple.
 * Note that here, 0 is the topmost scope. *)
val find_topmost_scope_def = Define `
  find_topmost_scope (sf:scope list) x =
    (INDEX_FIND 0 (\sc. IS_SOME (FLOOKUP sc x)) sf)
`;

(* Extracts the topmost scope where the variable name x is mapped *)
val topmost_scope_def = Define `
  topmost_scope (sf:scope list) x =
    SND (THE (find_topmost_scope sf x))
`;

(* Extracts the index of the topmost scope where the variable name x is mapped *)
val topmost_scope_index_def = Define `
  topmost_scope_index (sf:scope list) x = 
    FST (THE (find_topmost_scope sf x))
`;
(* Fetches the (value, string option) tuple of the variable name x,
 * in the topmost scope where it is mapped *)
val lookup_tup_def = Define `
  lookup_tup (sf:scope list) x =
    THE (FLOOKUP (topmost_scope sf x) x)
`;
(* Fetches the value of the variable name x from the topmost scope where it is mapped *)
val lookup_v_def = Define `
  lookup_v (sf:scope list) x =
    FST (lookup_tup sf x)
`;
(* Fetches the (optional) argument variable name that might have been saved if
 * variable name x was mapped as a result of being an out-parameter in a
 * called function from the topmost scope where x is mapped *)
val lookup_out_def = Define `
  lookup_out (sf:scope list) x =
    SND (lookup_tup sf x)
`;
(* Same as the above, but directly from an expression *)
val lookup_vexp_def = Define `
  lookup_vexp (sf:scope list) e =
    lookup_v (sf:scope list) (extract_string e) 
`;

(* Look up the value of a l-value (variables + fields of struct-valued variables) in
 * the current stack frame sf. *)
val lookup_lval_def = Define `
  (lookup_lval (sf:scope list) (lval_varname x) = (lookup_v sf x)) /\
  (lookup_lval (sf:scope list) (lval_field lval f) = THE (acc_f (lookup_lval sf lval) f))
`;

val is_d_none_in_def = Define `
  (is_d_none_in (d_in _) = T) /\
  (is_d_none_in d_none = T) /\
  (is_d_none_in _ = F)
`;

(* Obtains the minimum index where the direction is "none" or "in" in dlist and the
 * expression in the same position of elist is not a constant, and the corresponding such
 * direction and expression *)
val find_unred_arg_def = Define `
  find_unred_arg dlist elist = 
    (INDEX_FIND 0 (\(d, e). (is_d_none_in d) /\ ~(is_const e)) (ZIP (dlist, elist)))
`;
val unred_arg_index_def = Define `
  unred_arg_index dlist elist  = 
    FST (THE (find_unred_arg dlist elist))
`;

(* Checks if function arguments have been appropriately reduced.
 * In e_func_call_newframe rule, we need this definition to show the second premise *)
val is_arg_red_def = Define `
  is_arg_red d e = 
   ((is_d_none_in d ==> (is_const e)) /\ (~(is_d_none_in d) ==> (is_var e)) = T)
`;
val check_args_red_def = Define `
  check_args_red dlist elist = EVERY (\(d, e). is_arg_red d e) (ZIP(dlist, elist))
`;

(* Given an an expression (should be a e_var or e_v), a direction and a stack frame,
 * creates the proper tuple to be be assigned in the fresh scope created by a function call *)
val one_arg_val_for_newscope_def = Define `
  one_arg_val_for_newscope d e sf =
   if ~(is_d_none_in d)
   then ((lookup_vexp sf e), SOME (extract_string e))
   else (extract_value e, NONE)
`;

(* Fills a fresh scope with the values of the arguments of a called function.
 * Note: used in e_func_call_newframe *)
val all_arg_update_for_newscope_def = Define `
  all_arg_update_for_newscope xlist dlist elist sf = 
    FOLDL (\f (d,x,e). (f |+ (x , one_arg_val_for_newscope d e sf))) FEMPTY (ZIP (dlist, ZIP(xlist:string list, elist)))
`;

(* Updates a stack frame by mapping the variable name a to the value v
 * in the topmost scope where a is defined,
 * written as ε[a -> v], colloquially known as assignment.
 * Note that this function will be used in the assignment and return rules *)
val assign_def = Define `
  assign sf val a =
    LUPDATE
      ((topmost_scope sf a) |+ (a, (val, NONE)))
      (topmost_scope_index sf a)
      sf
`;

(* Given lists of variable names and directions, a caller's stack frame sf
 * and a callees stack frame sf_current, updates the caller's stack frame
 * according to the calling conventions. *)
val update_return_frame_def = Define `
  update_return_frame xlist dlist sf sf_current = 
    FOLDL
      (\sf_temp (x,d).
        if (is_d_none_in d)
        then sf_temp
        else assign sf_temp (lookup_v sf_current x) (THE (lookup_out sf_current x))
      )
      sf
      (ZIP(xlist, dlist))
`;
}}
grammar

defns
  e_stmt_sem :: '' ::=
defn
  [ e ] ( stacks , status ) ~> [ e' ] ( stacks' , status' ) :: :: e_red :: e_
  {{ com expression semantics }}
  %TODO Should use different export homs for LaTeX and HOL4 so that LaTeX hides unnecessary status?
  %{{ tex [ [[e]] ] [[stacks]] \rightsquigarrow [ [[e']] ] [[stacks']] }}
by

%%%%%%%%%%%%%%%%%
%Variable look-up

  v = lookup_vexp ( curr_stack_frame , x )
  ----------------------------------- :: lookup
  [x] ( ( curr_stack_frame, call_stack ) , Running ) ~> [v] ( ( curr_stack_frame, call_stack ) , Running )

%%%%%%%%%%%%%%
%Function call + exec (in expression)

  %Check that all arguments have been reduced
  ( stmt , ( x1 , d1 ) , .. , ( xn , dn ) ) = func_map ( f )
  check_args_red [ d1 , .. , dn ] [ e1 , .. , en ]
  %Build new stack frame
  scope' = all_arg_update_for_newscope ( ( x1 , .. , xn ) , [ d1 , .. , dn ] , [ e1 , .. , en ] , curr_stack_frame )  
  G scope = curr_stack_frame[0]
  curr_stack_frame' = scope' :: [G scope]
  curr_stack_frame'' = tl curr_stack_frame
  call_stack' = ( curr_stack_frame'' , f ) :: call_stack
  ----------------------------------- :: func_call_newframe
  [call f ( e1 , .. , en )] ( ( curr_stack_frame , call_stack ) , Running ) ~> [ exec stmt ] ( ( curr_stack_frame' , call_stack' ) , Running )

  [stmt] ( stacks , Running ) -> [stmt'] ( stacks' , Running )
  ----------------------------------- :: func_exec
  [exec stmt] ( stacks , Running ) ~> [exec stmt'] ( stacks' , Running )

%Note: this rule works together with the "ret" rule in the statement semantics.
%      By the time statement has been reduced to empty_stmt, the stacks have
%      been updated with the effect of the function call on the caller stacks.
  ----------------------------------- :: func_ret
  [exec empty_stmt] ( stacks , Return v ) ~> [v] ( stacks , Running )

%%%%%%%%%%%%%%%%%%%%
%Struct field access

  v = struct { f1 = v1 ; ... ; fn = vn } ( f )
  ----------------------------------- :: s_acc
  [ struct { f1 = v1 ; ... ; fn = vn } . f] ( stacks , Running ) ~> [v] ( stacks , Running )

%%%%%%%%%%%%%%%%%%%%
%Header field access

  v = header boolv { f1 = v1 ; ... ; fn = vn } ( f )
  ----------------------------------- :: h_acc
  [ header boolv { f1 = v1 ; ... ; fn = vn } . f] ( stacks , Running ) ~> [v] ( stacks , Running )

%%%%%%%%%%%%%%%%%%
%Select expression

%Case select lookup
  x' = { v1 : x1 ; ... ; vn : xn } x ( v )
  ----------------------------------- :: sel_acc
  [ select v { v1 : x1 ; ... ; vn : xn } x ] ( stacks , Running ) ~> [ x' ] ( stacks , Running )

%Case default
  v notin { v1 : x1 ; ... ; vn : xn }
  ----------------------------------- :: sel_def
  [ select v { v1 : x1 ; ... ; vn : xn } x ] ( stacks , Running ) ~> [ x ] ( stacks , Running )

%%%%%%%%%%%%%
%"Reduction of argument" rules

%Arguments to function call
  ( stmt , ( x1 , d1 ) , .. , ( xn , dn ) ) = func_map ( f )
  unred_arg_index [ d1 , .. , dn ] [ e1 , .. , en ] = i
  e = [ e1 , .. , en ] [ i ]
  [ e ] ( stacks , Running ) ~> [ e' ] ( stacks' , Running )
  [ e'1 , .. , e'n ] =' update ( e' , i , [ e1 , .. , en ] )
  ----------------------------------- :: func_call_args
  [call f ( e1 , .. , en )] ( stacks , Running ) ~> [call f ( e'1 , .. , e'n )] ( stacks' , Running )

%Struct/header field accesses
%(looks nicer with left-to-right, since we avoid writing out an explicit struct)
  [e'] ( stacks , Running ) ~> [e''] ( stacks' , Running )
  ----------------------------------- :: acc_arg2
  [e . e'] ( stacks , Running ) ~> [e . e''] ( stacks' , Running )

  [e] ( stacks , Running ) ~> [e'] ( stacks' , Running )
  ----------------------------------- :: acc_arg1
  [e . x] ( stacks , Running ) ~> [e' . x] ( stacks' , Running )

%Select
  [e] ( stacks , Running ) ~> [e'] ( stacks' , Running )
  ----------------------------------- :: sel_arg
  [ select e { v1 : x1 ; ... ; vn : xn } x ] ( stacks , Running ) ~> [ select e' { v1 : x1 ; ... ; vn : xn } x ] ( stacks' , Running )

%Unary operations
  [e] ( stacks , Running ) ~> [e'] ( stacks' , Running )
  ----------------------------------- :: unop_arg
  [unop e] ( stacks , Running ) ~> [unop e'] ( stacks' , Running )

%Binary operations
  [e] ( stacks , Running ) ~> [e''] ( stacks' , Running )
  ----------------------------------- :: binop_arg1
  [e binop e'] ( stacks , Running ) ~> [e'' binop e'] ( stacks' , Running )

  [e'] ( stacks , Running ) ~> [e''] ( stacks' , Running )
  ----------------------------------- :: binop_arg2
  [v binop e'] ( stacks , Running ) ~> [e binop e''] ( stacks' , Running )


%%%%%%%%%%%%%%%%%%%
%Unary expressions%
%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%
%Boolean negation

  ! b = b'
  ----------------------------------- :: neg_bool
  [! b] ( stacks , Running ) ~> [b'] ( stacks , Running )

%%%%%%%%%%%%%%%%%%%
%Bitwise complement

  ~ bitv = bitv'
  ----------------------------------- :: compl
  [~ bitv] ( stacks , Running ) ~> [bitv'] ( stacks , Running )

%%%%%%%%%%%%%%%%
%Signed negation

  - bitv = bitv'
  ----------------------------------- :: neg_signed
  [- bitv] ( stacks , Running ) ~> [bitv'] ( stacks , Running )

%%%%%%%%%%%
%Unary plus

  + bitv = bitv'
  ----------------------------------- :: un_plus
  [+ bitv] ( stacks , Running ) ~> [bitv'] ( stacks , Running )


%%%%%%%%%%%%%%%%%%%%
%Binary expressions%
%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%
%Multiplication

  bitv * bitv' = bitv''
  ----------------------------------- :: mul
  [bitv * bitv'] ( stacks , Running ) ~> [bitv''] ( stacks , Running )

%%%%%%%%%%%%%%%
%Division

  bitv / bitv' = bitv''
  ----------------------------------- :: div
  [bitv / bitv'] ( stacks , Running ) ~> [bitv''] ( stacks , Running )

%%%%%%%%%%%%%%%
%Modulo

  bitv mod bitv' = bitv''
  ----------------------------------- :: mod
  [bitv mod bitv'] ( stacks , Running ) ~> [bitv''] ( stacks , Running )

%%%%%%%%%%%%
%Addition

  bitv + bitv' = bitv''
  ----------------------------------- :: add
  [bitv + bitv'] ( stacks , Running ) ~> [bitv''] ( stacks , Running )

%%%%%%%%%%%%
%Subtraction

  bitv - bitv' = bitv''
  ----------------------------------- :: sub
  [bitv - bitv'] ( stacks , Running ) ~> [bitv''] ( stacks , Running )

%%%%%%%%%%%%
%Left shift

  bitv SHL bitv' = bitv''
  ----------------------------------- :: shl
  [bitv SHL bitv'] ( stacks , Running ) ~> [bitv''] ( stacks , Running )

%%%%%%%%%%%%
%Right shift

  bitv SHR bitv' = bitv''
  ----------------------------------- :: shr
  [bitv SHR bitv'] ( stacks , Running ) ~> [bitv''] ( stacks , Running )

%%%%%%%%%%%%%%%%%%%
%Less than or equal

  bitv LE bitv' = b
  ----------------------------------- :: le
  [bitv LE bitv'] ( stacks , Running ) ~> [b] ( stacks , Running )

%%%%%%%%%%%%%%%%%%%%%%
%Greater than or equal

  bitv GE bitv' = b
  ----------------------------------- :: ge
  [bitv GE bitv'] ( stacks , Running ) ~> [b] ( stacks , Running )

%%%%%%%%%%
%Less than

  bitv < bitv' = b
  ----------------------------------- :: lt
  [bitv < bitv'] ( stacks , Running ) ~> [b] ( stacks , Running )

%%%%%%%%%%%%%
%Greater than

  bitv > bitv' = b
  ----------------------------------- :: gt
  [bitv > bitv'] ( stacks , Running ) ~> [b] ( stacks , Running )

%%%%%%%%%%%%%
%Not equal

  bitv NE bitv' = b
  ----------------------------------- :: neq
  [bitv NE bitv'] ( stacks , Running ) ~> [b] ( stacks , Running )

  (x <> x') = b
  ----------------------------------- :: neq_error
  [(errmsg x) NE (errmsg x')] ( stacks , Running ) ~> [b] ( stacks , Running )

%%%%%%%%%%%%%
%Equal

  bitv EQ bitv' = b
  ----------------------------------- :: eq
  [bitv EQ bitv'] ( stacks , Running ) ~> [b] ( stacks , Running )

  (x EQ x') = b
  ----------------------------------- :: eq_error
  [(errmsg x) EQ (errmsg x')] ( stacks , Running ) ~> [b] ( stacks , Running )

%%%%%%%%%%%%%
%Bitwise and

  bitv & bitv' = bitv''
  ----------------------------------- :: and
  [bitv & bitv'] ( stacks , Running ) ~> [bitv''] ( stacks , Running )

%%%%%%%%%%%%%
%Bitwise xor

  bitv ^ bitv' = bitv''
  ----------------------------------- :: xor
  [bitv ^ bitv'] ( stacks , Running ) ~> [bitv''] ( stacks , Running )


%%%%%%%%%%%%%
%Bitwise or

  bitv | bitv' = bitv''
  ----------------------------------- :: or
  [bitv | bitv'] ( stacks , Running ) ~> [bitv''] ( stacks , Running )

%%%%%%%%%%%%%
%Binary and

  b AND b' = b''
  ----------------------------------- :: bin_and
  [b AND b'] ( stacks , Running ) ~> [b''] ( stacks , Running )

%%%%%%%%%%%%%
%Binary or

  b OR b' = b''
  ----------------------------------- :: bin_or
  [b OR b'] ( stacks , Running ) ~> [b''] ( stacks , Running )


%%%%%%%%%%%%%%%%%%%%%%%
% Statement semantics %
%%%%%%%%%%%%%%%%%%%%%%%

%TODO: Block
%TODO: Exit
%TODO: Switch

defn
  [ stmt ] state -> [ stmt' ] state' :: :: stmt_red :: stmt_
  {{ com statement semantics }}
by

%%%%%%%%%%%%%%
%Return

  %TODO: Obtaining stmt and storing f in the call stack not needed?
  ( curr_stack_frame' , f ) :: call_stack' = call_stack
  ( stmt , ( x1 , d1 ) , .. , ( xn , dn ) ) = func_map ( f )
  G scope = curr_stack_frame [ 0 ]
  curr_stack_frame'' = ( curr_stack_frame' ) ++ ( [ G scope ] )
  curr_stack_frame''' = update_return ( curr_stack_frame , curr_stack_frame'' , [ d1 , .. , dn ] , ( x1 , .. , xn ) )
  ----------------------------------- :: ret
  [return v] ( ( curr_stack_frame , call_stack ) , Running ) -> [empty_stmt] ( ( curr_stack_frame''' , call_stack' ) , Return v )

%%%%%%%%%%%%%%
%Assignment

  %Assign a constant to a variable
  curr_stack_frame' = assign ( curr_stack_frame , v , x )
  ----------------------------------- :: ass_v
  [assign x v] ( ( curr_stack_frame , call_stack ) , Running ) -> [empty_stmt] ( ( curr_stack_frame' , call_stack ) , Running )

  %Assign to a struct field
  struct { f1 = v1 ; ... ; fn = vn } = lookup_lval ( curr_stack_frame , lval )
  v'' = ( struct { f1 = v1 ; ... ; fn = vn } with f := v )
  ----------------------------------- :: ass_s
  [assign ( lval . f ) v] ( ( curr_stack_frame , call_stack ) , Running ) -> [assign lval  v''] ( ( curr_stack_frame , call_stack ) , Running )

  %Assign to a header field
  header boolv { f1 = v1 ; ... ; fn = vn } = lookup_lval ( curr_stack_frame , lval )
  v'' = ( header boolv { f1 = v1 ; ... ; fn = vn } with f := v )
  ----------------------------------- :: ass_h
  [assign ( lval . f ) v] ( ( curr_stack_frame , call_stack ) , Running ) -> [assign lval  v''] ( ( curr_stack_frame , call_stack ) , Running )

  %Assign to null
  %Note: This is be used to model function calls as an expression.
  ----------------------------------- :: ass_null
  [assign null v] ( ( curr_stack_frame , call_stack ) , Running ) -> [empty_stmt] ( ( curr_stack_frame , call_stack ) , Running )


%%%%%%%%%%%%%%
%Sequence

  [stmt1] ( stacks , Running ) -> [stmt1'] ( stacks' , Running )
  ----------------------------------- :: seq1
  [stmt1 ; stmt2] ( stacks , Running ) -> [stmt1' ; stmt2] ( stacks' , Running )

  ----------------------------------- :: seq2
  [empty_stmt ; stmt] ( stacks , Running ) -> [stmt] ( stacks , Running )

  [stmt1] ( stacks , Running ) -> [stmt1'] ( stacks' , Return v )
  ----------------------------------- :: seq3
  [stmt1 ; stmt2] ( stacks , Running ) -> [ empty_stmt ] ( stacks' , Return v )

%%%%%%%%%%%%%%
%Conditional

  ----------------------------------- :: cond2
  [if true then stmt1 else stmt2] ( stacks , Running ) -> [stmt1] ( stacks , Running )

  ----------------------------------- :: cond3
  [if false then stmt1 else stmt2] ( stacks , Running ) -> [stmt2] ( stacks , Running )

%%%%%%%%%%%%%%
%Declaration

  length ( curr_stack_frame ) = i
  scope = curr_stack_frame [ i ]
  curr_stack_frame' = update ( scope + [ x |-> uninit ] , i , curr_stack_frame )
  ----------------------------------- :: decl
  [decl x t] ( ( curr_stack_frame , call_stack ) , Running ) -> [empty_stmt] ( ( curr_stack_frame' , call_stack ) , Running )


%%%%%%%%%%%%%%
%Block

  curr_stack_frame' = emptyscope :: curr_stack_frame
  ----------------------------------- :: block_enter
  [begin stmt end] ( ( curr_stack_frame , call_stack ) , Running ) -> [begin' stmt end'] ( ( curr_stack_frame' , call_stack ) , Running )

  [stmt] ( stacks , Running ) -> [stmt'] ( stacks' , Running )
  ----------------------------------- :: block_exec
  [begin' stmt end'] ( stacks , Running ) -> [begin' stmt' end'] ( stacks' , Running )

  curr_stack_frame' = tl curr_stack_frame
  ----------------------------------- :: block_exit
  [begin' empty_stmt end'] ( ( curr_stack_frame , call_stack ) , Running ) -> [empty_stmt] ( ( curr_stack_frame' , call_stack ) , Running )

%%%%%%%%%%%%%%
%Verify

%Case predicate holds
  ------------------------------------------------- :: verify_3
  [verify true ( errmsg x )]( stacks , Running ) -> [empty_stmt]( stacks' , Running )

%Case predicate does not hold
  %TODO: This assumption needed since we don't have string literals yet
  x' = parseError
  x'' = "reject"
  ------------------------------------------------- :: verify_4
  [verify false ( errmsg x )]( stacks , Running ) -> [ assign x' ( errmsg x ) ; transition x'' ]( stacks' , Running )

%%%%%%%%%%%%%%
%Transition

  not_final_state ( x )
  ------------------------------------------------- :: trans_1
  [transition x]( stacks , Running ) -> [empty_stmt]( stacks , Trans x )

  x = "accept"
  ------------------------------------------------- :: trans_2
  [transition x]( stacks , Running ) -> [empty_stmt]( stacks , Accept )

  x = "reject"
  ------------------------------------------------- :: trans_3
  [transition x]( stacks , Running ) -> [empty_stmt]( stacks , Reject )


%%%%%%%%%%%%%%
%Exit

  %TODO: Exit semantics might require to have a specific "function-in-progress" statement
  %      in order to know what to reduce to nothing.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     Match-Action rules       %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  %Apply table name and reduce the expression
  [e] ( stacks , Running ) ~> [e'] ( stacks' , Running )
  ----------------------------------- :: apply_table_e
  [apply table_name e] ( stacks , Running ) -> [apply table_name e'] ( stacks' , Running )

  %The action is treated as a function call
  t_map (table_name) = ( e' , match_kind )
  ctrl ( table_name , v , match_kind ) = ( f , ( v1 , .. , vn ) )
  ----------------------------------- :: apply_table_v
  [apply table_name v] ( stacks , Running ) -> [assign null ( call f ( v1 , .. , vn ) )] ( stacks' , Running )

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Reduction of expression rules %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%Reduction step of return expression
  [e] ( stacks , Running ) ~> [e'] ( stacks' , Running )
  ----------------------------------- :: ret_e
  [return e] ( stacks , Running ) -> [return e'] ( stacks' , Running )

%Reduction step of assign expression
  [e] ( stacks , Running ) ~> [e'] ( stacks' , Running )
  ----------------------------------- :: ass_e
  [assign x e] ( stacks , Running ) -> [assign x e'] ( stacks' , Running )

%Reduction step of condition
  [e] ( stacks , Running ) ~> [e'] ( stacks' , Running )
  ----------------------------------- :: cond_e
  [if e then stmt1 else stmt2] ( stacks , Running ) -> [if e' then stmt1 else stmt2] ( stacks' , Running )

%Reduction step of verify predicate
  [e] ( stacks , Running ) ~> [e''] ( stacks' , Running )
  ------------------------------------------------- :: verify_e1
  [verify e e' ]( stacks , Running ) -> [verify e'' e']( stacks' , Running )

%Reduction step of error message
  [e] ( stacks , Running ) ~> [e'] ( stacks' , Running )
  ------------------------------------------------- :: verify_e2
  [verify b e]( stacks , Running ) -> [verify b e']( stacks' , Running )

%Reduction step of transition
  [e] ( stacks , Running ) ~> [e'] ( stacks' , Running )
  ------------------------------------------------- :: trans_e
  [transition e]( stacks , Running ) -> [transition e']( stacks' , Running )


%%%%%%%%%%%%%%%%%%%%
% Parser semantics %
%%%%%%%%%%%%%%%%%%%%
%This isolates the unstructured parser semantics into a set of rules defined in terms
%of the regular statement semantics.

defns
  pars_sem :: '' ::=
defn
  [ stmt ] state --> [ stmt' ] state' :: :: pars_red :: pars_
  {{ com parser semantics }}
by

  [stmt]( stacks , Running ) -> [stmt']( stacks' , Running )
  ------------------------------------------------- :: stmt
  [stmt]( stacks , Running ) --> [stmt']( stacks' , Running )

  [stmt]( stacks , Running ) -> [stmt']( stacks' , Trans x )
  stmt'' = pars_map ( x )
  ------------------------------------------------- :: state
  [stmt]( stacks , Running ) --> [stmt'']( stacks' , Running )

%If the end of some parser state is reached without status change, we reject
  [stmt]( stacks , Running ) -> [empty_stmt]( stacks' , Running )
  x = "reject"
  ------------------------------------------------- :: empty
  [stmt]( stacks , Running ) --> [transition x]( stacks' , Running )

defns
  pars_t_sem :: '' ::=
defn
  [ stmt ] state --> state' :: :: pars_t_red :: pars_t_
  {{ com parser semantics, final step }}
by

  [stmt]( stacks , Running ) -> [stmt']( stacks , pars_fin )
  ------------------------------------------------- :: fin
  [stmt]( stacks , Running ) --> ( stacks , pars_fin )
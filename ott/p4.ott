embed
{{ hol
open bitstringTheory;
open wordsTheory;
}}

%%%%%%%%%%%%%%%%%
% P4 base types %
%%%%%%%%%%%%%%%%%

%x denotes variable name, f denotes field name or function name
metavar x, f, a, tbl ::=
      {{ lex alphanum }}
      {{ hol string }}
      {{ tex [[x]] }}
      {{ com string }}

%TODO Numeral or alphanum?
metavar b ::=
      {{ lex numeral }}
      {{ hol bool }}
      {{ tex [[b]] }}
      {{ com boolean }}
metavar bl ::=
      {{ lex numeral }}
      {{ hol bool list }}
      {{ tex [[bl]] }}
      {{ com bit-string }}
    

%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Auxiliary metavariables %
%%%%%%%%%%%%%%%%%%%%%%%%%%%

metavar i ::=
      {{ lex numeral }}
      {{ hol num }}
      {{ tex [[i]] }}
      {{ com natural number }}
indexvar m, n, o ::=
  {{ lex numeral }}
  {{ coq nat }}
  {{ hol num }}
  {{ com indices }}


grammar

%%%%%%%%%%%%%%%%
% Value syntax %
%%%%%%%%%%%%%%%%

boolv :: boolv_ ::=
{{ hol bool }}
{{ com boolean }}
| true :: M :: true
  {{ hol T }}
| false :: M :: false
  {{ hol F }}
| b :: M :: free
  {{ hol [[b]] }}

bitv :: bitv_ ::=
{{ hol (bl # num) }}
{{ com bit-string }}
| bl n :: M :: bl
  {{ hol ([[bl]], [[n]]) }}

%Fence so that ott does not put packet_in before boolv
embed
{{ hol

}}
grammar

packet_in :: packet_in_ ::=
{{ hol (boolv list) }}
{{ com input packet }}
| [ boolv1 , .. , boolvn ] :: M :: list
  {{ hol ([[boolv1 .. boolvn]]) }}

packet_out :: packet_out_ ::=
{{ hol (boolv list) }}
{{ com output packet }}
| [ boolv1 , .. , boolvn ] :: M :: list
  {{ hol ([[boolv1 .. boolvn]]) }}

ipv4_checksum :: ipv4_checksum_ ::= {{ hol (word16) }}
{{ com ipv4 header checksum }}

%TODO: This should be expanded to cover data of all extern objects
%TODO: Only stuff in core.p4, for now... Should this be polymorphic when done for multiple platforms?
ext_obj :: ext_obj_ ::=
{{ com extern object }}
| packet_in :: :: in
  {{ com input packet }}
| packet_out :: :: out
  {{ com input packet }}
| ipv4_checksum :: :: ck
  {{ com ipv4 header checksum }}


%TODO: Add identifiers
%TODO: Add enums
v :: v_ ::=
{{ com constant }}
| boolv :: :: bool
  {{ com boolean value }}
%bitv currently represents both signed and unsigned bit-strings
| bitv :: :: bit
  {{ com bit-string }}
| x :: :: str
  {{ com string literal }} 
| struct { x1 = v1 ; ... ; xn = vn } :: :: struct
  {{ com struct }} %TODO: Ott User Guide 12.2  List comprehension forms
| header boolv { x1 = v1 ; ... ; xn = vn } :: :: header
% A header is like a struct, but with a validity bit.
% Headers also have different well-formedness conditions (for example, headers cannot be nested).
%TODO: We must have the following header methods:
%      isValid()
%      setValid()
%      setInvalid()
%      Should these be modeled as statements, or should they
%      be pre-set in the function map?
  {{ com header }}
| ext_obj :: :: ext
  {{ com extern object }}
| errmsg x :: :: err
  {{ com error message }}
%TODO: Represent uninitialised variables? Default values?
%See https://p4lang.github.io/p4-spec/docs/P4-16-v1.2.2.html#sec-uninitialized-values-and-writing-invalid-headers
| uninit :: :: uninit
  {{ com uninitialized value }}
  {{ tex ? }}
  {{ hol (ARB) }}
| bot :: :: bot
  {{ com no value }}


varn :: varn_ ::=
| x :: :: name
  {{ com variable name }}
| star :: :: star 
  {{ com function return placeholder }}
| ext_ret :: :: ext_ret
  {{ com extern return variable }}

%TODO: Add array element
%TODO: Add bitslice
lval :: lval_ ::=
| varn :: :: varname
  {{ com variable name }}
| null :: :: null
  {{ com null variable }} 
| lval . f :: :: field
  {{ com field access }}
| ( lval ) :: X :: paren
  {{ hol ([[lval]]) }}

%%%%%%%%%%%%%%%%%%%
% Execution state %
%%%%%%%%%%%%%%%%%%%
%Note that this is not part of the P4 specification, but made up for verification purposes.

pars_fin {{ tex p_{ \mathrm{fin} } }} :: pars_fin ::=
{{ com final parser states }}
| Accept :: :: accept
  {{ com accepted state }}
  {{ tex { \mathbf{acc} } }}
| Reject :: :: reject
  {{ com rejected state }}
  {{ tex { \mathbf{rej} } }}

pars_next {{ tex p }} :: pars_next_ ::=
{{ com parser next state }}
| Trans x :: :: trans
  {{ com transition to named state }}
  {{ tex { \mathbf{tra} \; x } }}
| pars_fin :: :: pars_fin
  {{ com final state }}

%Execution status of current programmable block
status {{ tex t }}:: status_ ::=
{{ com execution status }}
| Running :: I :: running
  {{ tex { \mathbf{run} } }}
| Ret v :: I :: returnv
  {{ tex { \mathbf{ret} \, v } }}  
| pars_next :: I :: pars_next
| TypeError :: I :: type_error
  {{ tex { \bot } }}

scope {{ tex \gamma }} :: scope_ ::=
{{ hol (varn |-> (v # lval option)) }}
{{ com frame/variable environment of current scope }}
| emptyscope :: M :: empty
  {{ com empty stack frame }}
  {{ hol FEMPTY }}
  {{ tex {\gamma}_{ \emptyset } }}
%TODO: This should keep output parameter instead of requiring NONE
| scope + [ varn |-> ( v , NONE ) ] :: M :: update
  {{ com update variable mapping }}
  {{ hol (FUPDATE [[scope]] ([[varn]], ( [[v]] , NONE ))) }}
  {{ tex ([[varn]] \mapsto  [[v]]) [[scope]] }}
%TODO: Update or remove this production
| scope ++ [ varn1 |-> v1 , .. , varnn |-> vn ] :: M :: update_list
  {{ com update variable mapping }}
  {{ hol (FUPDATE_LIST [[scope]] [[varn1 v1 .. varnn vn]]) }}
  %TODO: The below is a hack since LaTeX cannot interpret dot form...
  {{ tex \forall i \leq n. \,\, (x_i \mapsto  \mathit{v}_i) \,\, [[scope]] }}
| ( scope ) :: S :: paren
  {{ hol ([[scope]]) }}
  {{ tex  [[scope]] }}

g_scope {{ tex \gamma_G }} :: g_scope_ ::=
{{ com global scope}}
{{ hol scope}}
| scope :: M :: global
  {{ hol ([[scope]]) }}

%Fence so that ott does not re-order g_scope_list
embed
{{ hol

}}
grammar

g_scope_list {{ tex {\gamma}_L }} :: g_scope_list_ ::=
{{ hol (scope list) }}
{{ com list of global scopes }}
| [ g_scope ]' :: M :: one
  {{ com 1 global scope }}
  {{ hol ([ [[g_scope]] ]) }}
  {{ tex [ [[g_scope]] ] }}
| [ g_scope ; g_scope' ] :: M :: two
  {{ com 2 global scopes }}
  {{ hol ([ [[g_scope]] ; [[g_scope']] ]) }}
  {{ tex [ [[g_scope]], [[g_scope']] ] }}

%Fence so that ott does not re-order scopes_stack
embed
{{ hol

}}
grammar

scopes_stack {{ tex \overrightarrow{\gamma} }} :: scopes_stack_ ::=
{{ hol (scope list) }}
{{ com stack of block scopes }}
| emptyss :: M :: empty
  {{ hol ([]:scope list) }}
  {{ tex {\emptyset}_{\varepsilon} }}
| [ scope1 , .. , scopen ] :: M :: list
  {{ hol ([[scope1 .. scopen]]) }}
| tl scopes_stack :: M :: tl
  {{ hol (TL [[scopes_stack]]) }}
  {{ tex \mathrm{tl} [[scopes_stack]] }}
| g_scope '::' scopes_stack' :: M :: cons
  {{ hol ([[g_scope]] :: [[scopes_stack']]) }}
  {{ tex [[g_scope]] :: [[scopes_stack']] }}
| scopes_stack ++ scopes_stack' :: M :: append
  {{ hol ([[scopes_stack]] ++ [[scopes_stack']]) }}
  {{ tex [[scopes_stack]] \mathrel{\mathop+}+ [[scopes_stack']] }}
| rev scopes_stack :: M :: rev
  {{ hol (REVERSE [[scopes_stack]]) }}
  {{ tex \mathrm{rev} ([[scopes_stack]]) }}
| update ( scope , i , scopes_stack ) :: M :: update_scope
  {{ com update a scope in the stack frame }}
  {{ hol ( LUPDATE [[scope]] [[i]] [[scopes_stack]] ) }}
  {{ tex ([[i]] \mapsto [[scope]]) [[scopes_stack]] }}
%TODO: Hack to make you able to concatenate g_scope_lists and scope_stacks
| g_scope_list :: M :: g_scope_list
  {{ com g_scope_list }}
  {{ hol ( [[g_scope_list]] ) }}
  {{ tex [[g_scope_list]] }}
| ( scopes_stack ) :: S :: paren
  {{ hol ([[scopes_stack]]) }}

embed
{{ hol

}}
grammar

mk {{ tex \mathit{mk} }} :: mk_ ::=
{{ com matching kinds }}
| exact :: :: exact
  {{ tex exact }}
| ternary :: :: ternary
  {{ tex ternary }}
| lpm :: :: lpm
  {{ tex lpm }}

%Fence so that ott does not re-order expression syntax with state syntax
embed
{{ hol

}}
grammar

%%%%%%%%%%%%%%%%%%%%%
% Expression syntax %
%%%%%%%%%%%%%%%%%%%%%

unop {{ tex \ominus }}:: unop_ ::=
| ! :: :: neg
  {{ com negation }}
  {{ tex ! }}
| ~ :: :: compl
  {{ com bitwise complement }}
  {{ tex \neg }}
| - :: :: neg_signed
  {{ com signed negation }}
| + :: :: un_plus
  %Defined as no-op for all values in P4 spec
  {{ com unary plus }}

%Binary operations
%TODO: Split these up into operations (bv # bv -> bv) and predicates (bv # bv -> bool)?
%TODO: Add saturating addition
%TODO: Add saturating subtraction
binop {{ tex \oplus }} :: binop_ ::=
| * :: :: mul
  {{ com multiplication }}
  {{ tex \times }}
| / :: :: div
  {{ com division }}
| mod :: :: mod
  %Denoted by % in P4 spec
  {{ com modulo }}
  {{ tex \bmod }}
| + :: :: add
  {{ com addition }}
| - :: :: sub
  {{ com subtraction }}
| SHL :: :: shl
  {{ com logical left-shift }}
  {{ tex \ll }}
| SHR :: :: shr
  {{ com logical right-shift }}
  {{ tex \gg }}
| LE :: :: le
  {{ com less or equal }}
  {{ tex \leq }}
| GE :: :: ge
  {{ com greater or equal }}
  {{ tex \geq }}
| < :: :: lt
  {{ com less }}
  {{ tex < }}
| > :: :: gt
  {{ com greater }}
  {{ tex > }}
| NE :: :: neq
  {{ com not equal }}
  {{ tex \neq }}
| EQ :: :: eq
  {{ com equal }}
  {{ tex = }}
| & :: :: and
  {{ com bitwise and }}
| ^ :: :: xor
  {{ com bitwise xor }}
  {{ tex \underline{\vee} }}
| '|' :: :: or
  {{ com bitwise or }}
  {{ tex \mid }}
| AND :: :: bin_and
  {{ com binary and }}
  {{ tex \land }}
| OR :: :: bin_or
  {{ com binary or }}
  {{ tex \lor }}

%An abstract function or extern method/function name
funn :: funn_ ::=
| f :: :: name
  {{ com function name }}
| inst f :: :: inst
  {{ com extern object instantiation }}
| f f' :: :: ext
  {{ com extern method call }}

%TODO: Add casts
%TODO: Add tuples
%TODO: Add conditional operator
e :: e_ ::=
{{ com expression }}
| v :: :: v
  {{ com constant value }}
| var varn :: :: var
  {{ com variable }}
| { e1 , .. , en } :: :: list
  {{ com expression list }}
| e . e' :: :: acc
  {{ com field access }}
| unop e :: :: unop
  {{ com unary operation }}
  {{ tex [[unop]] [[e]] }}
| e1 binop e2 :: :: binop
  {{ com binary operation }}
  {{ tex [[e1]] [[binop]] [[e2]] }}
| concat e1 e2 :: :: concat
  {{ com concatenation of bit-strings }}
| e1 [ e2 : e3 ] :: :: slice
  {{ com bit-slice }}
| call funn ( e1 , .. , en ) :: :: call
  {{ com function or extern call }}
| select e { v1 : x1 ; ... ; vn : xn } x :: :: select
  %TODO: x is the default value of select expression, which should be optional
  {{ com select }}
| ( e ) :: S :: paren
  {{ hol ([[e]]) }}

%TODO: Trying to make a new definition for expression lists (mainly for function
%      arguments) proved problematic.
%      If all e_list productions are meta, then you get e_list as a type abbreviation of "e list",
%      which is either undefined at the point where the abbreviation is made, or
%      e_list is unknown when defining e (and specifically function call, which would use e_list).
%      In both situations, mutually recursive definitions are not possible.
%
%      If nothing is meta and e_list is not exported to a type abbreviation, you risk the function call semantics not understanding the "e_list" and "e list" correspondence. However, this seems to work currently.
e_list :: e_list_ ::=
{{ com list of expressions }}
{{ hol (e list) }}
| empty_el :: M :: empty
  {{ com empty expression list }}
  {{ hol ([]:e list) }}
| e1 , .. , en :: M :: exps
  {{ com list of expressions }}
  {{ hol ([[e1 .. en]]) }}
| e '::' e_list :: M :: cons
  {{ com cons }}
  {{ hol ([[e]]::[[e_list]]) }}
| tl e_list :: M :: tail
  {{ com tail }}
  {{ hol (TL [[e_list]]) }}
| [ e1 , .. , en ] :: M :: exps2
  {{ com bracketed list of expressions }}
  {{ hol ([[e1 .. en]]) }}
| e_list ++ e_list' :: M :: append
  {{ com append two expression lists }}
  {{ hol ([[e_list]] ++ [[e_list']]) }}
| update ( e , i , e_list ) :: M :: update
  {{ com update entry of expression list }}
  {{ hol (LUPDATE [[e]] [[i]] [[e_list]]) }}
  {{ tex ([[i]] \mapsto  [[e]]) [[e_list]] }}
| ( e_list ) :: S :: paren
  {{ hol ([[e_list]]) }}

init_opt :: init_opt_ ::=
{{ com optional initializer }}
{{ hol (e option) }}
| e :: M :: some
  {{ com initializer }}
  {{ hol (SOME [[e]]) }}
%TODO: Choose notation
| - :: M :: none
  {{ com no initializer }}
  {{ hol (NONE:e option) }}

%%%%%%%%%%%%%%
% Statements %
%%%%%%%%%%%%%%

bt {{ tex bt }} :: bt_ ::=
{{ com base types }}
| bool_t :: :: bool
  {{ tex { \mathrm{bool}_{ \mathrm{t} } } }}
| bit_t :: :: bit
  {{ tex { \mathrm{bit}_{ \mathrm{t} } } }}

t {{ tex t }} :: t_ ::=
{{ com types }}
| bt :: :: base
| struct_t t1 , ... , tn :: :: struct
  {{ tex { \mathrm{struct}_{ \mathrm{t} }\,\, t_1 , \ldots , t_n } }}
| header_t t1 , ... , tn :: :: header
  {{ tex { \mathrm{header}_{ \mathrm{t} }\,\, t_1 , \ldots , t_n } }}
%TODO: are all extern objects that are declared done so using constructors?
| extt :: :: ext
  {{ tex \mathrm{ext} }}

%Fence between ctrl and e_list
embed
{{ hol

}}
grammar

% TODO: Could be just a type abbreviation?
ctrl {{ tex { C } }} :: ctrl_ ::=
{{ com control plane }}
{{ hol ((string # v # mk) -> (string # e_list) option) }}
| empty :: M :: empty
  {{ com empty table map }}
  %TODO: Correct? How does this affect export?
  {{ hol FEMPTY }}

%Fence between ctrl and state
embed
{{ hol

}}
grammar

%ext updates the scope stack, global scope list and ctrl directly.
%Note that at the time this happens, a new frame has already been declared for ext. 
ext {{ tex { \mathit{ext} } }} :: ext_ ::=
{{ hol ((g_scope_list # scopes_stack # ctrl) -> ((g_scope_list # scopes_stack # ctrl) option)) }}

%Fence between ext and ext_map
embed
{{ hol

}}
grammar

%TODO: Add switch statement
stmt :: stmt_ ::=
{{ com statement }}
| empty_stmt :: :: empty
  {{ com empty statement }}
  {{ tex \emptyset_{ \mathrm{stmt} } }}
| assign lval e :: :: ass
  {{ com assignment }}
  {{ tex [[lval]] \mathrel{\mathop:}= [[e]] }}
| if e then stmt1 else stmt2 :: :: cond
  {{ com conditional }}
| decl t x init_opt :: :: declare
  %TODO: This should have a type name instead of a type t, which is then looked up in the type environment.
  {{ com declaration }}
| begin stmt end :: :: block
  {{ com block }}
  {{ tex \{ [[stmt]] \} }}
| begin' stmt end' :: I :: block_ip
  {{ com block in progress }}
  {{ tex [ [[stmt]] ] }}
| return e :: :: ret
  {{ com return }}
| stmt1 ; stmt2 :: :: seq
  {{ com sequence }}
| verify e e' :: :: verify
  %e is predicate, e' is error message
  {{ com verify }}
| transition e :: :: trans
  %e should evaluate to a parser state name
  {{ com transition }}
  {{ tex \mathbf{transition}\, [[e]] }}
| apply tbl e :: :: app
  %tbl is the table name that should be applied
  {{ com apply }}
  {{ tex \mathbf{apply} \, [[tbl]] \, [[e]] }}
| ext :: :: ext
  {{ com extern function }}
  {{ tex \blacksquare  }}

frame {{ tex \Phi }} :: frame_ ::=
{{ com contains the current function name, stmt and local scope stack }}
{{ hol (funn # stmt # scopes_stack) }}
| ( funn , stmt , scopes_stack ) :: M :: tup
 {{ hol ([[funn]] , [[stmt]] , [[scopes_stack]]) }}
 {{ tex ( {[[stmt]])}_{[[scopes_stack]]}^{[[funn]]} }}

%Fence between frame and frame_list
embed
{{ hol

}}
grammar

frame_list {{ tex \overrightarrow{\Phi} }} :: frame_list_ ::=
{{ hol (frame list) }}
{{ com list of frame tuples }}
| empty :: M :: empty
  {{ hol ([]:frame list) }}
  {{ tex [ \, ] }}
| [ frame ] :: M :: sing
  {{ hol ([ [[frame]] ]) }}
  {{ tex [ [[frame]] ] }}    
| frame '::' frame_list :: M :: cons
  {{ hol ([[frame]] :: [[frame_list]]) }}
  {{ tex [[frame]] :: [[frame_list]] }}    
| frame_list ++ frame_list' :: M :: app
  {{ hol ([[frame_list]] ++ [[frame_list']]) }}
  {{ tex [[frame_list]] {+}\mspace{-8mu}{+} [[frame_list']] }} 
| tl frame_list :: M :: tl
  {{ hol (TL [[frame_list]]) }}
  {{ tex \mathrm{tl} ([[frame_list]]) }}
| ( frame_list ) :: M :: paren
  {{ hol ([[frame_list]]) }}
  {{ tex [[frame_list]] }}

state {{ tex \sigma }} :: state_ ::=
{{ hol (g_scope_list # frame_list # ctrl # status) }}
{{ com execution state }}
| ( g_scope_list , frame_list , ctrl , status ) :: M :: tup
{{ hol ([[g_scope_list]], [[frame_list]], [[ctrl]], [[status]]) }}

d {{ tex d }} :: d_ ::=
{{ com parameter direction }}
| 'in :: :: in
  {{ tex \downarrow }}
| out :: :: out
  {{ tex \uparrow }}
| inout :: :: inout
  {{ tex \updownarrow }}
| none :: :: none
  {{ tex \circ }}

%The "fixed function" of a fixed-function block
ff {{ tex { \mathit{ff} } }} :: ff_ ::=
{{ hol ((e list # scope) -> scope option) }}

%Fence between d and d_list
embed
{{ hol

}}
grammar

d_list :: d_list_ ::=
{{ com list of directions }}
{{ hol (d list) }}
| empty_el :: M :: empty
  {{ com empty direction list }}
  {{ hol ([]:d list) }}
| [ d1 , .. , dn ] :: M :: ds
  {{ com list of directions }}
  {{ hol ([[d1 .. dn]]) }}
| ( d_list ) :: S :: paren
  {{ hol ([[d_list]]) }}
| d_list ++ d_list' :: M :: append
  {{ com append two e_lists }}
  {{ hol ([[d_list]] ++ [[d_list']]) }}

func_map {{ tex F }} :: func_map_ ::=
{{ com function map  }}
{{ hol (string |-> (stmt # (string # d) list)) }}
| empty :: M :: empty
  {{ com empty function map }}
  {{ hol FEMPTY }}
| func_map + [ x |-> stmt ] :: M :: update
  {{ com update variable mapping }}
  {{ hol (FUPDATE [[func_map]] ([[x]], [[stmt]])) }}

%This maps extern function names of an individual object obj to their implementations
%Note that the body of the extern is stmt in order to accommodate return by using return statements
ext_fun_map {{ tex X_{ \mathit{obj} } }} :: ext_fun_map_ ::=
{{ com extern function map }}
{{ hol (string |-> (stmt # (string # d) list)) }}

%Fence between ext_fun_map and ext_map
embed
{{ hol

}}
grammar

%This maps extern object names to tuples of constructors and their respective function maps
ext_map {{ tex X }} :: ext_map_ ::=
{{ com extern object map }}
{{ hol (string |-> (((stmt # (string # d) list) option) # ext_fun_map)) }}

% TODO: Could be just a type abbreviation?
tbl_map {{ tex { \mathit{Tb} } }} :: tbl_map_ ::=
{{ com table map  }}
{{ hol (string |-> (e # mk)) }}
| empty :: M :: empty
  {{ com empty table map }}
  {{ hol FEMPTY }}

% TODO: Could be just a type abbreviation?
pars_map {{ tex P }} :: pars_map_ ::=
{{ com parser state map  }}
{{ hol (string |-> stmt) }}
| empty :: M :: empty
  {{ com empty parser state map }}
  {{ hol FEMPTY }}

% TODO: Could be just a type abbreviation?
ty_map {{ tex \mathit{Ty} }} :: ty_map_ ::=
{{ com type environment  }}
{{ hol (string |-> ((string # t) list)) }}
| empty :: M :: empty
  {{ com empty type environment }}
  {{ hol FEMPTY }}

in_out :: in_out_ ::=
{{ com input and output }}
{{ hol (bl # num) }}
| packet bl i :: M :: packet
  {{ hol ( [[bl]] , [[i]] ) }}

%Fence so that ott does not re-order block and block map
embed
{{ hol

}}
grammar

arch_frame_list :: arch_frame_list_ ::=
{{ com architecture-level frame list }}
%TODO Weird name is to avoid multiple parses with nested types (frame_list)
| arch_frame_list_empty :: :: empty
  {{ com empty architecture-level frame list }}
| frame_list :: :: regular
  {{ com regular frame list }}
| pbl_call f ( e1 , .. , en ) :: :: pbl_call
  {{ com programmable block call }}
| ffbl_call f ( e1 , .. , en ) :: :: ffbl_call
  {{ com fixed-function block call }}

pblock {{ tex { \mathit{ pblock } } }} :: pblock_ ::=
{{ com programmable block }}
| parser ( ( x1 , d1 ) , .. , ( xn , dn ) ) stmt pars_map :: :: parser
| control ( ( x1 , d1 ) , .. , ( xn , dn ) ) stmt stmt' tbl_map :: :: control

ffblock {{ tex { \mathit{ ffblock } } }} :: ffblock_ ::=
{{ com fixed-function block }}
%{{ hol (ff # (string # d) list) }}
| ff ( ( x1 , d1 ) , .. , ( xn , dn ) ) :: :: ff
%  {{ com fixed-function block }}
%  {{ hol ( [[ff]] , ()) }}

%Fence so that ott does not re-order ffblock
embed
{{ hol

}}
grammar

arch_block :: arch_block_ ::=
{{ com architectural block }}
| inp :: :: inp
| pbl x ( e1 , .. , en ) :: :: pbl
| ffbl x ( e1 , .. , en ) :: :: ffbl
| out :: :: out

% TODO: Could be just a type abbreviation?
pblock_list {{ tex \overline{pb} }} :: pblock_list_ ::=
{{ com list of programmable blocks }}
{{ hol (pblock list) }}
| empty_pbl :: M :: empty
  {{ hol ([]:pblock list) }}

% TODO: Could be just a type abbreviation?
ffblock_list {{ tex \overline{ffb} }} :: ffblock_list_ ::=
{{ com list of fixed-function blocks }}
{{ hol (ffblock list) }}
| empty_ffbl :: M :: empty
  {{ hol ([]:ffblock list) }}

pblock_map {{ tex B_{ \mathit{p} } }} :: pblock_map_ ::=
{{ com programmable block map }}
{{ hol (string |-> pblock) }}
| empty :: M :: empty
  {{ com empty programmable block map }}
  {{ hol FEMPTY }}

ffblock_map {{ tex B_{ \mathit{ff} } }} :: ffblock_map_ ::=
{{ com fixed-function block map }}
{{ hol (string |-> ffblock) }}
| empty :: M :: empty
  {{ com empty fixed-function block map }}
  {{ hol FEMPTY }}

% TODO: Could be just a type abbreviation?
in_out_list {{ tex \overline{io} }} :: in_out_list_ ::=
{{ com list of input and output }}
{{ hol (in_out list) }}
| empty_in_out :: M :: empty
  {{ hol ([]:in_out list) }}
| in_out '::' in_out_list :: M :: cons
  {{ com cons }}
  {{ hol ([[in_out]]::[[in_out_list]]) }}
| ( in_out_list ) :: S :: paren
  {{ hol ([[in_out_list]]) }}

%Fence so that ott does not re-order input_f and output_f, ab_list
embed
{{ hol

}}
grammar

ab_list {{ tex \overline{ab} }} :: ab_list_ ::=
{{ com list of architectural blocks }}
{{ hol (arch_block list) }}
| empty :: M :: empty
  {{ com empty list }}
  {{ hol ([]:arch_block list) }}

%TODO: Unify input_f and output_f?
input_f {{ tex { f_{ \mathit{in} } } }} :: input_f_ ::=
{{ com input function }}
{{ hol ((in_out_list # scope) -> (in_out_list # scope) option) }}

output_f {{ tex { f_{ \mathit{out} } } }} :: output_f_ ::=
{{ com output function }}
{{ hol ((in_out_list # scope) -> (in_out_list # scope) option) }}

%Fence so that ott does not re-order ctx
embed
{{ hol

}}
grammar

aenv {{ tex { \mathit{env}_\mathit{A} } }} :: aenv_ ::=
{{ com architectural environment }}
{{ hol (num # boolv # in_out_list # in_out_list # scope) }}
| empty :: M :: empty
  {{ com empty architectural environment }}
  {{ hol (0, F, [], [], FEMPTY) }}
| ( i , boolv , in_out_list , in_out_list' , scope ) :: M :: tup
  {{ com tuple }}
  {{ hol ([[i]], [[boolv]], [[in_out_list]], [[in_out_list']], [[scope]]) }}

actx {{ tex { \mathit{ctx}_\mathit{A} } }} :: actx_ ::=
{{ com architectural context }}
{{ hol (ab_list # pblock_map # ffblock_map # input_f # output_f # ty_map # ext_map # func_map) }}
| ( ab_list , pblock_map , ffblock_map , input_f , output_f , ty_map , ext_map , func_map ) :: M :: tup
  {{ com tuple }}
  {{ hol ([[ab_list]], [[pblock_map]], [[ffblock_map]], [[input_f]], [[output_f]], [[ty_map]], [[ext_map]], [[func_map]]) }}

pctx {{ tex { \mathit{ctx}_\mathit{P} } }} :: pctx_ ::=
{{ com parser context }}
{{ hol (ty_map # ext_map # func_map # pars_map) }}
| ( ty_map , ext_map , func_map , pars_map ) :: M :: tup
  {{ com tuple }}
  {{ hol ([[ty_map]], [[ext_map]], [[func_map]], [[pars_map]]) }}

%TODO: Same as regular ctx?
cctx {{ tex { \mathit{ctx}_\mathit{C} } }} :: cctx_ ::=
{{ com control context }}
{{ hol (ty_map # ext_map # func_map # tbl_map) }}
| ( ty_map , ext_map , func_map , tbl_map ) :: M :: tup
  {{ com tuple }}
  {{ hol ([[ty_map]], [[ext_map]], [[func_map]], [[tbl_map]]) }}

% TODO: Could be just a type abbreviation?
ctx {{ tex \mathit{ctx} }} :: ctx_ ::=
{{ com context }}
{{ hol (ty_map # ext_map # func_map # tbl_map) }}
| empty :: M :: empty
  {{ com empty context }}
  {{ hol (FEMPTY, FEMPTY, FEMPTY, FEMPTY) }}
| ( ty_map , ext_map , func_map , tbl_map ) :: M :: tup
  {{ com tuple }}
  {{ hol ([[ty_map]], [[ext_map]], [[func_map]], [[tbl_map]]) }}

%%%%%%%%%%%%%%%%%%%%%%%%
% Expression semantics %
%%%%%%%%%%%%%%%%%%%%%%%%

terminals :: terminals_ ::=
%Statement reduction
| -> :: :: rightarrow {{ tex \rightarrow }}
%Expression reduction
| ~> :: :: rightsquigarrow {{ tex \rightsquigarrow }}
%Parser state reduction
| --> :: :: longrightarrow {{ tex \longrightarrow }}

formula :: formula_ ::=
{{ com formulas }}
| judgement :: :: judgement
  {{ com judgement }}
%Expressions
| ! b = b' :: M :: neg_bool
  {{ hol (~[[b]] = [[b']]) }}
| ~ bitv = bitv' :: M :: compl
  {{ hol (bitv_bl_unop bnot [[bitv]] = [[bitv']]) }}
| - bitv = bitv' :: M :: neg_signed
  {{ hol (bitv_unop unop_neg_signed [[bitv]] = [[bitv']]) }}
| + bitv = bitv' :: M :: un_plus
  %Note P4 spec says this is a noop
  {{ hol ([[bitv]] = [[bitv']]) }}
| bitv * bitv' = bitv'' :: M :: mul
  {{ hol (bitv_binop binop_mul [[bitv]] [[bitv']] = SOME [[bitv'']]) }}
| bitv / bitv' = bitv'' :: M :: div
  {{ hol (bitv_binop binop_div [[bitv]] [[bitv']] = SOME [[bitv'']]) }}
| bitv mod bitv' = bitv'' :: M :: mod
  {{ hol (bitv_binop binop_mod [[bitv]] [[bitv']] = SOME [[bitv'']]) }}
| bitv + bitv' = bitv'' :: M :: add
  {{ hol (bitv_binop binop_add [[bitv]] [[bitv']] = SOME [[bitv'']]) }}
| bitv - bitv' = bitv'' :: M :: sub
  {{ hol (bitv_binop binop_sub [[bitv]] [[bitv']] = SOME [[bitv'']]) }}
%TODO: Unify the below eq_ to equality over values?
| bitv EQ bitv' = b :: M :: eq_word
  {{ hol (([[bitv]] = [[bitv']]) <=> [[b]]) }}
| b EQ b' = b'' :: M :: eq_bool
  {{ hol ([[b]] = [[b']] <=> [[b'']]) }}
| ( x EQ x' ) = b :: M :: eq_error
  {{ com equality over strings - used for errors }}
  {{ hol (([[x]] = [[x']]) = [[b]]) }}
  {{ tex ([[x]] = [[x']]) = [[b]] }}
| bitv SHL bitv' = bitv'' :: M :: shl
  %TODO: Put fixwidth here instead?
  {{ hol (bitv_bl_binop shiftl [[bitv]] ((\(bl, n). (v2n bl, n)) [[bitv']]) = [[bitv'']]) }}
| bitv SHR bitv' = bitv'' :: M :: shr
  %TODO: Put fixwidth here instead?
  {{ hol (bitv_bl_binop shiftr [[bitv]] ((\(bl, n). (v2n bl, n)) [[bitv']]) = [[bitv'']]) }}
| bitv LE bitv' = b :: M :: le
  {{ hol ((bitv_binpred binop_le [[bitv]] [[bitv']]) = SOME [[b]]) }}
| bitv GE bitv' = b :: M :: ge
  {{ hol ((bitv_binpred binop_ge [[bitv]] [[bitv']]) = SOME [[b]]) }}
| bitv < bitv' = b :: M :: lt
  {{ hol ((bitv_binpred binop_lt [[bitv]] [[bitv']]) = SOME [[b]]) }}
| bitv > bitv' = b :: M :: gt
  {{ hol ((bitv_binpred binop_gt [[bitv]] [[bitv']]) = SOME [[b]]) }}
%TODO: Unify the below neq_ to inequality over values?
| bitv NE bitv' = b :: M :: neq_word
  {{ hol (([[bitv]] <> [[bitv']]) <=> [[b]]) }}
| ( x <> x' ) = b :: M :: neq_error
  {{ com inequality over strings - used for errors }}
  {{ hol (([[x]] <> [[x']]) = [[b]]) }}
  {{ tex ([[x]] \neq [[x']]) = [[b]] }}
| b NE b' = b'' :: M :: neq_bool
  {{ hol (([[b]] <> [[b']]) <=> [[b'']]) }}
| bitv & bitv' = bitv'' :: M :: and_word
  {{ hol (bitv_bl_binop band [[bitv]] [[bitv']] = [[bitv'']]) }}
| bitv ^ bitv' = bitv'' :: M :: xor_word
  %TODO: Decide LaTeX XOR representation
  {{ hol (bitv_bl_binop bxor [[bitv]] [[bitv']] = [[bitv'']]) }}
| bitv '|' bitv' = bitv'' :: M :: or_word
  {{ hol (bitv_bl_binop bor [[bitv]] [[bitv']] = [[bitv'']]) }}
| b AND b' = b'' :: M :: and_bool
  {{ hol ([[b]] /\ [[b']] = [[b'']]) }}
| b OR b' = b'' :: M :: or_bool
  {{ hol ([[b]] \/ [[b']] = [[b'']]) }}

%Type-transforming operations
| g_scope = scopes_stack [ i ] :: M :: scopes_stack_index
  {{ hol ([[g_scope]] = EL [[i]] [[scopes_stack]]) }}
%TODO: Why does the above not work for value 1?
| g_scope = scopes_stack [ 1 ] :: M :: scopes_stack_index_1
  {{ hol ([[g_scope]] = EL 1 [[scopes_stack]]) }}
| ( stmt , ( x1 , d1 ) , .. , ( xn , dn ) ) = func_map ( f ) :: M :: func_lookup
  {{ com function signature lookup }}
  {{ hol (FLOOKUP [[func_map]] [[f]] = SOME ([[stmt]], [[x1 d1 .. xn dn]])) }}
| length ( scopes_stack ) = i :: M :: find_length
  {{ com find the scope stack length }}
  {{ tex [[i]] = length ([[scopes_stack]])}}
  {{ hol ([[i]] = LENGTH [[scopes_stack]]) }}
| length ( scopes_stack ) - 1 = i :: M :: find_length_minus_1
  {{ com find the scope stack length minus 1 }}
  {{ tex [[i]] = length ([[scopes_stack]]) - 1}}
  {{ hol ([[i]] = LENGTH [[scopes_stack]] - 1) }}  
| v = scope ( x ) :: M :: lookup
  {{ com look-up of variable in scope }}
  {{ hol (FLOOKUP [[scope]] [[x]] = SOME [[v]]) }}
| v = struct { x1 = v1 ; ... ; xn = vn } ( x ) :: M :: s_access
  {{ com access of field in struct }}
  {{ hol (FIND (\(k, v). k = [[x]]) [[x1 v1 ... xn vn]] = SOME ([[x]], [[v]])) }}
| v = header boolv { x1 = v1 ; ... ; xn = vn } ( x ) :: M :: h_access
  {{ com access of field in header }}
  {{ hol (FIND (\(k, v). k = [[x]]) [[x1 v1 ... xn vn]] = SOME ([[x]], [[v]])) }}
| e = e_list [ i ] :: M :: args_index
  {{ hol ([[e]] = EL [[i]] [[e_list]]) }}
| e = hd e_list :: M :: args_hd
  {{ hol ([[e]] = HD [[e_list]]) }}
  {{ tex [[e]] = \mathrm{hd} \,\, [[e_list]] }}
| v = lookup_vexp ( scopes_stack , x ) :: :: lookup_v
  {{ tex [[v]] = \mathrm{lookup_v} ([[scopes_stack]], [[x]]) }}
  {{ hol SOME [[v]] =  lookup_vexp [[scopes_stack]] (varn_name [[x]])}}
| v = lookup_vexp2 ( scopes_stack , g_scope_list , varn ) :: :: lookup_v2
  {{ tex [[v]] = \mathrm{lookup_v} ([[scopes_stack]], [[g_scope_list]], [[varn]]) }}
  {{ hol SOME [[v]] =  lookup_vexp2 [[scopes_stack]] [[g_scope_list]] [[varn]]}} 
| ( v , a ) = lookup_tup ( scopes_stack , varn ) :: :: lookup_tup
  {{ tex ([[v]] , [[a]]) = \mathrm{lookup_tup} ([[scopes_stack]], [[varn]]) }}
| x' = { v1 : x1 ; ... ; vn : xn } x ( v ) :: M :: sel_access
  {{ com access of string in select key-value list }}
  {{ hol [[x']] = sel [[v]] [[v1 x1 ... vn xn]] [[x]]}}
  {{ tex [[x']] = \{ v_1 : x_1 ; ... ; v_n : x_n ; \_ : x \} (v) }}
| check_args_red d_list e_list :: M :: signature_check  
  {{ com check if arguments are isvar or isconst }}
  {{ tex \forall i \leqslant n. \, ((d_i \in \{\circ , \downarrow\} \implies \mathrm{is\_const} \, e_i ) \land (d_i \in \{\updownarrow , \uparrow\} \implies \mathrm{is\_var} \, e_i))  }}
 % {{ tex \forall d ,\, e ,\, i \leqslant n. \, d = [[d_list]] [i] \, \land \, e = [[e_list]] [i] \, \implies  
 %        ((d \in \{\circ , \downarrow\} \implies \mathrm{is\_const} \, e ) \land (d \in \{\updownarrow , \uparrow\} \implies \mathrm{is\_var} \, e)) }}
  {{ hol (check_args_red [[d_list]] [[e_list]]) }}
%some operations on the direction list
| d = d_list [ i ] :: M :: d_index
  {{ hol ([[d]] = EL [[i]] [[d_list]]) }}
  {{ tex [[d]] = [[d_list]] [[i]] }}  
| d = hd d_list :: M :: d_hd
  {{ hol ([[d]] = HD [[d_list]]) }}
  {{ tex [[d]] = \mathrm{hd} \,\, [[d_list]] }} 
| unred_arg_index d_list e_list = i :: M :: parameter_index
  {{ tex i = \mathrm{min} \, \{ j . \,\, [[d_list]] [j]  \in \{\circ , \downarrow\} \wedge \neg ( \mathrm{is\_const} \, [[e_list]] [j] ) \} }}
  {{ hol (unred_arg_index [[d_list]] [[e_list]] = SOME [[i]]) }}

%concatination and bit slicing:
| bitv'' = concat bitv bitv' :: M :: concat
  {{ com concatination operation}}
  {{ tex [[bitv'']] =  [[bitv]] {+}\mspace{-8mu}{+}  [[bitv']] }}
  {{ hol ([[bitv'']] = bitv_concat [[bitv]] [[bitv']]) }}

| bitv''' = bitv [ bitv' : bitv'' ] :: M :: slice
  {{ com bit slicing operation}}
  {{ tex [[bitv''']] =  [[bitv]] [ [[bitv']] : [[bitv'']] ]}}
  {{ hol [[bitv''']] = slice [[bitv]] [[bitv']] [[bitv'']] }}

%Equalities
| scope = scope' :: M :: scope_eq
  {{ com scope equality }}
  {{ hol ([[scope]] = [[scope']]) }}
| scopes_stack = scopes_stack' :: M :: scopes_stack_eq
  {{ com scopes_stack equality }}
  {{ hol ([[scopes_stack]] = [[scopes_stack']]) }}
%Note the modified equality sign in the below.
%This help to distinguish between e and e_list, as well as provide a single parse
%considering some equalities between expressions are explicitly typeset
| e_list =' e_list' :: M :: args_eq
  {{ com args equality }}
  {{ hol ([[e_list]] = [[e_list']]) }}
  {{ tex [[e_list]] = [[e_list']] }}
| in_out_list = in_out_list' :: M :: io_eq
  {{ com args equality }}
  {{ hol ([[in_out_list]] = [[in_out_list']]) }}
  {{ tex [[in_out_list]] = [[in_out_list']] }}

%frame_list operation
| frame_list neq empty :: M ::flnotempty
  {{ com args equality }}
  {{ hol ([[frame_list]] <> []) }}
  {{ tex [[frame_list]] \neq [ \, ] }}

%Apply table
| tbl_map ( tbl ) = ( e , mk ) :: :: find_key
  {{ com find keys and the matching kind in the table map }}
  {{ tex \mathrm{Tb}\, [[tbl]]\, =\, ( [[e]] \, , [[mk]] ) }}
  {{ hol ( FLOOKUP [[tbl_map]] [[tbl]] = SOME ( [[e]] , [[mk]] ) ) }}
| ctrl ( tbl , v , mk ) = ( f , e_list ) :: :: ctrl_plane  
  {{ com fetch the function name and parameters from the ctrl plane }}
  {{ tex \mathrm{ctrl}\, ( [[tbl]] , \, [[v]], \, [[mk]]\, ) = \,( [[f]] , [[e_list]] ) }}
  {{ hol ([[ctrl]] ( [[tbl]] , [[v]] , [[mk]] ) = SOME ( [[f]] , [[e_list]] ) ) }}

% extern
| ( g_scope_list' , scopes_stack' , ctrl' ) = ext ( g_scope_list , scopes_stack , ctrl ) :: :: ext 
  {{ com application of an extern function }}
  {{ tex ([[g_scope_list']], \, [[scopes_stack']], \, [[ctrl']]) = \blacksquare \, ( [[g_scope_list]] , \, [[scopes_stack]] , \, [[ctrl]] ) }}
  {{ hol (SOME ([[g_scope_list']], [[scopes_stack']], [[ctrl']]) = [[ext]] ([[g_scope_list]], [[scopes_stack]], [[ctrl]])) }}

%MISC (TODO: Sort these)
%TODO: Equalities and inequalities on numerals
| i' = i + 1 :: M :: num_inc
  {{ com numeral increment }}
  {{ hol ([[i']] = [[i]] + 1) }}
  {{ tex [[i']] = [[i]] + 1 }}
| i = length ( e_list ) :: M :: num_len
  {{ com length of list }}
  {{ hol ([[i]] = LENGTH [[e_list]]) }}
  {{ tex [[i]] = \mathrm{len} \,\, [[e_list]] }}
| i < length ( e_list ) :: M :: num_in_rg
  {{ com numeral in range }}
  {{ hol ([[i]] < LENGTH [[e_list]]) }}
  {{ tex [[i]] < \mathrm{len}(\mathit{e}) }}
| is_consts ( e_list ) :: M :: args_const
  {{ com function arguments constant }}
  {{ hol (is_consts [[e_list]]) }}
  %TODO: Fix typesetting
  {{ tex \mathrm{is\_consts} \,\, [[e_list]] }}
| stmt = pars_map ( x ) :: M :: pars_lookup
  {{ com parser state map lookup }}
  {{ hol (FLOOKUP [[pars_map]] [[x]] = SOME ([[stmt]])) }}
| x = parseError :: M :: pars_err
  {{ com parser error literal }}
  {{ hol ([[x]] = "parseError") }}
  {{ tex [[x]] = ``\mathit{parseError}" }}
  %Dummy to keep syntax highlighting from freaking out: "
| v = lookup_lval ( scopes_stack , lval ) :: M :: lookup_lval
  {{ com instantaneous lookup of lvals }}
  {{ hol ([[v]] = lookup_lval [[scopes_stack]]  [[lval]]) }}
  {{ tex [[v]] = { \mathrm{lookup} }_{ \mathrm{lval} } ([[scopes_stack]], [[lval]]) }}
| scopes_stack' = init_in_highest_scope ( scopes_stack , v , star ) :: M :: init_star
  {{ com declare "star" with value v in topmost scope }}
  {{ hol ([[scopes_stack']] = init_in_highest_scope [[scopes_stack]] [[v]] varn_star) }}
  {{ tex [[scopes_stack']] = [[scopes_stack]] [ [[star]] \longmapsto [[v]] ] }}
| not_final_state ( x ) :: M :: not_final_x
  {{ com x is not name of final state }}
  {{ hol (([[x]] <> "accept") /\ ([[x]] <> "reject")) }}
| notrun( status ) :: M :: notrun
  {{ com status is not in running}}
  {{ tex t \neq { \mathbf{run} } }}
  {{ hol (status <> status_running)}}
| notret( status ) :: :: noret
  {{ com status is not in return}}
  {{ tex [[status]] \neq { \mathbf{Ret \, v} } }}
  {{ hol ( notret [[status]] )}}  
| acc_or_rej( status ) :: M :: accrejstatus
  {{ com status is not in running}}
  {{ tex t = { \mathbf{acc} } \vee t = { \mathbf{rej} } }}
  {{ hol (status = Accept \/ status = Reject) }}     
| x = "accept" :: M :: is_accept
  {{ com x is accept }}
  {{ hol ([[x]] = "accept") }}
  {{ tex [[x]] = ``\mathit{accept}" }}
  %Dummy to keep syntax highlighting from freaking out: "
| x = "reject" :: M :: is_reject
  {{ com x is reject }}
  {{ hol ([[x]] = "reject") }}
  {{ tex [[x]] = ``\mathit{reject}" }}
  %Dummy to keep syntax highlighting from freaking out: "
| x = "start" :: M :: is_start
  {{ com x is start }}
  {{ hol ([[x]] = "start") }}
  {{ tex [[x]] = ``\mathit{start}" }}
  %Dummy to keep syntax highlighting from freaking out: "
| scope = all_arg_update_for_newscope ( ( x1 , .. , xn ) , d_list , e_list , scopes_stack ) :: M :: build_scope
  {{ com build new scope }}
  %This is a hack, fix the scopes_stack
  {{ tex \forall i \leqslant n . \, [[scope]](x_n) = \mathrm{copyin} (x_n , e_n , d_n , \overrightarrow{\gamma}' )  }}
 % {{ tex \forall d,\, e,\, x,\, i \leqslant n . \, x = [x_1 , ... , x_n] [i] \land 
 %        \, e = [e_1 , ... , e_n] [i] \land 
 %        \, d = [d_1 , ... , d_n] [i] 
 %        \implies [[scope]](x) = 
%	   \begin{cases}
%	     (\mathrm{lookup_v}( [[scopes_stack]] , e), e) & \mathrm{if} \; d \in \{ \uparrow , \updownarrow \} \\
 %            (e, \bot) & \mathrm{if} \; d \in \{ \downarrow , \circ \}
	%   \end{cases} }}
  {{ hol (SOME [[scope]] = all_arg_update_for_newscope [[x1 .. xn]] [[d_list]] [[e_list]] [[scopes_stack]]) }}
| scope' = copyin ( ( x1 , .. , xn ) , d_list , e_list , g_scope_list , scopes_stack ) :: M :: copyin
  {{ com build new scope and copyin }}
  {{ tex [[scope']] = \mathrm{copyin} ([x_1 , \; .. \; , x_n] , [e_1 , \; .. \; , e_n] , [d_1 , \; .. \; , d_n] , [[g_scope_list]] , \overrightarrow{\gamma} )  }}
  {{ hol (SOME [[scope']] = copyin [[x1 .. xn]] [[d_list]] [[e_list]] [[g_scope_list]] [[scopes_stack]]) }}
| v = arb_from_t t :: M :: make_arb
  {{ com create new varaible in declaration }}
  {{ hol ([[v]] = arb_from_t [[t]]) }}
  {{ tex [[v]] = \mathrm{arb\_from\_t} \, [[t]] }}
| scopes_stack' = assign ( scopes_stack , v , lval ) :: M :: assign
  {{ com assign v to lval in the frame }}
  {{ hol (SOME [[scopes_stack']] = assign [[scopes_stack]] [[v]] [[lval]]) }}
  {{ tex [[scopes_stack']] = [[scopes_stack]] [ [[lval]] \longmapsto [[v]] ] }}
| scopes_stack'' = update_return ( scopes_stack , scopes_stack' , d_list , ( x1 , .. , xn ) ) :: M :: update_return
  %scopes_stack is function's stack frame, scopes_stack' is caller's stack frame  
  %REMOVE THIS!!!!!!!!!!!!!!!!!!
  {{ com update caller's stack frame upon function return }}
  {{ tex [[scopes_stack'']] = \mathrm{updateframe} ([x1, \, .. , \, xn] , [[d_list]] , [[scopes_stack']] , [[scopes_stack]]) }}
  {{ hol (SOME [[scopes_stack'']] = update_return_frame [[x1 .. xn]] [[d_list]] [[scopes_stack']] [[scopes_stack]]) }}
| not_empty stmt :: M :: not_empty
  {{ com check so that statement is not the empty statement }}
  {{ hol ([[stmt]] <> stmt_empty) }}

%Package semantics-related formulae
| pblock = pblock_map ( f ) :: M :: lookup_pb
  {{ com programmable block lookup }}
  {{ hol (FLOOKUP [[pblock_map]] [[f]] = SOME [[pblock]]) }}
| ffblock = ffblock_map ( f ) :: M :: lookup_ffb
  {{ com fixed-function block lookup }}
  {{ hol (FLOOKUP [[ffblock_map]] [[f]] = SOME [[ffblock]]) }}
| ( ( x1 , d1 ) , .. , ( xn , dn ) ) = args_of_pbl ( pblock ) :: M :: body_args_pb
  {{ com obtain body and args of pblock }}
  {{ hol (([[x1 d1 .. xn dn]]) = args_of_pbl [[pblock]] ) }}
| ( ( x1 , d1 ) , .. , ( xn , dn ) ) = args_of_ffbl ( ffblock ) :: M :: args_ffb
  {{ com obtain args of ffblock }}
  {{ hol (([[x1 d1 .. xn dn]]) = args_of_ffbl [[ffblock]] ) }}
| arch_block = ab_list [ i ] :: M :: ab_index
  {{ com ab at index i }}
  {{ hol ( [[arch_block]] = EL [[i]] [[ab_list]] ) }}
| scope' = ff ( ( e1 ,  .. , en ) , scope ) :: M :: app_ff
  {{ com apply fixed function }}
  {{ hol (SOME [[scope']] = [[ff]] ([[e1 .. en]], [[scope]]) ) }}
| ( in_out_list' , scope' ) = input_f ( in_out_list , scope ) :: M :: input_f
  {{ com apply input function }}
  {{ hol ( SOME ( [[in_out_list']] , [[scope']] ) = [[input_f]] ( [[in_out_list]] , [[scope]] ) ) }}
| ( in_out_list' , scope' ) = output_f ( in_out_list , scope ) :: M :: output_f
  {{ com apply output function }}
  {{ hol ( SOME ( [[in_out_list']] , [[scope']] ) = [[output_f]] ( [[in_out_list]] , [[scope]] ) ) }}
%TODO: Try replacing "zero i" with "i = 0" - mysterious bugs appear...
| zero i :: M :: num_zero
  {{ com numeral zeroing }}
  {{ hol ([[i]] = 0) }}
  {{ tex [[i]] = 0 }}
| status_not_fin status :: M :: not_final
  {{ com status is not final }}
  {{ hol (([[status]] <> status_pars_next (pars_next_pars_fin pars_finaccept)) /\ ([[status]] <> status_pars_next (pars_next_pars_fin pars_finreject))) }}
  {{ tex [[status]] \neq \mathit{pars\_fin} }}
| not_top_return frame_list :: M :: not_top_return
  {{ com top frame is not about to execute a return statement }}
  {{ hol (not_top_return [[frame_list]]) }}
  {{ tex \mathrm{not\_top\_return} [[frame_list]] }}
| lval = "parseError" :: M :: is_parse_error
  {{ com lval is parseError }}
  {{ hol ([[lval]] = lval_varname (varn_name "parseError")) }}
  {{ tex [[lval]] = \mathit{parseError} }}
| v = errmsg "NoError" :: M :: is_no_error
  {{ com v is NoError }}
  {{ hol ([[v]] = v_err "NoError") }}
  {{ tex [[v]] = \mathit{NoError} }}
| ( g_scope_list' , scopes_stack' ) = declare ( g_scope_list , scopes_stack , x , t ) :: M :: declare
  {{ com declare variable of type }}
  {{ hol (([[g_scope_list]], [[scopes_stack']]) = declare [[g_scope_list]] [[scopes_stack]] [[x]] [[t]]) }}
  {{ tex ([[g_scope_list']], [[scopes_stack']]) = \mathrm{declare} ([[g_scope_list]], [[scopes_stack]], [[x]], [[t]]) }}
| scopes_stack' = initialise ( scopes_stack , varn , v ) :: M :: initialise
  {{ com initialise variable to value }}
  {{ hol ([[scopes_stack']] = initialise [[scopes_stack]] [[varn]] [[v]]) }}
  {{ tex [[scopes_stack']] = \mathrm{initialise} ([[scopes_stack]], [[varn]], [[v]]) }}
| [ ( f , stmt , scopes_stack ) ] = E :: M :: contofE 
  {{ com extract the content of E }}
  {{ tex [ ( [[f]] , [[stmt]] , [[scopes_stack]]) ] = [[E]] }}
  {{ hol [ ( [[f]] , [[stmt]] , [[scopes_stack]]) ] = [[E]] }}
| ( g_scope_list' , scopes_stack'' ) = copyout ( ( x1 , .. , xn ) , d_list , g_scope_list , scopes_stack , scopes_stack' ) :: M :: copyout
   %scopes_stack callee stack, whereas scopes_stack' is the caller stack
  %{{ tex ( [[scope]] , [[scopes_stack'']]) =  \mathrm{copyout} \, ( [x1, \, .. , \, xn] , [[d_list]] , [[scope']] , [[scopes_stack]] , [[scopes_stack']] ) }}
  {{ tex ( [[g_scope_list']] , [[scopes_stack'']]) =  \mathrm{copyout} \, ( [x1, \, .. , \, xn] , [d1, \, .. , \, dn] , [[g_scope_list]] , \overrightarrow{\gamma}'' , \overrightarrow{\gamma} ) }}
  {{ hol ( SOME ( [[g_scope_list']] , [[scopes_stack'']] ) = copyout [[x1 .. xn]] [[d_list]] [[g_scope_list]] [[scopes_stack]] [[scopes_stack']] ) }}
| is_not_fully_red e :: M :: not_fully_red
  {{ com expression is not fully reduced }}
  {{ tex ~ { \mathrm{fully\_reduced} } \, [[e]] }}
  {{ hol (~(fully_reduced [[e]])) }}
| ( stmt , [ ( x1 , d1 ) , .. , ( xn , dn ) ] ) = lookup_funn_sig_body ( funn , func_map , ext_map ) :: M :: fun_sig_body
  {{ com look up the body and signature of an abstract function name }}
  {{ hol (SOME ([[stmt]], [[x1 d1 .. xn dn]]) = lookup_funn_sig_body [[funn]] [[func_map]] [[ext_map]]) }}
| [ ( x1 , d1 ) , .. , ( xn , dn ) ] = lookup_funn_sig ( funn , func_map , ext_map ) :: M :: fun_sig
  {{ com look up the signature of an abstract function name }}
  {{ hol (SOME [[x1 d1 .. xn dn]] = lookup_funn_sig [[funn]] [[func_map]] [[ext_map]]) }}

embed
{{ hol
val is_const_def = Define `
  (is_const (e_v _) = T) /\
  (is_const _ = F)
`;
val is_consts_def = Define `
  is_consts el = ~(EXISTS (\e. ~(is_const e)) el)
`;

(* Access the field f of a struct or a header *)
val acc_f_def = Define `
  (acc_f (v_struct s) f =
    case FIND (\(f', v). f' = f) s of
    | SOME (f'', v) => SOME v
    | _ => NONE) /\
  (acc_f (v_header _ s) f =
    case FIND (\(f', v). f' = f) s of
    | SOME (f'', v) => SOME v
    | _ => NONE) /\
  (acc_f _ f = NONE)
`;

val bitv_bl_unop_def = Define `
  bitv_bl_unop unop (bl, n) = (unop bl, n)
`;

val bitv_bl_binop_def = Define `
  bitv_bl_binop binop (bl, n) (bl', n') = (fixwidth n (binop bl bl'), n)
`;

val get_word_unop_def = Define `
  (get_word_unop unop_compl = word_1comp) /\
  (get_word_unop unop_neg_signed = word_2comp) /\
  (get_word_unop unop_un_plus = (\w. w))
`;
val bitv_unop_def = Define `
    (bitv_unop unop (v, 1) = (w2v ((get_word_unop unop) ((v2w v): 1 word)), 1) )
/\  (bitv_unop unop (v, 2) = (w2v ((get_word_unop unop) ((v2w v): 2 word)), 2) )
/\  (bitv_unop unop (v, 3) = (w2v ((get_word_unop unop) ((v2w v): 3 word)), 3) )
/\  (bitv_unop unop (v, 4) = (w2v ((get_word_unop unop) ((v2w v): 4 word)), 4) )
/\  (bitv_unop unop (v, 5) = (w2v ((get_word_unop unop) ((v2w v): 5 word)), 5) )
/\  (bitv_unop unop (v, 6) = (w2v ((get_word_unop unop) ((v2w v): 6 word)), 6) )
/\  (bitv_unop unop (v, 7) = (w2v ((get_word_unop unop) ((v2w v): 7 word)), 7) )
/\  (bitv_unop unop (v, 8) = (w2v ((get_word_unop unop) ((v2w v): 8 word)), 8) )
/\  (bitv_unop unop (v, 9) = (w2v ((get_word_unop unop) ((v2w v): 9 word)), 9) )
/\  (bitv_unop unop (v, 10) = (w2v ((get_word_unop unop) ((v2w v): 10 word)), 10) )
/\  (bitv_unop unop (v, 11) = (w2v ((get_word_unop unop) ((v2w v): 11 word)), 11) )
/\  (bitv_unop unop (v, 12) = (w2v ((get_word_unop unop) ((v2w v): 12 word)), 12) )
/\  (bitv_unop unop (v, 13) = (w2v ((get_word_unop unop) ((v2w v): 13 word)), 13) )
/\  (bitv_unop unop (v, 14) = (w2v ((get_word_unop unop) ((v2w v): 14 word)), 14) )
/\  (bitv_unop unop (v, 15) = (w2v ((get_word_unop unop) ((v2w v): 15 word)), 15) )
/\  (bitv_unop unop (v, 16) = (w2v ((get_word_unop unop) ((v2w v): 16 word)), 16) )
/\  (bitv_unop unop (v, 17) = (w2v ((get_word_unop unop) ((v2w v): 17 word)), 17) )
/\  (bitv_unop unop (v, 18) = (w2v ((get_word_unop unop) ((v2w v): 18 word)), 18) )
/\  (bitv_unop unop (v, 19) = (w2v ((get_word_unop unop) ((v2w v): 19 word)), 19) )
/\  (bitv_unop unop (v, 20) = (w2v ((get_word_unop unop) ((v2w v): 20 word)), 20) )
/\  (bitv_unop unop (v, 21) = (w2v ((get_word_unop unop) ((v2w v): 21 word)), 21) )
/\  (bitv_unop unop (v, 22) = (w2v ((get_word_unop unop) ((v2w v): 22 word)), 22) )
/\  (bitv_unop unop (v, 23) = (w2v ((get_word_unop unop) ((v2w v): 23 word)), 23) )
/\  (bitv_unop unop (v, 24) = (w2v ((get_word_unop unop) ((v2w v): 24 word)), 24) )
/\  (bitv_unop unop (v, 25) = (w2v ((get_word_unop unop) ((v2w v): 25 word)), 25) )
/\  (bitv_unop unop (v, 26) = (w2v ((get_word_unop unop) ((v2w v): 26 word)), 26) )
/\  (bitv_unop unop (v, 27) = (w2v ((get_word_unop unop) ((v2w v): 27 word)), 27) )
/\  (bitv_unop unop (v, 28) = (w2v ((get_word_unop unop) ((v2w v): 28 word)), 28) )
/\  (bitv_unop unop (v, 29) = (w2v ((get_word_unop unop) ((v2w v): 29 word)), 29) )
/\  (bitv_unop unop (v, 30) = (w2v ((get_word_unop unop) ((v2w v): 30 word)), 30) )
/\  (bitv_unop unop (v, 31) = (w2v ((get_word_unop unop) ((v2w v): 31 word)), 31) )
/\  (bitv_unop unop (v, 32) = (w2v ((get_word_unop unop) ((v2w v): 32 word)), 32) )
/\  (bitv_unop unop (v, 33) = (w2v ((get_word_unop unop) ((v2w v): 33 word)), 33) )
/\  (bitv_unop unop (v, 34) = (w2v ((get_word_unop unop) ((v2w v): 34 word)), 34) )
/\  (bitv_unop unop (v, 35) = (w2v ((get_word_unop unop) ((v2w v): 35 word)), 35) )
/\  (bitv_unop unop (v, 36) = (w2v ((get_word_unop unop) ((v2w v): 36 word)), 36) )
/\  (bitv_unop unop (v, 37) = (w2v ((get_word_unop unop) ((v2w v): 37 word)), 37) )
/\  (bitv_unop unop (v, 38) = (w2v ((get_word_unop unop) ((v2w v): 38 word)), 38) )
/\  (bitv_unop unop (v, 39) = (w2v ((get_word_unop unop) ((v2w v): 39 word)), 39) )
/\  (bitv_unop unop (v, 40) = (w2v ((get_word_unop unop) ((v2w v): 40 word)), 40) )
/\  (bitv_unop unop (v, 41) = (w2v ((get_word_unop unop) ((v2w v): 41 word)), 41) )
/\  (bitv_unop unop (v, 42) = (w2v ((get_word_unop unop) ((v2w v): 42 word)), 42) )
/\  (bitv_unop unop (v, 43) = (w2v ((get_word_unop unop) ((v2w v): 43 word)), 43) )
/\  (bitv_unop unop (v, 44) = (w2v ((get_word_unop unop) ((v2w v): 44 word)), 44) )
/\  (bitv_unop unop (v, 45) = (w2v ((get_word_unop unop) ((v2w v): 45 word)), 45) )
/\  (bitv_unop unop (v, 46) = (w2v ((get_word_unop unop) ((v2w v): 46 word)), 46) )
/\  (bitv_unop unop (v, 47) = (w2v ((get_word_unop unop) ((v2w v): 47 word)), 47) )
/\  (bitv_unop unop (v, 48) = (w2v ((get_word_unop unop) ((v2w v): 48 word)), 48) )
/\  (bitv_unop unop (v, 49) = (w2v ((get_word_unop unop) ((v2w v): 49 word)), 49) )
/\  (bitv_unop unop (v, 50) = (w2v ((get_word_unop unop) ((v2w v): 50 word)), 50) )
/\  (bitv_unop unop (v, 51) = (w2v ((get_word_unop unop) ((v2w v): 51 word)), 51) )
/\  (bitv_unop unop (v, 52) = (w2v ((get_word_unop unop) ((v2w v): 52 word)), 52) )
/\  (bitv_unop unop (v, 53) = (w2v ((get_word_unop unop) ((v2w v): 53 word)), 53) )
/\  (bitv_unop unop (v, 54) = (w2v ((get_word_unop unop) ((v2w v): 54 word)), 54) )
/\  (bitv_unop unop (v, 55) = (w2v ((get_word_unop unop) ((v2w v): 55 word)), 55) )
/\  (bitv_unop unop (v, 56) = (w2v ((get_word_unop unop) ((v2w v): 56 word)), 56) )
/\  (bitv_unop unop (v, 57) = (w2v ((get_word_unop unop) ((v2w v): 57 word)), 57) )
/\  (bitv_unop unop (v, 58) = (w2v ((get_word_unop unop) ((v2w v): 58 word)), 58) )
/\  (bitv_unop unop (v, 59) = (w2v ((get_word_unop unop) ((v2w v): 59 word)), 59) )
/\  (bitv_unop unop (v, 60) = (w2v ((get_word_unop unop) ((v2w v): 60 word)), 60) )
/\  (bitv_unop unop (v, 61) = (w2v ((get_word_unop unop) ((v2w v): 61 word)), 61) )
/\  (bitv_unop unop (v, 62) = (w2v ((get_word_unop unop) ((v2w v): 62 word)), 62) )
/\  (bitv_unop unop (v, 63) = (w2v ((get_word_unop unop) ((v2w v): 63 word)), 63) )
/\  (bitv_unop unop (v, 64) = (w2v ((get_word_unop unop) ((v2w v): 64 word)), 64) )
`;
val get_word_binop_def = Define `
    (get_word_binop binop_mul = word_mul)
/\  (get_word_binop binop_div = word_div)
/\  (get_word_binop binop_mod = word_mod)
/\  (get_word_binop binop_add = word_add)
/\  (get_word_binop binop_sub = word_sub)
/\  (get_word_binop binop_shl = word_lsl_bv)
/\  (get_word_binop binop_shr = word_lsr_bv)
/\  (get_word_binop binop_and = word_and)
/\  (get_word_binop binop_xor = word_xor)
/\  (get_word_binop binop_or = word_or)
`;

val bitv_binop_inner_def = Define `
    (bitv_binop_inner binop v v' 1 = SOME (w2v ((get_word_binop binop) ((v2w v): 1 word) ((v2w v'): 1 word)), 1) )
/\  (bitv_binop_inner binop v v' 2 = SOME (w2v ((get_word_binop binop) ((v2w v): 2 word) ((v2w v'): 2 word)), 2) )
/\  (bitv_binop_inner binop v v' 3 = SOME (w2v ((get_word_binop binop) ((v2w v): 3 word) ((v2w v'): 3 word)), 3) )
/\  (bitv_binop_inner binop v v' 4 = SOME (w2v ((get_word_binop binop) ((v2w v): 4 word) ((v2w v'): 4 word)), 4) )
/\  (bitv_binop_inner binop v v' 5 = SOME (w2v ((get_word_binop binop) ((v2w v): 5 word) ((v2w v'): 5 word)), 5) )
/\  (bitv_binop_inner binop v v' 6 = SOME (w2v ((get_word_binop binop) ((v2w v): 6 word) ((v2w v'): 6 word)), 6) )
/\  (bitv_binop_inner binop v v' 7 = SOME (w2v ((get_word_binop binop) ((v2w v): 7 word) ((v2w v'): 7 word)), 7) )
/\  (bitv_binop_inner binop v v' 8 = SOME (w2v ((get_word_binop binop) ((v2w v): 8 word) ((v2w v'): 8 word)), 8) )
/\  (bitv_binop_inner binop v v' 9 = SOME (w2v ((get_word_binop binop) ((v2w v): 9 word) ((v2w v'): 9 word)), 9) )
/\  (bitv_binop_inner binop v v' 10 = SOME (w2v ((get_word_binop binop) ((v2w v): 10 word) ((v2w v'): 10 word)), 10) )
/\  (bitv_binop_inner binop v v' 11 = SOME (w2v ((get_word_binop binop) ((v2w v): 11 word) ((v2w v'): 11 word)), 11) )
/\  (bitv_binop_inner binop v v' 12 = SOME (w2v ((get_word_binop binop) ((v2w v): 12 word) ((v2w v'): 12 word)), 12) )
/\  (bitv_binop_inner binop v v' 13 = SOME (w2v ((get_word_binop binop) ((v2w v): 13 word) ((v2w v'): 13 word)), 13) )
/\  (bitv_binop_inner binop v v' 14 = SOME (w2v ((get_word_binop binop) ((v2w v): 14 word) ((v2w v'): 14 word)), 14) )
/\  (bitv_binop_inner binop v v' 15 = SOME (w2v ((get_word_binop binop) ((v2w v): 15 word) ((v2w v'): 15 word)), 15) )
/\  (bitv_binop_inner binop v v' 16 = SOME (w2v ((get_word_binop binop) ((v2w v): 16 word) ((v2w v'): 16 word)), 16) )
/\  (bitv_binop_inner binop v v' 17 = SOME (w2v ((get_word_binop binop) ((v2w v): 17 word) ((v2w v'): 17 word)), 17) )
/\  (bitv_binop_inner binop v v' 18 = SOME (w2v ((get_word_binop binop) ((v2w v): 18 word) ((v2w v'): 18 word)), 18) )
/\  (bitv_binop_inner binop v v' 19 = SOME (w2v ((get_word_binop binop) ((v2w v): 19 word) ((v2w v'): 19 word)), 19) )
/\  (bitv_binop_inner binop v v' 20 = SOME (w2v ((get_word_binop binop) ((v2w v): 20 word) ((v2w v'): 20 word)), 20) )
/\  (bitv_binop_inner binop v v' 21 = SOME (w2v ((get_word_binop binop) ((v2w v): 21 word) ((v2w v'): 21 word)), 21) )
/\  (bitv_binop_inner binop v v' 22 = SOME (w2v ((get_word_binop binop) ((v2w v): 22 word) ((v2w v'): 22 word)), 22) )
/\  (bitv_binop_inner binop v v' 23 = SOME (w2v ((get_word_binop binop) ((v2w v): 23 word) ((v2w v'): 23 word)), 23) )
/\  (bitv_binop_inner binop v v' 24 = SOME (w2v ((get_word_binop binop) ((v2w v): 24 word) ((v2w v'): 24 word)), 24) )
/\  (bitv_binop_inner binop v v' 25 = SOME (w2v ((get_word_binop binop) ((v2w v): 25 word) ((v2w v'): 25 word)), 25) )
/\  (bitv_binop_inner binop v v' 26 = SOME (w2v ((get_word_binop binop) ((v2w v): 26 word) ((v2w v'): 26 word)), 26) )
/\  (bitv_binop_inner binop v v' 27 = SOME (w2v ((get_word_binop binop) ((v2w v): 27 word) ((v2w v'): 27 word)), 27) )
/\  (bitv_binop_inner binop v v' 28 = SOME (w2v ((get_word_binop binop) ((v2w v): 28 word) ((v2w v'): 28 word)), 28) )
/\  (bitv_binop_inner binop v v' 29 = SOME (w2v ((get_word_binop binop) ((v2w v): 29 word) ((v2w v'): 29 word)), 29) )
/\  (bitv_binop_inner binop v v' 30 = SOME (w2v ((get_word_binop binop) ((v2w v): 30 word) ((v2w v'): 30 word)), 30) )
/\  (bitv_binop_inner binop v v' 31 = SOME (w2v ((get_word_binop binop) ((v2w v): 31 word) ((v2w v'): 31 word)), 31) )
/\  (bitv_binop_inner binop v v' 32 = SOME (w2v ((get_word_binop binop) ((v2w v): 32 word) ((v2w v'): 32 word)), 32) )
/\  (bitv_binop_inner binop v v' 33 = SOME (w2v ((get_word_binop binop) ((v2w v): 33 word) ((v2w v'): 33 word)), 33) )
/\  (bitv_binop_inner binop v v' 34 = SOME (w2v ((get_word_binop binop) ((v2w v): 34 word) ((v2w v'): 34 word)), 34) )
/\  (bitv_binop_inner binop v v' 35 = SOME (w2v ((get_word_binop binop) ((v2w v): 35 word) ((v2w v'): 35 word)), 35) )
/\  (bitv_binop_inner binop v v' 36 = SOME (w2v ((get_word_binop binop) ((v2w v): 36 word) ((v2w v'): 36 word)), 36) )
/\  (bitv_binop_inner binop v v' 37 = SOME (w2v ((get_word_binop binop) ((v2w v): 37 word) ((v2w v'): 37 word)), 37) )
/\  (bitv_binop_inner binop v v' 38 = SOME (w2v ((get_word_binop binop) ((v2w v): 38 word) ((v2w v'): 38 word)), 38) )
/\  (bitv_binop_inner binop v v' 39 = SOME (w2v ((get_word_binop binop) ((v2w v): 39 word) ((v2w v'): 39 word)), 39) )
/\  (bitv_binop_inner binop v v' 40 = SOME (w2v ((get_word_binop binop) ((v2w v): 40 word) ((v2w v'): 40 word)), 40) )
/\  (bitv_binop_inner binop v v' 41 = SOME (w2v ((get_word_binop binop) ((v2w v): 41 word) ((v2w v'): 41 word)), 41) )
/\  (bitv_binop_inner binop v v' 42 = SOME (w2v ((get_word_binop binop) ((v2w v): 42 word) ((v2w v'): 42 word)), 42) )
/\  (bitv_binop_inner binop v v' 43 = SOME (w2v ((get_word_binop binop) ((v2w v): 43 word) ((v2w v'): 43 word)), 43) )
/\  (bitv_binop_inner binop v v' 44 = SOME (w2v ((get_word_binop binop) ((v2w v): 44 word) ((v2w v'): 44 word)), 44) )
/\  (bitv_binop_inner binop v v' 45 = SOME (w2v ((get_word_binop binop) ((v2w v): 45 word) ((v2w v'): 45 word)), 45) )
/\  (bitv_binop_inner binop v v' 46 = SOME (w2v ((get_word_binop binop) ((v2w v): 46 word) ((v2w v'): 46 word)), 46) )
/\  (bitv_binop_inner binop v v' 47 = SOME (w2v ((get_word_binop binop) ((v2w v): 47 word) ((v2w v'): 47 word)), 47) )
/\  (bitv_binop_inner binop v v' 48 = SOME (w2v ((get_word_binop binop) ((v2w v): 48 word) ((v2w v'): 48 word)), 48) )
/\  (bitv_binop_inner binop v v' 49 = SOME (w2v ((get_word_binop binop) ((v2w v): 49 word) ((v2w v'): 49 word)), 49) )
/\  (bitv_binop_inner binop v v' 50 = SOME (w2v ((get_word_binop binop) ((v2w v): 50 word) ((v2w v'): 50 word)), 50) )
/\  (bitv_binop_inner binop v v' 51 = SOME (w2v ((get_word_binop binop) ((v2w v): 51 word) ((v2w v'): 51 word)), 51) )
/\  (bitv_binop_inner binop v v' 52 = SOME (w2v ((get_word_binop binop) ((v2w v): 52 word) ((v2w v'): 52 word)), 52) )
/\  (bitv_binop_inner binop v v' 53 = SOME (w2v ((get_word_binop binop) ((v2w v): 53 word) ((v2w v'): 53 word)), 53) )
/\  (bitv_binop_inner binop v v' 54 = SOME (w2v ((get_word_binop binop) ((v2w v): 54 word) ((v2w v'): 54 word)), 54) )
/\  (bitv_binop_inner binop v v' 55 = SOME (w2v ((get_word_binop binop) ((v2w v): 55 word) ((v2w v'): 55 word)), 55) )
/\  (bitv_binop_inner binop v v' 56 = SOME (w2v ((get_word_binop binop) ((v2w v): 56 word) ((v2w v'): 56 word)), 56) )
/\  (bitv_binop_inner binop v v' 57 = SOME (w2v ((get_word_binop binop) ((v2w v): 57 word) ((v2w v'): 57 word)), 57) )
/\  (bitv_binop_inner binop v v' 58 = SOME (w2v ((get_word_binop binop) ((v2w v): 58 word) ((v2w v'): 58 word)), 58) )
/\  (bitv_binop_inner binop v v' 59 = SOME (w2v ((get_word_binop binop) ((v2w v): 59 word) ((v2w v'): 59 word)), 59) )
/\  (bitv_binop_inner binop v v' 60 = SOME (w2v ((get_word_binop binop) ((v2w v): 60 word) ((v2w v'): 60 word)), 60) )
/\  (bitv_binop_inner binop v v' 61 = SOME (w2v ((get_word_binop binop) ((v2w v): 61 word) ((v2w v'): 61 word)), 61) )
/\  (bitv_binop_inner binop v v' 62 = SOME (w2v ((get_word_binop binop) ((v2w v): 62 word) ((v2w v'): 62 word)), 62) )
/\  (bitv_binop_inner binop v v' 63 = SOME (w2v ((get_word_binop binop) ((v2w v): 63 word) ((v2w v'): 63 word)), 63) )
/\  (bitv_binop_inner binop v v' 64 = SOME (w2v ((get_word_binop binop) ((v2w v): 64 word) ((v2w v'): 64 word)), 64) )
/\  (bitv_binop_inner binop v v' _ = NONE )
`;
val bitv_binop_def = Define `
  bitv_binop binop (v, n) (v', n') =
    if n = n'
    then bitv_binop_inner binop v v' n
    else NONE
`;

val get_word_binpred_def = Define `
    (get_word_binpred binop_le = word_le)
/\  (get_word_binpred binop_ge = word_ge)
/\  (get_word_binpred binop_lt = word_lt)
/\  (get_word_binpred binop_gt = word_gt)
/\  (get_word_binpred binop_neq = (\w1 w2. ~(w1 = w2)))
/\  (get_word_binpred binop_eq = (\w1 w2. w1 = w2))
`;

val bitv_binpred_inner_def = Define `
    (bitv_binpred_inner binpred v v' 1 = SOME (((get_word_binpred binpred) ((v2w v): 1 word) ((v2w v'): 1 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 2 = SOME (((get_word_binpred binpred) ((v2w v): 2 word) ((v2w v'): 2 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 3 = SOME (((get_word_binpred binpred) ((v2w v): 3 word) ((v2w v'): 3 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 4 = SOME (((get_word_binpred binpred) ((v2w v): 4 word) ((v2w v'): 4 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 5 = SOME (((get_word_binpred binpred) ((v2w v): 5 word) ((v2w v'): 5 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 6 = SOME (((get_word_binpred binpred) ((v2w v): 6 word) ((v2w v'): 6 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 7 = SOME (((get_word_binpred binpred) ((v2w v): 7 word) ((v2w v'): 7 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 8 = SOME (((get_word_binpred binpred) ((v2w v): 8 word) ((v2w v'): 8 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 9 = SOME (((get_word_binpred binpred) ((v2w v): 9 word) ((v2w v'): 9 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 10 = SOME (((get_word_binpred binpred) ((v2w v): 10 word) ((v2w v'): 10 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 11 = SOME (((get_word_binpred binpred) ((v2w v): 11 word) ((v2w v'): 11 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 12 = SOME (((get_word_binpred binpred) ((v2w v): 12 word) ((v2w v'): 12 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 13 = SOME (((get_word_binpred binpred) ((v2w v): 13 word) ((v2w v'): 13 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 14 = SOME (((get_word_binpred binpred) ((v2w v): 14 word) ((v2w v'): 14 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 15 = SOME (((get_word_binpred binpred) ((v2w v): 15 word) ((v2w v'): 15 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 16 = SOME (((get_word_binpred binpred) ((v2w v): 16 word) ((v2w v'): 16 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 17 = SOME (((get_word_binpred binpred) ((v2w v): 17 word) ((v2w v'): 17 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 18 = SOME (((get_word_binpred binpred) ((v2w v): 18 word) ((v2w v'): 18 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 19 = SOME (((get_word_binpred binpred) ((v2w v): 19 word) ((v2w v'): 19 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 20 = SOME (((get_word_binpred binpred) ((v2w v): 20 word) ((v2w v'): 20 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 21 = SOME (((get_word_binpred binpred) ((v2w v): 21 word) ((v2w v'): 21 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 22 = SOME (((get_word_binpred binpred) ((v2w v): 22 word) ((v2w v'): 22 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 23 = SOME (((get_word_binpred binpred) ((v2w v): 23 word) ((v2w v'): 23 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 24 = SOME (((get_word_binpred binpred) ((v2w v): 24 word) ((v2w v'): 24 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 25 = SOME (((get_word_binpred binpred) ((v2w v): 25 word) ((v2w v'): 25 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 26 = SOME (((get_word_binpred binpred) ((v2w v): 26 word) ((v2w v'): 26 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 27 = SOME (((get_word_binpred binpred) ((v2w v): 27 word) ((v2w v'): 27 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 28 = SOME (((get_word_binpred binpred) ((v2w v): 28 word) ((v2w v'): 28 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 29 = SOME (((get_word_binpred binpred) ((v2w v): 29 word) ((v2w v'): 29 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 30 = SOME (((get_word_binpred binpred) ((v2w v): 30 word) ((v2w v'): 30 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 31 = SOME (((get_word_binpred binpred) ((v2w v): 31 word) ((v2w v'): 31 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 32 = SOME (((get_word_binpred binpred) ((v2w v): 32 word) ((v2w v'): 32 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 33 = SOME (((get_word_binpred binpred) ((v2w v): 33 word) ((v2w v'): 33 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 34 = SOME (((get_word_binpred binpred) ((v2w v): 34 word) ((v2w v'): 34 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 35 = SOME (((get_word_binpred binpred) ((v2w v): 35 word) ((v2w v'): 35 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 36 = SOME (((get_word_binpred binpred) ((v2w v): 36 word) ((v2w v'): 36 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 37 = SOME (((get_word_binpred binpred) ((v2w v): 37 word) ((v2w v'): 37 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 38 = SOME (((get_word_binpred binpred) ((v2w v): 38 word) ((v2w v'): 38 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 39 = SOME (((get_word_binpred binpred) ((v2w v): 39 word) ((v2w v'): 39 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 40 = SOME (((get_word_binpred binpred) ((v2w v): 40 word) ((v2w v'): 40 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 41 = SOME (((get_word_binpred binpred) ((v2w v): 41 word) ((v2w v'): 41 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 42 = SOME (((get_word_binpred binpred) ((v2w v): 42 word) ((v2w v'): 42 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 43 = SOME (((get_word_binpred binpred) ((v2w v): 43 word) ((v2w v'): 43 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 44 = SOME (((get_word_binpred binpred) ((v2w v): 44 word) ((v2w v'): 44 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 45 = SOME (((get_word_binpred binpred) ((v2w v): 45 word) ((v2w v'): 45 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 46 = SOME (((get_word_binpred binpred) ((v2w v): 46 word) ((v2w v'): 46 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 47 = SOME (((get_word_binpred binpred) ((v2w v): 47 word) ((v2w v'): 47 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 48 = SOME (((get_word_binpred binpred) ((v2w v): 48 word) ((v2w v'): 48 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 49 = SOME (((get_word_binpred binpred) ((v2w v): 49 word) ((v2w v'): 49 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 50 = SOME (((get_word_binpred binpred) ((v2w v): 50 word) ((v2w v'): 50 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 51 = SOME (((get_word_binpred binpred) ((v2w v): 51 word) ((v2w v'): 51 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 52 = SOME (((get_word_binpred binpred) ((v2w v): 52 word) ((v2w v'): 52 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 53 = SOME (((get_word_binpred binpred) ((v2w v): 53 word) ((v2w v'): 53 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 54 = SOME (((get_word_binpred binpred) ((v2w v): 54 word) ((v2w v'): 54 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 55 = SOME (((get_word_binpred binpred) ((v2w v): 55 word) ((v2w v'): 55 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 56 = SOME (((get_word_binpred binpred) ((v2w v): 56 word) ((v2w v'): 56 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 57 = SOME (((get_word_binpred binpred) ((v2w v): 57 word) ((v2w v'): 57 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 58 = SOME (((get_word_binpred binpred) ((v2w v): 58 word) ((v2w v'): 58 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 59 = SOME (((get_word_binpred binpred) ((v2w v): 59 word) ((v2w v'): 59 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 60 = SOME (((get_word_binpred binpred) ((v2w v): 60 word) ((v2w v'): 60 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 61 = SOME (((get_word_binpred binpred) ((v2w v): 61 word) ((v2w v'): 61 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 62 = SOME (((get_word_binpred binpred) ((v2w v): 62 word) ((v2w v'): 62 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 63 = SOME (((get_word_binpred binpred) ((v2w v): 63 word) ((v2w v'): 63 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 64 = SOME (((get_word_binpred binpred) ((v2w v): 64 word) ((v2w v'): 64 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' _ = NONE )
`;
val bitv_binpred_def = Define `
  bitv_binpred binpred (v, n) (v', n') =
    if n = n'
    then bitv_binpred_inner binpred v v' n
    else NONE
`;
val bitv_concat_def = Define `
  bitv_concat (v, (n:num)) (v', n') = (v ++ v', n + n')
`;

(* The arguments are v vector, n length of that vector, m is the most significant bit
 * l is the least significant bit. It returns the sliced vector with the length *)
val bitv_bitslice_def = Define `
  bitv_bitslice (v, n) m l = (SEG ( m - l + 1 ) l v, m - l + 1)
`;

val slice_def = Define `
  slice (v, n) (vec1, len1) (vec2, len2) = bitv_bitslice (v , n) (v2n (vec1)) (v2n (vec2))
`;

val is_var_def = Define `
  (is_var (e_var _) = T) /\
  (is_var _ = F)
`;

(* Extracts the string that represents the variable name from the expression form *)
val varname_of_e_def = Define `
  (varname_of_e (e_var varn) = SOME varn) /\
  (varname_of_e _ = NONE)
`;

val v_of_e_def = Define `
  (v_of_e (e_v v) = SOME v) /\
  (v_of_e _ = NONE)
`;

(* TODO: Rename to avoid confusion with "newest_scope" et.c. *)
(* Finds the topmost scope where the variable x is mapped and its index, as a tuple.*)
val find_topmost_scope_def = Define `
  find_topmost_scope (ss:scope list) x =
    case INDEX_FIND 0 (\sc. IS_SOME (FLOOKUP sc x)) (REVERSE ss) of
    | SOME (i, sc) => SOME (((LENGTH ss) - 1) - i, sc)
    | NONE => NONE
`;

(* Extracts the topmost scope where the variable name x is mapped *)
val topmost_scope_def = Define `
  topmost_scope (ss:scope list) x =
    case find_topmost_scope ss x of
    | SOME (i, sc) => SOME sc
    | _ => NONE
`;

(* Extracts the index of the topmost scope where the variable name x is mapped *)
val topmost_scope_index_def = Define `
  topmost_scope_index (ss:scope list) x = 
    case find_topmost_scope ss x of
    | SOME (i, sc) => SOME i
    | _ => NONE
`;
(* Fetches the (value, string option) tuple of the variable name x,
 * in the topmost scope where it is mapped *)
val lookup_tup_def = Define `
  lookup_tup (ss:scope list) x =
    case topmost_scope ss x of
    | SOME sc => 
      (case FLOOKUP sc x of
       | SOME (v, str_opt) => SOME (v, str_opt)
       | _ => NONE)
    | _ => NONE
`;
(* Fetches the value of the variable name x from the topmost scope where it is mapped *)
val lookup_v_def = Define `
  lookup_v (ss:scope list) x =
    case lookup_tup ss x of
    | SOME (v, str_opt) => SOME v
    | _ => NONE
`;
(* Fetches the (optional) argument variable name that might have been saved if
 * variable name x was mapped as a result of being an out-parameter in a
 * called function from the topmost scope where x is mapped *)
val lookup_out_def = Define `
  lookup_out (ss:scope list) x =
    case lookup_tup ss x of
    | SOME (v, str_opt) => SOME str_opt
    | _ => NONE
`;
(* Same as the above, but directly from an expression *)
val lookup_vexp_def = Define `
  lookup_vexp (ss:scope list) x =
    lookup_v (ss:scope list) x
`;

(* Lookup with g_scope_list as a separate argument *)
val lookup_vexp2_def = Define `
  lookup_vexp2 (ss:scope list) (g_scope_list:scope list) x =
    lookup_v (g_scope_list++ss) x
`;

(* Look up the value of a l-value (variables + fields of struct-valued variables) in
 * a scope stack. *)
val lookup_lval_def = Define `
  (lookup_lval (ss:scope list) (lval_varname x) = lookup_v ss x) /\
  (lookup_lval (ss:scope list) (lval_field lval f) =
     case lookup_lval ss lval of
     | SOME v => acc_f v f
     | NONE => NONE)
`;

(* TODO: This is ambiguous with regard to inout... *)
val is_d_none_in_def = Define `
  (is_d_none_in d_in = T) /\
  (is_d_none_in d_none = T) /\
  (is_d_none_in _ = F)
`;

val is_d_in_def = Define `
  (is_d_in d_in = T) /\
  (is_d_in d_inout = T) /\
  (is_d_in _ = F)
`;

val is_d_out_def = Define `
  (is_d_out d_inout = T) /\
  (is_d_out d_out = T) /\
  (is_d_out _ = F)
`;

(* Obtains the minimum index where the direction is "none" or "in" in dlist and the
 * expression in the same position of elist is not a constant, and the corresponding such
 * direction and expression *)
val find_unred_arg_def = Define `
  find_unred_arg dlist elist = 
    (INDEX_FIND 0 (\(d, e). ~(is_d_out d) /\ ~(is_const e)) (ZIP (dlist, elist)))
`;
val unred_arg_index_def = Define `
  unred_arg_index dlist elist  = 
    case find_unred_arg dlist elist of
    | SOME (i, de) => SOME i
    | _ => NONE
`;

val get_lval_of_e_def = Define `
  (get_lval_of_e (e_var x) = SOME (lval_varname x)) /\
  (get_lval_of_e (e_acc e (e_v (v_str x))) =
   case get_lval_of_e e of
   | SOME lval => SOME (lval_field lval x)
   | NONE => NONE) /\
  (get_lval_of_e _ = NONE)
`;

val is_e_lval_def = Define `
  (is_e_lval e =
    case get_lval_of_e e of
    | SOME lval => T
    | NONE => F)
`;

(* Checks if function arguments have been appropriately reduced. *)
val is_arg_red_def = Define `
  is_arg_red d e =
   ((~(is_d_out d) ==> (is_const e)) /\ (is_d_out d ==> (is_e_lval e)) = T)
`;
val check_arg_red_def = Define `
  check_arg_red dlist e i =
    is_arg_red (EL i dlist) e
`;
val check_args_red_def = Define `
  check_args_red dlist elist = EVERY (\(d, e). is_arg_red d e) (ZIP(dlist, elist))
`;

val v_size_def = DB.fetch "p4" "v_size_def";

Theorem v1_size_append:
 !v_l1 v_l2. v1_size (v_l1 ++ v_l2) = (v1_size v_l1 + v1_size v_l2)
Proof
 Induct_on `v_l1` >> (
  fs [v_size_def]
 )
QED

Theorem v1_size_mem:
 !x v t. MEM (x,v) t ==> v_size v < v1_size t
Proof
 REPEAT STRIP_TAC >>
 fs [listTheory.MEM_SPLIT, v1_size_append, v_size_def]
QED

val init_out_v_def = TotalDefn.tDefine "init_out_v" `
  (init_out_v (v_bool boolv) = v_bool ARB) /\
  (init_out_v (v_bit (bl, n)) = v_bit (extend ARB n [], n)) /\
  (init_out_v (v_str x) = v_str ARB) /\
  (init_out_v (v_struct ((x,v)::t)) = v_struct (((x, init_out_v v))::(MAP (\(x',v'). (x', init_out_v v')) t))) /\
  (init_out_v (v_struct []) = v_struct []) /\
  (init_out_v (v_header boolv ((x,v)::t)) =
    v_header F (( (x, init_out_v v) )::(MAP (\(x',v'). (x', init_out_v v')) t))) /\
  (init_out_v (v_header boolv []) = v_header F []) /\
  (init_out_v (v_ext ext_obj) = v_ext ARB) /\
  (init_out_v (v_err errmsg) = v_err ARB) /\
  (init_out_v v_uninit = v_uninit) /\
  (init_out_v v_bot = v_bot)
`
(WF_REL_TAC `measure v_size` >>
 fs [v_size_def] >>
 REPEAT STRIP_TAC >>
 `v_size v' < v1_size t` suffices_by (
  fs []
 ) >>
 METIS_TAC [v1_size_mem]
);

(* TODO: Other cases *)
val arb_from_t_def = Define `
  (arb_from_t (t_base bt_bool) = (v_bool ARB)) /\
  (arb_from_t (t_base bt_bit) = (v_bit ARB)) /\
  (arb_from_t t_ext = (v_ext ARB))
`;

(* Given a direction, an expression (should be a lval), and a scope stack,
 * creates the proper tuple to be be assigned in the fresh scope created by a function call *)
val one_arg_val_for_newscope_def = Define `
 one_arg_val_for_newscope d e ss =
  if is_d_out d
  then
   (case get_lval_of_e e of
    | SOME lval =>
     (case lookup_lval ss lval of
      | SOME v =>
       if is_d_in d
       then SOME (v, SOME lval)
       else SOME (init_out_v v, SOME lval)
      | NONE => NONE)
    | NONE => NONE)
  else
   (case v_of_e e of
    | SOME v => SOME (v, NONE)
    | NONE => NONE)
`;

val update_arg_for_newscope_def = Define `
  update_arg_for_newscope ss f_opt (d, x, e) =
    case f_opt of
    | SOME f =>
      (case one_arg_val_for_newscope d e ss of
       | SOME (v, lval_opt) => SOME (f |+ (varn_name x, (v, lval_opt)))
       | NONE => NONE)
    | NONE => NONE
`;

(* Fills a fresh scope with the values of the arguments of a called function.
 * Note: used in e_call_newframe *)
val all_arg_update_for_newscope_def = Define `
  all_arg_update_for_newscope xlist dlist elist ss = 
    FOLDL (update_arg_for_newscope ss) (SOME FEMPTY) (ZIP (dlist, ZIP(xlist, elist)))
`;


(* full copyin definition *)
val copyin_def = Define `
  copyin xlist dlist elist gsl ss_curr = 
    all_arg_update_for_newscope xlist dlist elist (gsl++ss_curr)
`;


(* Updates a scope stack by mapping the variable name a to the value v
 * in the topmost scope where a is defined,
 * written as [a -> v], colloquially known as assignment.
 * Note that this function is used in the assignment and return rules *)
val assign_def = Define `
  (assign ss v (lval_varname x) =
    case find_topmost_scope ss x of
    | SOME (i, sc) =>
      (case lookup_out ss x of
       | SOME str_opt =>
         SOME (LUPDATE (sc |+ (x, (v, str_opt))) i ss)
       | NONE => NONE)
    | _ => NONE) /\
  (assign ss v (lval_field lval f) =
    case lookup_lval ss lval of
    | SOME (v_struct f_v_l) =>
      (case INDEX_OF f (MAP FST f_v_l) of
       | SOME i => assign ss (v_struct (LUPDATE (f, v) i f_v_l)) lval
       | NONE => NONE)
    | SOME (v_header validity f_v_l) =>
      (case INDEX_OF f (MAP FST f_v_l) of
       | SOME i => assign ss (v_header validity (LUPDATE (f, v) i f_v_l)) lval
       | NONE => NONE)
    | _ => NONE
  ) /\
  (assign ss v lval_null =
    SOME ss
  )
`;

(* Declares a new variable and initialises it to ARB, returns the new scope stack *)
(* TODO: Behaviour when variable already exists? *)
(* Note that this will declare variables in the block-global scope when scope stack is empty *)
val declare_def = Define `
  (declare g_scope_list (ss:scopes_stack) x t =
    case ss of
    | [] => (LUPDATE (FUPDATE (EL 1 g_scope_list) (varn_name x, (arb_from_t t, NONE))) 1 g_scope_list, [])
    | _ =>
     let i = LENGTH ss - 1 in
     let scope = EL i ss in
     (g_scope_list, LUPDATE (FUPDATE scope (varn_name x, (arb_from_t t, NONE))) i ss)
  )
`;

(* Initialises a new variable in the topmost scope. *)
val initialise_def = Define `
  (initialise (ss:scopes_stack) varn v =
    LUPDATE (FUPDATE (LAST ss) (varn, (v, NONE))) (LENGTH ss - 1) ss
  )
`;

(* Looks up the function signature and body for an abstract function name. *)
val lookup_funn_sig_body_def = Define `
  (lookup_funn_sig_body funn func_map ext_map =
    case funn of
    | (funn_name x) =>
     (case FLOOKUP func_map x of
      | SOME (stmt, x_d_l) => SOME (stmt, x_d_l)
      | NONE => NONE)
    | (funn_inst x) =>
     (case FLOOKUP ext_map x of
      | SOME (SOME (stmt, x_d_l), _) => SOME (stmt, x_d_l)
      | _ => NONE)
    | (funn_ext x x') =>
     (case FLOOKUP ext_map x of
      | SOME (_, ext_fun_map) =>
       (case FLOOKUP ext_fun_map x' of
	| SOME (stmt, x_d_l) => SOME (stmt, x_d_l)
	| _ => NONE)
      | _ => NONE)
  )
`;

val lookup_funn_sig_def = Define `
  (lookup_funn_sig funn func_map ext_map =
    case lookup_funn_sig_body funn func_map ext_map of
    | SOME (_, x_d_l) => SOME x_d_l
    | NONE => NONE
  )
`;

(* Given lists of variable names and directions, a caller's scope stack ss
 * and a callees scope_stack ss_curr, updates the caller's scope stack
 * according to the calling conventions. *)
val update_return_frame_def = Define `
  update_return_frame xlist dlist ss ss_curr = 
    FOLDL
      (\ss_temp_opt (x,d).
        if (is_d_none_in d)
        then ss_temp_opt
        else
          case ss_temp_opt of
          | SOME ss_temp =>
           (case lookup_tup ss_curr (varn_name x) of
            | SOME (v, str_opt) =>
              (case str_opt of
               | SOME str => assign ss_temp v str
               | NONE => NONE)
            | _ => NONE)
          | NONE => NONE
      )
      (SOME ss)
      (ZIP(xlist, dlist))
`;

val args_of_pbl_def = Define `
  (args_of_pbl (pblock_parser x_d_list stmt pars_map) = x_d_list) /\
  (args_of_pbl (pblock_control x_d_list stmt stmt' tbl_map) = x_d_list)
`;

(* Implements the whole copyout operation to the caller scope stack. Given list of arguments
 * of the funtion i.e. names and directions, global scope list, caller scope stack and current
 * scope stack, it will return a tuple where first element is a global scope list updated with
 * the copy-outs, and the second element is the caller's scope updated with the copy-outs *)
val copyout_def = Define `
  copyout xlist dlist gsl ss ss_curr =
    case update_return_frame xlist dlist (gsl++ss) ss_curr of
    | SOME updated_return_ss =>
     SOME (TAKE 2 updated_return_ss, DROP 2 updated_return_ss)
    | NONE => NONE
`;

val sel_def = Define `
  sel v (v_x_list) x = 
    case (FIND (\(ks, s). ks = v) v_x_list) of
    | SOME (v, x') => x'
    | NONE => x
`;

val fully_reduced_def = Define `
  fully_reduced e =
    case e of
    | (e_v (v_str _)) => T
    | _ => F
`;

val not_top_return_def = Define `
  not_top_return frame_list =
    case frame_list of
    | [(funn, stmt, scopes_stack)] =>
      (case stmt of
      | stmt_ret e => T
      | stmt_seq (stmt_ret e) _ => T
      | _ => F)
    | _ => F
`;

(* check if the status is not a return *)
val notret_def = Define `
  (notret (status_returnv v) = F) /\
  (notret _ = T)
`;


(* fetch the newest scope index from a scopes stack *)
val newest_scope_ind_def = Define `
  newest_scope_ind scopes_stack = (LENGTH scopes_stack) - 1
`;

(* returns the newest (topmost) scope using the index from the newest_scope_ind_def *)
(* TODO: Use LAST instead? *)
val newest_scope_def = Define `
  newest_scope scopes_stack = EL (newest_scope_ind scopes_stack) scopes_stack
`;

(* Init the variable name star in the topmost scope and return only the scope *)
val decl_init_star_def = Define `
  decl_init_star scopes_stack v varn_star =
    FUPDATE (newest_scope scopes_stack) (varn_star, (v , NONE))
`;

(* TODO: Use initialise_def? *)
(* Init the variable name star in the topmost scope and return the updated scope stack *)
val init_in_highest_scope_def = Define `
  init_in_highest_scope scopes_stack v varn_star =
    LUPDATE (decl_init_star scopes_stack v varn_star) (newest_scope_ind scopes_stack) scopes_stack
`;

}}
grammar


defns
e_sem :: '' ::=
defn
ctx g_scope_list scopes_stack ( e ) ~> ( e' , frame_list ) :: :: e_red :: e_
{{ com expression semantics }}
{{ tex [[ctx]] \, [[g_scope_list]] \, [[scopes_stack]] \vdash ( [[e]] ) \rightsquigarrow  ( [[e']] , [[frame_list]] ) }}
by

%%%%%%%%%%%%%%%%%
%Variable look-up

v = lookup_vexp2 ( scopes_stack , g_scope_list , varn )
----------------------------------- :: lookup
ctx g_scope_list scopes_stack ( var varn ) ~> ( v ,  empty )

%%%%%%%%%%%%%%
%Function/method call

%Function call construction of new frame
( stmt , [ ( x1 , d1 ) , .. , ( xn , dn ) ] ) = lookup_funn_sig_body ( funn , func_map , ext_map )
check_args_red [ d1 , .. , dn ] [ e1 , .. , en ]
scope' = copyin ( ( x1 , .. , xn ) , [ d1 , .. , dn ] , [ e1 , .. , en ] , g_scope_list , scopes_stack )
----------------------------------- :: call_newframe
( ty_map , ext_map , func_map , tbl_map ) g_scope_list scopes_stack ( call funn ( e1 , .. , en ) ) ~> ( var star , [ ( funn , stmt , [ scope' ] ) ] )

%Function call reduction of arguments
[ ( x1 , d1 ) , .. , ( xn , dn ) ] = lookup_funn_sig ( funn , func_map , ext_map )
unred_arg_index [ d1 , .. , dn ] [ e1 , .. , en ] = i
e = [ e1 , .. , en ] [ i ]
( ty_map , ext_map , func_map , tbl_map ) g_scope_list scopes_stack ( e ) ~> ( e' , frame_list )
[ e'1 , .. , e'n ] =' update ( e' , i , [ e1 , .. , en ] )
----------------------------------- :: call_args
( ty_map , ext_map , func_map , tbl_map ) g_scope_list scopes_stack ( call funn ( e1 , .. , en ) ) ~> ( call funn ( e'1 , .. , e'n ) , frame_list )

%Struct field access
v = struct { f1 = v1 ; ... ; fn = vn } ( f )
----------------------------------- :: s_acc
ctx g_scope_list scopes_stack ( struct { f1 = v1 ; ... ; fn = vn } . f ) ~> ( v ,  empty )

%Header field access
v = header boolv { f1 = v1 ; ... ; fn = vn } ( f )
----------------------------------- :: h_acc
ctx g_scope_list scopes_stack ( header boolv { f1 = v1 ; ... ; fn = vn } . f ) ~> ( v ,  empty )

%Case select lookup
x' = { v1 : x1 ; ... ; vn : xn } x ( v )
----------------------------------- :: sel_acc
ctx g_scope_list scopes_stack ( select v { v1 : x1 ; ... ; vn : xn } x ) ~> ( x' ,  empty )

%concatination of two bitstrings 

ctx g_scope_list scopes_stack ( e ) ~> ( e'' , frame_list )
----------------------------------- :: concat_arg1
ctx g_scope_list scopes_stack ( concat e e' ) ~> ( concat e'' e' , frame_list )


ctx g_scope_list scopes_stack ( e ) ~> ( e' , frame_list )
----------------------------------- :: concat_arg2
ctx g_scope_list scopes_stack ( concat bitv e ) ~> ( concat bitv e' , frame_list )


bitv'' = concat bitv bitv'
----------------------------------- :: concat_v
ctx g_scope_list scopes_stack ( concat bitv bitv' ) ~> ( bitv'' , empty )


%bit slicing operation

ctx g_scope_list scopes_stack ( e ) ~> ( e' , frame_list )
----------------------------------- :: slice_arg1
ctx g_scope_list scopes_stack ( e [ bitv : bitv' ] ) ~> ( e' [ bitv : bitv' ] , frame_list )

%compile time known values from p4 spec. 
bitv''' = bitv [ bitv' : bitv'' ]
----------------------------------- :: slice_v
ctx g_scope_list scopes_stack ( bitv [ bitv' : bitv'' ] ) ~> ( bitv''' , empty )


%Struct/header field accesses
%(looks nicer with left-to-right, since we avoid writing out an explicit struct)
ctx g_scope_list scopes_stack ( e ) ~> ( e' , frame_list )
----------------------------------- :: acc_arg1
ctx g_scope_list scopes_stack ( e . x ) ~> ( e' . x , frame_list )

is_not_fully_red e'
ctx g_scope_list scopes_stack ( e' ) ~> ( e'' , frame_list )
----------------------------------- :: acc_arg2
ctx g_scope_list scopes_stack ( e . e' ) ~> ( e . e'' , frame_list )

%Select

ctx g_scope_list scopes_stack ( e ) ~> ( e' , frame_list )
----------------------------------- :: sel_arg
ctx g_scope_list scopes_stack ( select e { v1 : x1 ; ... ; vn : xn } x ) ~> ( select e' { v1 : x1 ; ... ; vn : xn } x , frame_list )


%Unary operations

ctx g_scope_list scopes_stack ( e ) ~> ( e' , frame_list )
----------------------------------- :: unop_arg
ctx g_scope_list scopes_stack ( unop e ) ~> ( unop e' , frame_list )

%Binary operations

ctx g_scope_list scopes_stack ( e ) ~> ( e'' , frame_list )
----------------------------------- :: binop_arg1
ctx g_scope_list scopes_stack ( e binop e' ) ~> ( e'' binop e' , frame_list )

%TODO: Enforce short-circuit evaluation for AND, OR on Booleans?
ctx g_scope_list scopes_stack ( e ) ~> ( e' , frame_list )
----------------------------------- :: binop_arg2
ctx g_scope_list scopes_stack ( v binop e ) ~> ( v binop e' , frame_list )


%%%%%%%%%%%%%%%%%%%
%Unary expressions%
%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%
%Boolean negation

! b = b'
----------------------------------- :: neg_bool
ctx g_scope_list scopes_stack ( ! b ) ~> ( b' , empty )

%%%%%%%%%%%%%%%%%%%
%Bitwise complement

~ bitv = bitv'
----------------------------------- :: compl
ctx g_scope_list scopes_stack ( ~ bitv ) ~> ( bitv' , empty )

%%%%%%%%%%%%%%%%
%Signed negation

- bitv = bitv'
----------------------------------- :: neg_signed
ctx g_scope_list scopes_stack ( - bitv ) ~> ( bitv' , empty )


%%%%%%%%%%%
%Unary plus

+ bitv = bitv'
----------------------------------- :: un_plus
ctx g_scope_list scopes_stack ( + bitv ) ~> ( bitv' , empty )


%%%%%%%%%%%%%%%%%%%%
%Binary expressions%
%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%
%Multiplication

bitv * bitv' = bitv''
----------------------------------- :: mul
ctx g_scope_list scopes_stack ( bitv * bitv' ) ~> ( bitv'' , empty )


%%%%%%%%%%%%%%%
%Division

bitv / bitv' = bitv''
----------------------------------- :: div
ctx g_scope_list scopes_stack ( bitv / bitv' ) ~> ( bitv'' , empty )
%%%%%%%%%%%%%%%
%Modulo

bitv mod bitv' = bitv''
----------------------------------- :: mod
ctx g_scope_list scopes_stack ( bitv mod bitv' ) ~> ( bitv'' , empty )

%%%%%%%%%%%%
%Addition

bitv + bitv' = bitv''
----------------------------------- :: add
ctx g_scope_list scopes_stack ( bitv + bitv' ) ~> ( bitv'' , empty )

%%%%%%%%%%%%
%Subtraction

bitv - bitv' = bitv''
----------------------------------- :: sub
ctx g_scope_list scopes_stack ( bitv - bitv' ) ~> ( bitv'' , empty )


%%%%%%%%%%%%
%Left shift

bitv SHL bitv' = bitv''
----------------------------------- :: shl
ctx g_scope_list scopes_stack ( bitv SHL bitv' ) ~> ( bitv'' , empty )

%%%%%%%%%%%%
%Right shift

bitv SHR bitv' = bitv''
----------------------------------- :: shr
ctx g_scope_list scopes_stack ( bitv SHR bitv' ) ~> ( bitv'' , empty )

%%%%%%%%%%%%%%%%%%%
%Less than or equal

bitv LE bitv' = b
----------------------------------- :: le
ctx g_scope_list scopes_stack ( bitv LE bitv' ) ~> ( b , empty )

%%%%%%%%%%%%%%%%%%%%%%
%Greater than or equal

bitv GE bitv' = b
----------------------------------- :: ge
ctx g_scope_list scopes_stack ( bitv GE bitv' ) ~> ( b , empty )

%%%%%%%%%%
%Less than

bitv < bitv' = b
----------------------------------- :: lt
ctx g_scope_list scopes_stack ( bitv < bitv' ) ~> ( b , empty )
%%%%%%%%%%%%%
%Greater than

bitv > bitv' = b
----------------------------------- :: gt
ctx g_scope_list scopes_stack ( bitv > bitv' ) ~> ( b , empty )

%%%%%%%%%%%%%
%Not equal

bitv NE bitv' = b
----------------------------------- :: neq
ctx g_scope_list scopes_stack ( bitv NE bitv' ) ~> ( b , empty )

(x <> x') = b
----------------------------------- :: neq_error
ctx g_scope_list scopes_stack ( (errmsg x) NE (errmsg x') ) ~> ( b , empty )

b NE b' = b''
----------------------------------- :: neq_bool
ctx g_scope_list scopes_stack ( b NE b' ) ~> ( b'' , empty )

%%%%%%%%%%%%%
%Equal

bitv EQ bitv' = b
----------------------------------- :: eq
ctx g_scope_list scopes_stack ( bitv EQ bitv' ) ~> ( b , empty )


(x EQ x') = b
----------------------------------- :: eq_error
ctx g_scope_list scopes_stack ( (errmsg x) EQ (errmsg x') ) ~> ( b , empty )



b EQ b' = b''
----------------------------------- :: eq_bool
ctx g_scope_list scopes_stack ( b EQ b' ) ~> ( b'' , empty )


%%%%%%%%%%%%%
%Bitwise and

bitv & bitv' = bitv''
----------------------------------- :: and
ctx g_scope_list scopes_stack ( bitv & bitv' ) ~> ( bitv'' , empty )


%%%%%%%%%%%%%
%Bitwise xor

bitv ^ bitv' = bitv''
----------------------------------- :: xor
ctx g_scope_list scopes_stack ( bitv ^ bitv' ) ~> ( bitv'' , empty )



%%%%%%%%%%%%%
%Bitwise or

bitv | bitv' = bitv''
----------------------------------- :: or
ctx g_scope_list scopes_stack ( bitv | bitv' ) ~> ( bitv'' , empty )


%%%%%%%%%%%%%
%Binary and
%Note: This uses short-circuit evaluation

----------------------------------- :: bin_and1
ctx g_scope_list scopes_stack ( false AND e ) ~> ( false , empty )


----------------------------------- :: bin_and2
ctx g_scope_list scopes_stack ( true AND e ) ~> ( b , empty )

%%%%%%%%%%%%%
%Binary or
%Note: This uses short-circuit evaluation

----------------------------------- :: bin_or1
ctx g_scope_list scopes_stack ( true OR e ) ~> ( true , empty )


----------------------------------- :: bin_or2
ctx g_scope_list scopes_stack ( false OR e ) ~> ( b , empty )


%%%%%%%%%%%%%%%%%%%%%%%
% Statement semantics %
%%%%%%%%%%%%%%%%%%%%%%%

%TODO: Exit
%TODO: Switch

defns
  stmt_sem :: '' ::=
defn
  ctx state -> state' :: :: stmt_red :: stmt_
  {{ com stmt semantics }}
  {{ tex [[ctx]] \vdash  [[state]] \rightarrow  [[state']] }}
by

  frame_list'' neq empty
  notret( status' )
  ctx ( g_scope_list , [ frame ] , ctrl , status ) -> ( g_scope_list' , frame_list' , ctrl' , status' )
  ----------------------------------- :: comp1
  ctx ( g_scope_list , [ frame ] ++ frame_list'' , ctrl , status ) -> ( g_scope_list' , frame_list' ++ frame_list'' , ctrl' , status' )

%Note that stmt must be return v, so ctrl cannot be modified by this reduction
  ( ty_map , ext_map , func_map , tbl_map ) ( g_scope_list , [ ( funn , stmt , scopes_stack ) ] , ctrl , Running ) -> ( g_scope_list , [ ( funn , stmt'' , scopes_stack ) ] , ctrl , Ret v )
  scopes_stack'' = init_in_highest_scope ( ( g_scope_list ++ scopes_stack' ) , v , star )
  g_scope = scopes_stack'' [0]
  g_scope' = scopes_stack'' [1]
  scopes_stack''' = tl (tl scopes_stack'')
  ( stmt''' , [ ( x1 , d1 ) , .. , ( xn , dn ) ] ) = lookup_funn_sig_body ( funn , func_map , ext_map )
  ( g_scope_list' , scopes_stack'''' ) = copyout ( ( x1 , .. , xn ) , [ d1 , .. , dn ] , [ g_scope ; g_scope' ] , scopes_stack''' , scopes_stack )
  ----------------------------------- :: comp2
  ( ty_map , ext_map , func_map , tbl_map ) ( g_scope_list , [ ( funn , stmt , scopes_stack ) ] ++ ( [ ( funn' , stmt' , scopes_stack' ) ] ++ frame_list ) , ctrl , Running ) -> ( g_scope_list' , [ ( funn' , stmt' , scopes_stack'''' ) ] ++ frame_list , ctrl , Running )


  scopes_stack' = assign ( ( g_scope_list ++ scopes_stack ) , v , lval )
  g_scope = scopes_stack' [0]
  g_scope' = scopes_stack' [1]
  scopes_stack'' = tl (tl scopes_stack')
  ----------------------------------- :: ass_v
  ctx ( g_scope_list , [ ( funn , assign lval v , scopes_stack ) ] , ctrl , Running ) -> ( [ g_scope ; g_scope' ] , [ ( funn , empty_stmt , scopes_stack'' ) ]  , ctrl , Running )


  ----------------------------------- :: ass_null
  ctx ( g_scope_list , [ ( funn , assign null v , scopes_stack ) ] , ctrl , Running ) -> ( g_scope_list , [ ( funn , empty_stmt , scopes_stack ) ] , ctrl , Running )


%%%%%%%%%%%%%%
%Sequence

  ctx ( g_scope_list , [ ( funn , stmt1 , scopes_stack ) ] , ctrl , Running ) -> ( g_scope_list' , frame_list ++ [ ( funn , stmt1' , scopes_stack' ) ] , ctrl' , Running )
  ----------------------------------- :: seq1
  ctx ( g_scope_list , [ ( funn , stmt1 ; stmt2 , scopes_stack ) ] , ctrl , Running ) -> ( g_scope_list' , frame_list ++ [ ( funn , stmt1' ; stmt2 , scopes_stack' ) ] , ctrl' , Running )


  ----------------------------------- :: seq2
  ctx ( g_scope_list , [ ( funn , empty_stmt ; stmt , scopes_stack ) ] , ctrl , Running ) -> ( g_scope_list , [ ( funn , stmt , scopes_stack ) ] , ctrl , Running )


  ctx ( g_scope_list , [ ( funn , stmt1 , scopes_stack ) ] , ctrl , Running ) -> ( g_scope_list' , [ ( funn , stmt1' , scopes_stack' ) ] , ctrl' , status )
  notrun( status )
  ----------------------------------- :: seq3
  ctx ( g_scope_list , [ ( funn , stmt1 ; stmt2 , scopes_stack ) ] , ctrl , Running ) -> ( g_scope_list' , [ ( funn , stmt1' , scopes_stack' ) ] , ctrl' , status )

%%%%%%%%%%%%%%
%Conditional

  ----------------------------------- :: cond2
  ctx ( g_scope_list , [ ( funn , if true then stmt1 else stmt2 , scopes_stack ) ] , ctrl , Running ) -> ( g_scope_list , [ ( funn , stmt1 , scopes_stack ) ] , ctrl , Running )
 

  ----------------------------------- :: cond3
  ctx ( g_scope_list , [ ( funn , if false then stmt1 else stmt2 , scopes_stack ) ] , ctrl , Running ) -> ( g_scope_list , [ ( funn , stmt2 , scopes_stack ) ] , ctrl , Running )


%%%%%%%%%%%%%%
%Declaration (possibly with initializer) and Instantiation

  ( g_scope_list' , scopes_stack' ) = declare ( g_scope_list , scopes_stack , x , t )
  ----------------------------------- :: decl
  ctx ( g_scope_list , [ ( funn , decl t x - , scopes_stack ) ] , ctrl , Running ) -> ( g_scope_list' , [ ( funn , empty_stmt , scopes_stack' ) ] , ctrl , Running )

%TODO: Check type agreement between t and initial value?
  scopes_stack' = initialise ( g_scope_list ++ scopes_stack , x' , v )
  g_scope = scopes_stack' [0]
  g_scope' = scopes_stack' [1]
  scopes_stack'' = tl (tl scopes_stack')
  ----------------------------------- :: init
  ctx ( g_scope_list , [ ( funn , decl t x v , scopes_stack ) ] , ctrl , Running ) -> ( [ g_scope ; g_scope' ] , [ ( funn , empty_stmt , scopes_stack'' ) ] , ctrl , Running )

%%%%%%%%%%%%%%
%Block

  scopes_stack' =  scopes_stack ++ [ emptyscope ]
  ----------------------------------- :: block_enter
  ctx ( g_scope_list , [ ( funn , begin stmt end , scopes_stack ) ] , ctrl , Running ) -> ( g_scope_list , [ ( funn , begin' stmt end' , scopes_stack' ) ] , ctrl , Running )


  ctx ( g_scope_list , [ ( funn , stmt , scopes_stack ) ] , ctrl , status ) -> ( g_scope_list' , frame_list ++ [ ( funn , stmt' , scopes_stack' ) ] , ctrl' , status' )
  ----------------------------------- :: block_exec
  ctx ( g_scope_list , [ ( funn , begin' stmt end' , scopes_stack ) ] , ctrl , status ) -> ( g_scope_list , frame_list ++ [ ( funn , begin' stmt' end' , scopes_stack' ) ] , ctrl' , status' )


  scopes_stack' = rev ( tl ( rev scopes_stack ) )
  ----------------------------------- :: block_exit
  ctx ( g_scope_list , [ ( funn , begin' empty_stmt end' , scopes_stack ) ] , ctrl , status ) -> ( g_scope_list , [ ( funn , empty_stmt , scopes_stack' ) ] , ctrl , status )


%%%%%%%%%%%%%%
%Verify

%Case predicate holds
  ------------------------------------------------- :: verify_3
  ctx ( g_scope_list , [ ( funn , verify true ( errmsg x ) , scopes_stack ) ] , ctrl , Running ) -> ( g_scope_list , [ ( funn , empty_stmt , scopes_stack ) ] , ctrl , Running )


%Case predicate does not hold
  x' = parseError
  x'' = "reject"
  ------------------------------------------------- :: verify_4
  ctx ( g_scope_list , [ ( funn , verify false ( errmsg x ) , scopes_stack ) ] , ctrl , Running ) -> ( g_scope_list , [ ( funn , assign x' ( errmsg x ) ; transition x'' , scopes_stack ) ] , ctrl , Running )


%%%%%%%%%%%%%%
%Transition

  not_final_state ( x )
  ------------------------------------------------- :: trans_1
  ctx ( g_scope_list , [ ( funn , transition x , scopes_stack ) ] , ctrl , Running ) -> ( g_scope_list , [ ( funn , empty_stmt , scopes_stack ) ] , ctrl , Trans x )


  x = "accept"
  ------------------------------------------------- :: trans_2
  ctx ( g_scope_list , [ ( funn , transition x , scopes_stack ) ] , ctrl , Running ) -> ( g_scope_list , [ ( funn , empty_stmt , scopes_stack ) ] , ctrl , Accept )

  x = "reject"
  ------------------------------------------------- :: trans_3
  ctx ( g_scope_list , [ ( funn , transition x , scopes_stack ) ] , ctrl , Running ) -> ( g_scope_list , [ ( funn , empty_stmt , scopes_stack ) ] , ctrl , Reject )


%%%%%%%%%%%%%%
%The action is treated as a function call
  tbl_map ( tbl ) = ( e' , mk )
  ctrl ( tbl , v , mk ) = ( f , ( v1 , .. , vn ) )
  ----------------------------------- :: apply_table_v
  ( ty_map , ext_map , func_map , tbl_map ) ( g_scope_list , [ ( funn , apply tbl v , scopes_stack ) ] , ctrl , Running ) -> ( g_scope_list , [ ( funn , assign null ( call f ( v1 , .. , vn ) ) , scopes_stack ) ] , ctrl , Running )


%%%%%%%%%%%%%%
%Return

  ----------------------------------- :: return_v
  ( ty_map , ext_map , func_map , tbl_map ) ( g_scope_list , [ ( funn , return v , scopes_stack ) ] , ctrl , Running ) -> ( g_scope_list , [ ( funn , empty_stmt , scopes_stack ) ] , ctrl , Ret v )

%%%%%%%%%%%%%%
%Extern
  ( g_scope_list' , scopes_stack' , ctrl' ) = ext ( g_scope_list , scopes_stack , ctrl )
  ----------------------------------- :: ext
  ( ty_map , ext_map , func_map , tbl_map ) ( g_scope_list , [ ( funn , ext , scopes_stack ) ] , ctrl , Running ) -> ( g_scope_list' , [ ( funn , empty_stmt , scopes_stack' ) ] , ctrl' , Running )
 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Reduction of expression rules %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%Reduction step of declare with initializer/instantiation
  ctx g_scope_list scopes_stack ( e ) ~> ( e' , frame_list )
  ----------------------------------- :: init_e
  ctx ( g_scope_list , [ ( funn , decl t x e , scopes_stack ) ] , ctrl , Running ) -> ( g_scope_list , frame_list ++ [ ( funn , decl t x e' , scopes_stack ) ] , ctrl , Running )

%Reduction step of return expression

  ctx g_scope_list scopes_stack ( e ) ~> ( e' , frame_list )
  ----------------------------------- :: ret_e
  ctx ( g_scope_list , [ ( funn , return e , scopes_stack ) ] , ctrl , Running ) -> ( g_scope_list , frame_list ++ [ ( funn , return e' , scopes_stack ) ] , ctrl , Running )


%Reduction step of assign expression
  ctx g_scope_list scopes_stack ( e ) ~> ( e' , frame_list )
  ----------------------------------- :: ass_e
  ctx ( g_scope_list , [ ( funn , assign lval e , scopes_stack ) ] , ctrl , Running ) -> ( g_scope_list , frame_list ++ [ ( funn , assign lval e' , scopes_stack ) ] , ctrl , Running )


%Reduction step of condition
  ctx g_scope_list scopes_stack ( e ) ~> ( e' , frame_list )
  ----------------------------------- :: cond_e
  ctx ( g_scope_list , [ ( funn , if e then stmt1 else stmt2 , scopes_stack ) ] , ctrl , Running ) -> ( g_scope_list , frame_list ++ [ ( funn , if e' then stmt1 else stmt2 , scopes_stack ) ] , ctrl , Running )


%Reduction step of verify predicate
  ctx g_scope_list scopes_stack ( e ) ~> ( e'' , frame_list )
  ------------------------------------------------- :: verify_e1
  ctx ( g_scope_list , [ ( funn , verify e e' , scopes_stack ) ] , ctrl , Running ) -> ( g_scope_list , frame_list ++ [ ( funn , verify e'' e' , scopes_stack ) ] , ctrl , Running )
  

%Reduction step of error message
  ctx g_scope_list scopes_stack ( e ) ~> ( e' , frame_list )
  ------------------------------------------------- :: verify_e2
  ctx ( g_scope_list , [ ( funn , verify b e , scopes_stack ) ] , ctrl , Running ) -> ( g_scope_list , frame_list ++ [ ( funn , verify b e' , scopes_stack ) ] , ctrl , Running )


%Reduction step of transition
  ctx g_scope_list scopes_stack ( e ) ~> ( e' , frame_list )
  ------------------------------------------------- :: trans_e
  ctx ( g_scope_list , [ ( funn , transition e , scopes_stack ) ] , ctrl , Running ) -> ( g_scope_list , frame_list ++ [ ( funn , transition e' , scopes_stack ) ] , ctrl , Running )


%Reduction step of match-action expression
  ctx g_scope_list scopes_stack ( e ) ~> ( e' , frame_list )
  ----------------------------------- :: apply_table_e
  ctx ( g_scope_list , [ ( funn , apply tbl e , scopes_stack ) ] , ctrl , Running ) -> ( g_scope_list , frame_list ++ [ ( funn , apply tbl e' , scopes_stack ) ] , ctrl , Running )


%%%%%%%%%%%%%%%%%%%%%%%%%%
% Parser block semantics %
%%%%%%%%%%%%%%%%%%%%%%%%%%
%This isolates the unstructured parser block semantics into a set of rules defined in terms
%of the regular statement semantics.

defns
  pars_sem :: '' ::=
defn
  pctx state -p-> state' :: :: pars_red :: pars_
  {{ com parser block semantics }}
  {{ tex [[pctx]] \vdash [[state]] {\longrightarrow}_{p} [[state]] }}
by

%This rule describes how individual statement steps are taken inside the parser
  status_not_fin status
  (ty_map, ext_map, func_map, empty) ( g_scope_list , frame_list , ctrl, status ) -> state'
  ------------------------------------------------- :: stmt
  (ty_map, ext_map, func_map, pars_map) ( g_scope_list , frame_list , ctrl, status ) -p-> state'

%This rule governs transitions between parser states
%TODO: OK if function name is set to parser state name?
  (ty_map, ext_map, func_map, empty) ( g_scope_list , frame_list , ctrl, Running ) -> ( g_scope_list , frame_list' , ctrl, Trans x )
  stmt'' = pars_map ( x )
  ------------------------------------------------- :: state
  (ty_map, ext_map, func_map, pars_map) ( g_scope_list , frame_list , ctrl, Running ) -p-> ( g_scope_list , [ ( x , stmt'' , [ emptyscope ] ) ] , ctrl, Running )

%If the end of some parser state is reached without status change, we reject
  (ty_map, ext_map, func_map, empty) ( g_scope_list , frame_list , ctrl, Running ) -> ( g_scope_list' , [ ( funn , empty_stmt , scopes_stack ) ] , ctrl', Running )
  x = "reject"
  ------------------------------------------------- :: empty
  (ty_map, ext_map, func_map, pars_map) ( g_scope_list , frame_list , ctrl, Running ) -p-> ( g_scope_list' , [ ( funn , transition x , scopes_stack ) ] , ctrl', Running )

%This describes the final step of the parser
  (ty_map, ext_map, func_map, empty) ( g_scope_list , frame_list , ctrl, Running ) -> ( g_scope_list , frame_list , ctrl, pars_fin )
  ------------------------------------------------- :: fin
  (ty_map, ext_map, func_map, pars_map) ( g_scope_list , frame_list , ctrl, Running ) -p-> ( g_scope_list , frame_list , ctrl, pars_fin )


%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Control block semantics %
%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
  ctrl_sem :: '' ::=
defn
  cctx state -c-> state' :: :: ctrl_red :: ctrl_
  {{ com control block semantics }}
  {{ tex [[cctx]] \vdash [[state]] {\longrightarrow}_{c} [[state']] }}
by

  not_top_return frame_list
  (ty_map, ext_map, func_map, tbl_map) ( g_scope_list , frame_list , ctrl, status ) -> ( g_scope_list' , frame_list' , ctrl', status' )
  ------------------------------------------------- :: stmt
  (ty_map, ext_map, func_map, tbl_map) ( g_scope_list , frame_list , ctrl, status ) -c-> ( g_scope_list' , frame_list' , ctrl', status' )

  ------------------------------------------------- :: ret
  cctx ( g_scope_list , [ ( funn , return v , scopes_stack ) ] , ctrl, status ) -c-> ( g_scope_list , [ ( funn , empty_stmt , scopes_stack ) ] , ctrl, status )

  ------------------------------------------------- :: ret_2
  cctx ( g_scope_list , [ ( funn , return v ; stmt , scopes_stack ) ] , ctrl, status ) -c-> ( g_scope_list , [ ( funn , empty_stmt , scopes_stack ) ] , ctrl, status )

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Architectural-level semantics %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%TODO: Use varn, copyin, copyout in these rules also wherever applicatble

defns
  arch_sem :: '' ::=
defn
  actx ( aenv , g_scope_list , arch_frame_list , ctrl , status ) -'> ( aenv' , g_scope_list' , arch_frame_list' , ctrl' , status' ) :: :: arch_red :: arch_
  {{ com architecture-level semantics }}
  {{ tex [[actx]] \vdash ( [[aenv]], [[g_scope_list]], [[arch_frame_list]], [[ctrl]],  [[status]] ) {\longrightarrow}_{A} ( [[aenv']], [[g_scope_list']], [[arch_frame_list']], [[ctrl']],  [[status']] ) }}
by

%Four different phases: Input, programmable block, fixed-function block and output.

  inp = ab_list [ i ]
  ( in_out_list'' , scope' ) = input_f ( in_out_list , scope )
  i' = i + 1
  ----------------------------------- :: in
  ( ab_list , pblock_map , ffblock_map , input_f , output_f , ty_map , ext_map , func_map ) ( ( i , false , in_out_list , in_out_list' , scope ) , g_scope_list , arch_frame_list_empty , ctrl , Running ) -'> ( ( i' , false , in_out_list'' , in_out_list' , scope' ) , g_scope_list , arch_frame_list_empty , ctrl , Running )

  %Note that this rule does not increment i. That happens when the pblock is finished.
  pbl x ( e1 , .. , en ) = ab_list [ i ]
  ----------------------------------- :: pbl_call
  ( ab_list , pblock_map , ffblock_map , input_f , output_f , ty_map , ext_map , func_map ) ( ( i , false , in_out_list , in_out_list' , scope ) , g_scope_list , arch_frame_list_empty , ctrl , Running ) -'> ( ( i , true , in_out_list , in_out_list' , scope ) , g_scope_list , pbl_call x ( e1 , .. , en ) , ctrl , Running )

  ffbl x ( e1 , .. , en ) = ab_list [ i ]
  ----------------------------------- :: ffbl_call
  ( ab_list , pblock_map , ffblock_map , input_f , output_f , ty_map , ext_map , func_map ) ( ( i , false , in_out_list , in_out_list' , scope ) , g_scope_list , arch_frame_list_empty , ctrl , Running ) -'> ( ( i , false , in_out_list , in_out_list' , scope ) , g_scope_list , ffbl_call x ( e1 , .. , en ) , ctrl , Running )

%Note that this always sets index to 0. This could be done conditionally, if it would not be ideal
%to have the final state have index 0.
  out = ab_list [ i ]
  ( in_out_list'' , scope' ) = output_f ( in_out_list' , scope )
  zero i'
  ----------------------------------- :: out
  ( ab_list , pblock_map , ffblock_map , input_f , output_f , ty_map , ext_map , func_map ) ( ( i , false , in_out_list , in_out_list' , scope ) , g_scope_list , arch_frame_list_empty , ctrl , Running ) -'> ( ( i' , false , in_out_list , in_out_list'' , scope' ) , g_scope_list , arch_frame_list_empty , ctrl , Running )


%The "programmable block" phase can initiate execution of either a parser block or a control block

%This should populate the block-global scope with arguments + parseError and then set up execution of initial decls+constructors
%Note that initiation of a parser block also sets parseError to NoError
  parser ( ( x1 , d1 ) , .. , ( xn , dn ) ) stmt pars_map = pblock_map ( f )
  x = "start"
  stmt' = pars_map ( x )
  check_args_red [ d1 , .. , dn ] [ e1 , .. , en ]
  scope' = all_arg_update_for_newscope ( ( x1 , .. , xn ) , [ d1 , .. , dn ] , [ e1 , .. , en ] , [ scope ] )
  g_scope'' = g_scope_list [0]
  g_scope_list' = [g_scope'']' ++ [ scope' ]
  v = errmsg "NoError"
  x' = "parseError"
  g_scope_list'' = initialise ( g_scope_list' , x' , v )
  %TODO: Model arch scope external to the P4 program using the call stack?
  ----------------------------------- :: parser_init
  ( ab_list , pblock_map , ffblock_map , input_f , output_f , ty_map , ext_map , func_map ) ( ( i , true , in_out_list , in_out_list' , scope ) , g_scope_list , pbl_call f ( e1 ,  .. , en ) , ctrl , Running ) -'> ( ( i , true , in_out_list , in_out_list' , scope ) , g_scope_list'' , [ ( f , stmt ; stmt' , emptyss ) ] , ctrl , Running )

  control ( ( x1 , d1 ) , .. , ( xn , dn ) ) stmt stmt' tbl_map = pblock_map ( f )
  check_args_red [ d1 , .. , dn ] [ e1 , .. , en ]
  %TODO: Should you also be able to read from the global scope?
  scope' = all_arg_update_for_newscope ( ( x1 , .. , xn ) , [ d1 , .. , dn ] , [ e1 , .. , en ] , [ scope ] )
  g_scope'' = g_scope_list [0]
  g_scope_list' = [g_scope'']' ++ [ scope' ]
  %TODO: Model pseudo-scope external to the P4 program using the call stack?
  ----------------------------------- :: control_init
  ( ab_list , pblock_map , ffblock_map , input_f , output_f , ty_map , ext_map , func_map ) ( ( i , true , in_out_list , in_out_list' , scope ) , g_scope_list , pbl_call f ( e1 ,  .. , en ) , ctrl , Running ) -'> ( ( i , true , in_out_list , in_out_list' , scope ) , g_scope_list' , [ ( f , stmt ; stmt' , emptyss ) ] , ctrl , Running )


%The "programmable block" phase then follows the semantics for a parser or control, respectively...
  %TODO: Create specific control block semantics?

%Note that this rule needs to check that execution is actually inside a parser block to remove ambiguity
  pbl x ( e1 , .. , en ) = ab_list [ i ]
  parser ( ( x1 , d1 ) , .. , ( xn , dn ) ) stmt pars_map = pblock_map ( x )
  status_not_fin status
  ( ty_map , ext_map , func_map , pars_map ) ( g_scope_list , frame_list , ctrl , status ) -p-> ( g_scope_list' , frame_list' , ctrl' , status' )
  ----------------------------------- :: parser_exec
  ( ab_list , pblock_map , ffblock_map , input_f , output_f , ty_map , ext_map , func_map ) ( ( i , true , in_out_list , in_out_list' , scope ) , g_scope_list , frame_list , ctrl , status ) -'> ( ( i , true , in_out_list , in_out_list' , scope ) , g_scope_list' , frame_list' , ctrl' , status' )

%Note that this rule needs to check that execution is actually inside a control block to remove ambiguity
  pbl x ( e1 , .. , en ) = ab_list [ i ]
  control ( ( x1 , d1 ) , .. , ( xn , dn ) ) stmt stmt' tbl_map = pblock_map ( x )
  ( ty_map , ext_map , func_map , tbl_map ) ( g_scope_list , frame_list , ctrl , status ) -c-> ( g_scope_list' , frame_list' , ctrl' , status' )
  ----------------------------------- :: control_exec
  ( ab_list , pblock_map , ffblock_map , input_f , output_f , ty_map , ext_map , func_map ) ( ( i , true , in_out_list , in_out_list' , scope ) , g_scope_list , frame_list , ctrl , status ) -'> ( ( i , true , in_out_list , in_out_list' , scope ) , g_scope_list' , frame_list' , ctrl' , status' )

%... until execution using the regular statement semantics has finished


%Note that exiting a parser block also sets the value of parseError
  pbl f ( e1 , .. , en ) = ab_list [ i ]
  parser ( ( x1 , d1 ) , .. , ( xn , dn ) ) stmt pars_map = pblock_map ( f )
  [ scope' ] = update_return ( g_scope_list , [ scope ] , [ d1 , .. , dn ] , ( x1 , .. , xn ) )
  lval = "parseError"
  x = "parseError"
  v = lookup_vexp ( g_scope_list , x )
  [ scope'' ] = assign ( [ scope' ] , v , lval )
  g_scope''' = g_scope_list [0]
  g_scope_list' = [ g_scope''' ]'
  i' = i + 1
  %TODO: Relax requirement that statement be empty in initial state?
  ----------------------------------- :: parser_ret
  ( ab_list , pblock_map , ffblock_map , input_f , output_f , ty_map , ext_map , func_map ) ( ( i , true , in_out_list , in_out_list' , scope ) , g_scope_list , frame_list , ctrl , pars_fin ) -'> ( ( i' , false , in_out_list , in_out_list' , scope'' ) , g_scope_list' , arch_frame_list_empty , ctrl , Running )

  pbl f ( e1 , .. , en ) = ab_list [ i ]
  control ( ( x1 , d1 ) , .. , ( xn , dn ) ) stmt stmt' tbl_map = pblock_map ( f )
  [ scope' ] = update_return ( g_scope_list , [ scope ] , [ d1 , .. , dn ] , ( x1 , .. , xn ) )
  g_scope'' = g_scope_list [0]
  g_scope_list' = [ g_scope'' ]'
  i' = i + 1
  ----------------------------------- :: control_ret
  ( ab_list , pblock_map , ffblock_map , input_f , output_f , ty_map , ext_map , func_map ) ( ( i , true , in_out_list , in_out_list' , scope ) , g_scope_list , [ ( funn , empty_stmt , scopes_stack ) ] , ctrl , Running ) -'> ( ( i' , false , in_out_list , in_out_list' , scope' ) , g_scope_list' , arch_frame_list_empty , ctrl , Running )

%TODO: What should happen when all input has been processed?
%      	    Separate judgment form?
%      	    Set status to Ended? Then all rules would need to exclude having the Ended status

  i' = i + 1
  ff ( ( x1 , d1 ) , .. , ( xn , dn ) ) = ffblock_map ( f )
  check_args_red [ d1 , .. , dn ] [ e1 , .. , en ]
  scope' = ff ( ( e1 ,  .. , en ) , scope )
  ----------------------------------- :: ffblock_exec
  ( ab_list , pblock_map , ffblock_map , input_f , output_f , ty_map , ext_map , func_map ) ( ( i , false , in_out_list , in_out_list' , scope ) , g_scope_list , ffbl_call f ( e1 ,  .. , en ) , ctrl , status ) -'> ( ( i' , false , in_out_list , in_out_list' , scope' ) , g_scope_list , arch_frame_list_empty , ctrl , status' )

%"Reduction of argument" rules

%Note that the use of "args_of_pbl" is to avoid having two separate rules for parser and control
%TODO: Restrict the expression evaluation to just lookup?
%NOTE: These rules already disallow function calls, because of the shape of the RHS of the expression reductions
  pblock = pblock_map ( f )
  ( ( x1 , d1 ) , .. , ( xn , dn ) ) = args_of_pbl ( pblock )
  unred_arg_index [ d1 , .. , dn ] [ e1 , .. , en ] = i'
  e = [ e1 , .. , en ] [ i' ]
  ( ty_map , ext_map , func_map , empty ) g_scope_list [ scope ] ( e ) ~> ( e' , empty )
  [ e'1 , .. , e'n ] =' update ( e' , i' , [ e1 , .. , en ] )
  ----------------------------------- :: pblock_args
  ( ab_list , pblock_map , ffblock_map , input_f , output_f , ty_map , ext_map , func_map ) ( ( i , false , in_out_list , in_out_list' , scope ) , g_scope_list , pbl_call f ( e1 , .. , en ) , ctrl , Running ) -'> ( ( i , false , in_out_list , in_out_list' , scope' ) , g_scope_list , pbl_call f ( e'1 , .. , e'n ) , ctrl , Running )

  ff ( ( x1 , d1 ) , .. , ( xn , dn ) ) = ffblock_map ( f )
  unred_arg_index [ d1 , .. , dn ] [ e1 , .. , en ] = i'
  e = [ e1 , .. , en ] [ i' ]
  ( ty_map , ext_map , func_map , empty ) g_scope_list [ scope ] ( e ) ~> ( e' , empty )
  [ e'1 , .. , e'n ] =' update ( e' , i' , [ e1 , .. , en ] )
  ----------------------------------- :: ffblock_args
  ( ab_list , pblock_map , ffblock_map , input_f , output_f , ty_map , ext_map , func_map ) ( ( i , false , in_out_list , in_out_list' , scope ) , g_scope_list , ffbl_call f ( e1 , .. , en ) , ctrl , Running ) -'> ( ( i , false , in_out_list , in_out_list' , scope' ) , g_scope_list , ffbl_call f ( e1' , .. , en' ) , ctrl , Running )

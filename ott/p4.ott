%For lists? Add more as needed
indexvar i, j ::= {{ isa num }} {{ coq nat }} {{ hol num }} x

metavar string ::=
      {{ lex alphanum }}
      {{ hol string }}
      {{ com string }}

metavar num ::=
      {{ lex numeral }}
      {{ hol num }}
      {{ com natural number }}

metavar bool ::=
      {{ lex numeral }}
      {{ hol bool }}
      {{ com boolean }}

%Integers (Coq Z) are word31s in OCaml Light syntax (metavar integer_literal)
metavar int ::=
      {{ lex numeral }}
      {{ hol word64 }}
      {{ com integer }}

grammar
direction :: direction_ ::= {{ com ??? }}
| In :: :: in
| Out :: :: out
| InOut :: :: in_out
| Directionless :: :: directionless

function_kind :: function_kind_ ::= {{ com ??? }}
| Parser :: :: parser
| Control :: :: control
| Extern :: :: extern
| Table :: :: table
| Action :: :: action
| Function :: :: function
| Builtin :: :: builtin

name :: name_ ::= {{ com ??? }}
| BareName string :: :: bare_name
    {{ com String argument called "nm" }}
| QualifiedName (list string) string :: :: qualified_name
    {{ com "Path" and "nm" }}

unary_operator :: unary_operator_ ::= {{ com ??? }}
| Not :: :: not
| BitNot :: :: bit_not
| BitMinus :: :: bit_minus

binary_operator :: binary_operator_ ::= {{ com ??? }}
| Plus :: :: plus
| PlusSat :: :: plus_sat
{{ com What is this operator??? }}
| Minus :: :: minus
| MinusSat :: :: minus_sat
{{ com What is this operator??? }}
| Mul :: :: mul
| Div :: :: div
| Mod :: :: mod
| Shl :: :: shl
| Shr :: :: shr
| Le :: :: le
| Ge :: :: ge
| Lt :: :: lt
| Gt :: :: gt
| Eq :: :: eq
| NotEq :: :: not_eq
| BitAnd :: :: bit_and
| BitXor :: :: bit_xor
| BitOr :: :: bit_or
| PlusPlus :: :: plus_plus
{{ com What is this operator??? }}
| And :: :: and
| Or :: :: or


type :: type_ ::= {{ com ??? }}
| Bool :: :: bool
| String :: :: string
| Integer :: :: integer
| Int nat :: :: int
{{ com Args: width }}
| Bit nat :: :: bit
{{ com Args: width }}
| VarBit nat :: :: var_bit
{{ com Args: width }}
| Array type nat :: :: array
{{ com Args: inner size }}
| Tuple list type :: :: tuple
{{ com Args: types }}
| RecordType (list (string * type)) :: :: record_type
{{ com Args: fields }}
| SetType type :: :: set_type
{{ com Args: inner }}
| Error :: :: error
| MatchKind :: :: match_kind
| TypeName string :: :: type_name
{{ com Args: name }}
| NewType type :: :: new_type
{{ com Args: inner }}
| Void :: :: void
| Header (list (string * type)) :: :: header
{{ com Args: fields }}
| HeaderUnion (list (string * type)) :: :: header_union
{{ com Args: fields }}
| Struct (list (string * type)) :: :: struct
{{ com Args: fields }}
| Enum string (list string) (option type) :: :: enum
{{ com Args: name members inner }}
| SpecializedType type (list type) :: :: specialized_type
{{ com Args: base args }}
| ExternType string (list string) (list (string * function)) :: :: extern_type
{{ com Args: name type_params methods }}
| FunctionType function :: :: function_type
{{ com Args: inner }}
| ActionType (list param) (list param)' :: :: action_type
{{ com Args: data_params control_params }}
| Constructor (list string) (list param) type :: :: constructor
{{ com Args: type_params params return_type }}

function :: function_ ::= {{ com Function argument? }}
| MkFunction (list string) (list param) (function_kind) type :: :: mk_function
{{ com Args: type_params parameters kind return_type }}

param :: param_ ::= {{ com ??? }}
| MkParam direction type string (option expression) :: :: mk_param
{{ com Args: dir typ variable opt_value }}

keyvalue :: keyvalue_ ::= {{ com ??? }}
| MkKeyValue string expression :: :: mk_key_value
{{ com Args: key expr }}

argument :: argument_ ::= {{ com ??? }}
| Expression expression :: :: expression
{{ com What is the naming convention to use for this production name? }}
{{ com Args: value }}
| KeyValue string expression :: :: key_value
{{ com Args: key value }}
{{ com What is the relation to keyvalue production??? }}
| Missing :: :: missing

expression :: expression_ ::= {{ com ??? }}
| BoolExpression bool :: :: bool_expression
{{ com Args: value }}
{{ com TODO: Argument not related to type_bool? }}
| IntExpression int :: :: int_expression
{{ com Args: value }}
| StringExpression string :: :: string_expression
{{ com Args: value }}
| NameExpression name :: :: name_expression
{{ com Args: value }}
| ArrayAccess expression expression' :: :: array_access
{{ com Args: array, index }}
| BitStringAccess expression expression' expression'' :: :: bit_string_access
{{ com Args: array, hi, lo }}
| List (list expression) :: :: list
{{ com Args: values }}
| Record (list keyvalue) :: :: record
{{ com Args: entries }}
| UnaryOp unaryoperator expression :: :: unary_op
{{ com Args: op arg }}
| BinaryOp binaryoperator expression :: :: record
{{ com Args: op arg }}
| Cast type expression :: :: cast
{{ com Args: type expr}}
| TypeMember name string :: :: type_member
{{ com Args: type name }}
| ErrorMember string :: :: error_member
{{ com Args: error }}
| ExpressionMember expression string :: :: expression_member
{{ com Args: expr name }}
| Ternary expression expression' expression'' :: :: ternary
{{ com Args: cond true false }}
| FunctionCall expression (list type) (list argument) :: :: ternary
{{ com Args: function type_args args }}
| NamelessInstantiation type (list argument) :: :: nameless_instantiation
{{ com Args: type args }}
| Mask expression expression' :: :: mask
{{ com Args: expr mask }}
| Range expression expression' :: :: range
{{ com Args: lo hi }}


declaration :: declaration_ ::= {{ com ??? }}
| DeclarationConstant type string expression :: :: declaration_constant
{{ com Args: type name value }}
| DeclarationVariable type string (option expression) :: :: declaration_variable
{{ com Args: type name init }}
| Instantiation type (list expression) string :: :: instantiation
{{ com Args: type args name }}

statement :: statement_ ::= {{ com ??? }}
| MethodCall expression (list type) (list (option expression)):: :: method_call
{{ com Args: func type_args args }}
| Assignment expression expression' :: :: assignment
{{ com Args: lhs rhs }}
| BlockStatement block :: :: block_statement
{{ com Args: blk }}
| StatementConstant type string expression :: :: statement_constant
{{ com Args: type name value }}
| StatementVariable type string (option expression) :: :: statement_variable
{{ com Args: type name init }}


%TODO How to translate the following:
%  with block :=
%    | BlockEmpty : block
%    | BlockCons : statement -> block -> block
%????
block :: block_ ::= {{ com ??? }}
| BlockEmpty :: :: block_empty
| BlockCons statement block :: :: block_cons


match_expression :: match_expression_ ::= {{ com ??? }}
| DontCare :: :: dont_care
| MatchExpression expression :: :: match_expression
{{ com Args: expr }}

%%%%%%%%%%%%%%%
%%  Records  %%
%%%%%%%%%%%%%%%

%TODO How to write this? Currently using mk_ syntax
case :: case_ ::= {{ com ??? }}
| MkCase (list match_expression) string :: :: mk_case
{{ com Args: matches next }}

transition :: transition_ ::= {{ com ??? }}
| MkTransition (list expression) (list case) :: :: mk_transition
{{ com Args: exprs cases }}

state :: state_ ::= {{ com ??? }}
| MkState string (list statement) transition:: :: mk_state
{{ com Args: name statements transition }}

parser :: parser_ ::= {{ com ??? }}
| MkParser string (list param) (list param) (list declaration) (list state) :: :: mk_parser
%{ parser_name = string; params = list param; constructor_params = list param; locals = list declaration;  states = list states}   :: d :: parser_rec
{{ com Args: parser_name params constructor_params locals states }}

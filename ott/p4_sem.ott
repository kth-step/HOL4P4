defns
e_sem :: '' ::=
defn
ctx g_scope_list scopes_stack ( e ) ~> ( e' , frame_list ) :: :: e_red :: e_
{{ com expression semantics }}
{{ tex [[ctx]] \, [[g_scope_list]] \, [[scopes_stack]] \vdash ( [[e]] ) \rightsquigarrow  ( [[e']] , [[frame_list]] ) }}
by

%%%%%%%%%%%%%%%%%
%Variable look-up

v = lookup_vexp2 ( scopes_stack , g_scope_list , varn )
----------------------------------- :: lookup
ctx g_scope_list scopes_stack ( var varn ) ~> ( v ,  empty )

%%%%%%%%%%%%%%
%Function/method call

%Function call construction of new frame
( stmt , [ ( x1 , d1 ) , .. , ( xn , dn ) ] ) = lookup_funn_sig_body ( funn , func_map , b_func_map , ext_map )
check_args_red [ d1 , .. , dn ] [ e1 , .. , en ]
scope' = copyin ( ( x1 , .. , xn ) , [ d1 , .. , dn ] , [ e1 , .. , en ] , g_scope_list , scopes_stack )
----------------------------------- :: call_newframe
( ext_map , func_map , b_func_map , pars_map , tbl_map ) g_scope_list scopes_stack ( call funn ( e1 , .. , en ) ) ~> ( var ( star , funn ) , [ ( funn , [ stmt ] , [ scope' ] ) ] )

%Function call reduction of arguments
[ ( x1 , d1 ) , .. , ( xn , dn ) ] = lookup_funn_sig ( funn , func_map , b_func_map , ext_map )
unred_arg_index [ d1 , .. , dn ] [ e1 , .. , en ] = i
e = [ e1 , .. , en ] [ i ]
( ext_map , func_map , b_func_map , pars_map , tbl_map ) g_scope_list scopes_stack ( e ) ~> ( e' , frame_list )
[ e'1 , .. , e'n ] =' update ( e' , i , [ e1 , .. , en ] )
----------------------------------- :: call_args
( ext_map , func_map , b_func_map , pars_map , tbl_map ) g_scope_list scopes_stack ( call funn ( e1 , .. , en ) ) ~> ( call funn ( e'1 , .. , e'n ) , frame_list )


%%%%%% structs operations

%eStruct as expression reduction: reduce one step per expression in the list 
unred_mem_index [ e1 , ... , en ] = i
e = [ e1 , ... , en ] [ i ]
ctx g_scope_list scopes_stack ( e ) ~> ( e' , frame_list )
[ e'1 , ... , e'n ] =' update ( e' , i , [ e1 , ... , en ] )
----------------------------------- :: eStruct
ctx g_scope_list scopes_stack ( eStruct { f1 = e1 ; ... ; fn = en } ) ~> ( eStruct { f1 = e'1 ; ... ; fn = e'n } , frame_list )

%eStruct coversion to value struct
is_consts ( e1 , ... , en )
( v1 , ... , vn ) = vl_of_el ( e1 , ... , en )
----------------------------------- :: eStruct_to_v
ctx g_scope_list scopes_stack ( eStruct { f1 = e1 ; ... ; fn = en } ) ~> ( struct { f1 = v1 ; ... ; fn = vn } , empty )

%access a value struct field 
v = struct { f1 = v1 ; ... ; fn = vn } ( f )
----------------------------------- :: s_acc
ctx g_scope_list scopes_stack ( struct { f1 = v1 ; ... ; fn = vn } . f ) ~> ( v , empty )


%expression reduction for access fields
ctx g_scope_list scopes_stack ( e ) ~> ( e' , frame_list )
----------------------------------- :: acc_arg1
ctx g_scope_list scopes_stack ( e . f ) ~> ( e' . f , frame_list )

%%%%%% headers operations
%eHeader as expression reduction: reduce one step per expression in the list 
unred_mem_index [ e1 , ... , en ] = i
e = [ e1 , ... , en ] [ i ]
ctx g_scope_list scopes_stack ( e ) ~> ( e' , frame_list )
[ e'1 , ... , e'n ] =' update ( e' , i , [ e1 , ... , en ] )
----------------------------------- :: eHeader
ctx g_scope_list scopes_stack ( eHeader boolv { f1 = e1 ; ... ; fn = en } ) ~> ( eHeader boolv { f1 = e'1 ; ... ; fn = e'n } ,  frame_list )

%eHeader coversion to value struct
is_consts ( e1 , ... , en )
( v1 , ... , vn ) = vl_of_el ( e1 , ... , en )
----------------------------------- :: eHeader_to_v
ctx g_scope_list scopes_stack ( eHeader boolv { f1 = e1 ; ... ; fn = en } ) ~> ( header boolv { f1 = v1 ; ... ; fn = vn }  ,  empty )


%Header field access
v = header boolv { f1 = v1 ; ... ; fn = vn } ( f )
----------------------------------- :: h_acc
ctx g_scope_list scopes_stack ( header boolv { f1 = v1 ; ... ; fn = vn } . f ) ~> ( v ,  empty )

%Case select lookup
x' = { v1 : x1 ; ... ; vn : xn } x ( v )
----------------------------------- :: sel_acc
ctx g_scope_list scopes_stack ( select v { v1 : x1 ; ... ; vn : xn } x ) ~> ( x' ,  empty )

%concatenation of two bitstrings 

ctx g_scope_list scopes_stack ( e ) ~> ( e'' , frame_list )
----------------------------------- :: concat_arg1
ctx g_scope_list scopes_stack ( concat e e' ) ~> ( concat e'' e' , frame_list )


ctx g_scope_list scopes_stack ( e ) ~> ( e' , frame_list )
----------------------------------- :: concat_arg2
ctx g_scope_list scopes_stack ( concat bitv e ) ~> ( concat bitv e' , frame_list )


bitv'' = concat bitv bitv'
----------------------------------- :: concat_v
ctx g_scope_list scopes_stack ( concat bitv bitv' ) ~> ( bitv'' , empty )


%bit slicing operation

ctx g_scope_list scopes_stack ( e ) ~> ( e' , frame_list )
----------------------------------- :: slice_arg1
ctx g_scope_list scopes_stack ( e [ bitv : bitv' ] ) ~> ( e' [ bitv : bitv' ] , frame_list )

%compile time known values from p4 spec. 
bitv''' = bitv [ bitv' : bitv'' ]
----------------------------------- :: slice_v
ctx g_scope_list scopes_stack ( bitv [ bitv' : bitv'' ] ) ~> ( bitv''' , empty )


%Select

ctx g_scope_list scopes_stack ( e ) ~> ( e' , frame_list )
----------------------------------- :: sel_arg
ctx g_scope_list scopes_stack ( select e { v1 : x1 ; ... ; vn : xn } x ) ~> ( select e' { v1 : x1 ; ... ; vn : xn } x , frame_list )


%Unary operations

ctx g_scope_list scopes_stack ( e ) ~> ( e' , frame_list )
----------------------------------- :: unop_arg
ctx g_scope_list scopes_stack ( unop e ) ~> ( unop e' , frame_list )

%Binary operations

ctx g_scope_list scopes_stack ( e ) ~> ( e'' , frame_list )
----------------------------------- :: binop_arg1
ctx g_scope_list scopes_stack ( e binop e' ) ~> ( e'' binop e' , frame_list )

%TODO: Enforce short-circuit evaluation for AND, OR on Booleans?
~is_short_circuit ( binop )
ctx g_scope_list scopes_stack ( e ) ~> ( e' , frame_list )
----------------------------------- :: binop_arg2
ctx g_scope_list scopes_stack ( v binop e ) ~> ( v binop e' , frame_list )


%%%%%%%%%%%%%%%%%%%
%Unary expressions%
%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%
%Boolean negation

! b = b'
----------------------------------- :: neg_bool
ctx g_scope_list scopes_stack ( ! b ) ~> ( b' , empty )

%%%%%%%%%%%%%%%%%%%
%Bitwise complement

~ bitv = bitv'
----------------------------------- :: compl
ctx g_scope_list scopes_stack ( ~ bitv ) ~> ( bitv' , empty )

%%%%%%%%%%%%%%%%
%Signed negation

- bitv = bitv'
----------------------------------- :: neg_signed
ctx g_scope_list scopes_stack ( - bitv ) ~> ( bitv' , empty )


%%%%%%%%%%%
%Unary plus

+ bitv = bitv'
----------------------------------- :: un_plus
ctx g_scope_list scopes_stack ( + bitv ) ~> ( bitv' , empty )


%%%%%%%%%%%%%%%%%%%%
%Binary expressions%
%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%
%Multiplication

bitv * bitv' = bitv''
----------------------------------- :: mul
ctx g_scope_list scopes_stack ( bitv * bitv' ) ~> ( bitv'' , empty )


%%%%%%%%%%%%%%%
%Division

bitv / bitv' = bitv''
----------------------------------- :: div
ctx g_scope_list scopes_stack ( bitv / bitv' ) ~> ( bitv'' , empty )
%%%%%%%%%%%%%%%
%Modulo

bitv mod bitv' = bitv''
----------------------------------- :: mod
ctx g_scope_list scopes_stack ( bitv mod bitv' ) ~> ( bitv'' , empty )

%%%%%%%%%%%%
%Addition

bitv + bitv' = bitv''
----------------------------------- :: add
ctx g_scope_list scopes_stack ( bitv + bitv' ) ~> ( bitv'' , empty )

%%%%%%%%%%%%
%Subtraction

bitv - bitv' = bitv''
----------------------------------- :: sub
ctx g_scope_list scopes_stack ( bitv - bitv' ) ~> ( bitv'' , empty )


%%%%%%%%%%%%
%Left shift

bitv SHL bitv' = bitv''
----------------------------------- :: shl
ctx g_scope_list scopes_stack ( bitv SHL bitv' ) ~> ( bitv'' , empty )

%%%%%%%%%%%%
%Right shift

bitv SHR bitv' = bitv''
----------------------------------- :: shr
ctx g_scope_list scopes_stack ( bitv SHR bitv' ) ~> ( bitv'' , empty )

%%%%%%%%%%%%%%%%%%%
%Less than or equal

bitv LE bitv' = b
----------------------------------- :: le
ctx g_scope_list scopes_stack ( bitv LE bitv' ) ~> ( b , empty )

%%%%%%%%%%%%%%%%%%%%%%
%Greater than or equal

bitv GE bitv' = b
----------------------------------- :: ge
ctx g_scope_list scopes_stack ( bitv GE bitv' ) ~> ( b , empty )

%%%%%%%%%%
%Less than

bitv < bitv' = b
----------------------------------- :: lt
ctx g_scope_list scopes_stack ( bitv < bitv' ) ~> ( b , empty )
%%%%%%%%%%%%%
%Greater than

bitv > bitv' = b
----------------------------------- :: gt
ctx g_scope_list scopes_stack ( bitv > bitv' ) ~> ( b , empty )

%%%%%%%%%%%%%
%Not equal

bitv NE bitv' = b
----------------------------------- :: neq
ctx g_scope_list scopes_stack ( bitv NE bitv' ) ~> ( b , empty )

(x <> x') = b
----------------------------------- :: neq_error
ctx g_scope_list scopes_stack ( (errmsg x) NE (errmsg x') ) ~> ( b , empty )

b NE b' = b''
----------------------------------- :: neq_bool
ctx g_scope_list scopes_stack ( b NE b' ) ~> ( b'' , empty )

%%%%%%%%%%%%%
%Equal

bitv EQ bitv' = b
----------------------------------- :: eq
ctx g_scope_list scopes_stack ( bitv EQ bitv' ) ~> ( b , empty )


(x EQ x') = b
----------------------------------- :: eq_error
ctx g_scope_list scopes_stack ( (errmsg x) EQ (errmsg x') ) ~> ( b , empty )



b EQ b' = b''
----------------------------------- :: eq_bool
ctx g_scope_list scopes_stack ( b EQ b' ) ~> ( b'' , empty )


%%%%%%%%%%%%%
%Bitwise and

bitv & bitv' = bitv''
----------------------------------- :: and
ctx g_scope_list scopes_stack ( bitv & bitv' ) ~> ( bitv'' , empty )


%%%%%%%%%%%%%
%Bitwise xor

bitv ^ bitv' = bitv''
----------------------------------- :: xor
ctx g_scope_list scopes_stack ( bitv ^ bitv' ) ~> ( bitv'' , empty )



%%%%%%%%%%%%%
%Bitwise or

bitv | bitv' = bitv''
----------------------------------- :: or
ctx g_scope_list scopes_stack ( bitv | bitv' ) ~> ( bitv'' , empty )


%%%%%%%%%%%%%
%Binary and
%Note: This uses short-circuit evaluation

----------------------------------- :: bin_and1
ctx g_scope_list scopes_stack ( false AND e ) ~> ( false , empty )

----------------------------------- :: bin_and2
ctx g_scope_list scopes_stack ( true AND e ) ~> ( e , empty )

%%%%%%%%%%%%%
%Binary or
%Note: This uses short-circuit evaluation

----------------------------------- :: bin_or1
ctx g_scope_list scopes_stack ( true OR e ) ~> ( true , empty )

----------------------------------- :: bin_or2
ctx g_scope_list scopes_stack ( false OR e ) ~> ( e , empty )

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Statement semantics ( single frame )%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%TODO: Should this now be called statement stack semantics and use the prefix "stmt_stack"?

%TODO: Exit
%TODO: Switch

defns
  stmt_sem :: '' ::=
defn
  ctx state -> state' :: :: stmt_red :: stmt_
  {{ com stmt semantics }}
  {{ tex [[ctx]] \vdash  [[state]] \rightarrow  [[state']] }}
by

  scopes_stack' = assign ( ( scopes_stack ++ g_scope_list ) , v , lval )
  ( g_scope_list' , scopes_stack'' ) = separate scopes_stack'
  ----------------------------------- :: ass_v
  ctx ( g_scope_list , [ ( funn , [ assign lval v ]  , scopes_stack ) ] , ctrl , Running ) -> ( g_scope_list' , [ ( funn , [ empty_stmt ] , scopes_stack'' ) ]  , ctrl , Running )


%%%%%%%%%%%%%%
%Sequence

  ctx ( g_scope_list , [ ( funn , [ stmt1 ] , scopes_stack ) ] , ctrl , Running ) -> ( g_scope_list' , frame_list ++ [ ( funn , stmt_stack' ++ [ stmt1' ] , scopes_stack' ) ] , ctrl' , Running )
  ----------------------------------- :: seq1
  ctx ( g_scope_list , [ ( funn , [ stmt1 ; stmt2 ] , scopes_stack ) ] , ctrl , Running ) -> ( g_scope_list' , frame_list ++ [ ( funn , stmt_stack' ++ [ stmt1' ; stmt2 ] , scopes_stack' ) ] , ctrl' , Running )


  ----------------------------------- :: seq2
  ctx ( g_scope_list , [ ( funn , [ empty_stmt ; stmt ] , scopes_stack ) ] , ctrl , Running ) -> ( g_scope_list , [ ( funn , [ stmt ] , scopes_stack ) ] , ctrl , Running )


%Note that this does not have to take into account new items in the stmt_stack, since no statement can both create new items in the statement stack and change status
%TODO: Is this really needed as a separate rule? Arch sem will act immediately upon seeing changes status anyhow... 
  ctx ( g_scope_list , [ ( funn , [ stmt1 ] , scopes_stack ) ] , ctrl , Running ) -> ( g_scope_list' , [ ( funn , [ stmt1' ] , scopes_stack' ) ] , ctrl' , status )
  notrun( status )
  ----------------------------------- :: seq3
  ctx ( g_scope_list , [ ( funn , [ stmt1 ; stmt2 ] , scopes_stack ) ] , ctrl , Running ) -> ( g_scope_list' , [ ( funn , [ stmt1' ] , scopes_stack' ) ] , ctrl' , status )

%%%%%%%%%%%%%%
%Conditional

  ----------------------------------- :: cond2
  ctx ( g_scope_list , [ ( funn , [ if true then stmt1 else stmt2 ] , scopes_stack ) ] , ctrl , Running ) -> ( g_scope_list , [ ( funn , [ stmt1 ] , scopes_stack ) ] , ctrl , Running )
 
  ----------------------------------- :: cond3
  ctx ( g_scope_list , [ ( funn , [ if false then stmt1 else stmt2 ] , scopes_stack ) ] , ctrl , Running ) -> ( g_scope_list , [ ( funn , [ stmt2 ] , scopes_stack ) ] , ctrl , Running )

%%%%%%%%%%%%%%
%Block


  ( scope ) = declare_list_in_fresh_scope ( decl_list )
  scopes_stack' =  [ scope ] ++ scopes_stack
  ----------------------------------- :: block_enter
  ctx ( g_scope_list , [ ( funn , [ begin decl_list stmt end ] , scopes_stack ) ] , ctrl , Running ) -> ( g_scope_list , [ ( funn , stmt :: [ empty_stmt ] , scopes_stack' ) ] , ctrl , Running )

  not_empty stmt
  not_empty stmt_stack
  ( ext_map , func_map , b_func_map , pars_map , tbl_map ) ( g_scope_list , [ ( funn , [ stmt ] , scopes_stack ) ] , ctrl , status ) -> ( g_scope_list' , frame_list' ++ [ ( funn , stmt_stack' , scopes_stack' ) ] , ctrl' , status' )
  ----------------------------------- :: block_exec
  ( ext_map , func_map , b_func_map , pars_map , tbl_map ) ( g_scope_list , [ ( funn , stmt :: stmt_stack , scopes_stack ) ] , ctrl , status ) -> ( g_scope_list' , frame_list' ++ [ ( funn , stmt_stack' ++ stmt_stack , scopes_stack' ) ] , ctrl' , status' )

  not_empty stmt_stack
  scopes_stack' = tl scopes_stack
  ----------------------------------- :: block_exit
  ctx ( g_scope_list , [ ( funn , empty_stmt :: stmt_stack , scopes_stack ) ] , ctrl , status ) -> ( g_scope_list , [ ( funn , stmt_stack , scopes_stack' ) ] , ctrl , status )


%%%%%%%%%%%%%%
%Verify

%Case predicate holds
  ------------------------------------------------- :: verify_3
  ctx ( g_scope_list , [ ( funn , [ verify true ( errmsg x ) ] , scopes_stack ) ] , ctrl , Running ) -> ( g_scope_list , [ ( funn , [ empty_stmt ] , scopes_stack ) ] , ctrl , Running )


%Case predicate does not hold
  x' = parseError
  x'' = "reject"
  ------------------------------------------------- :: verify_4
  ctx ( g_scope_list , [ ( funn , [ verify false ( errmsg x ) ] , scopes_stack ) ] , ctrl , Running ) -> ( g_scope_list , [ ( funn , [ assign x' ( errmsg x ) ; transition x'' ] , scopes_stack ) ] , ctrl , Running )


%%%%%%%%%%%%%%
%Transition

  ------------------------------------------------- :: trans
  ctx ( g_scope_list , [ ( funn , [ transition x ] , scopes_stack ) ] , ctrl , Running ) -> ( g_scope_list , [ ( funn , [ empty_stmt ] , scopes_stack ) ] , ctrl , Trans x )


%%%%%%%%%%%%%%
%The action is treated as a function call
  is_consts ( e1 , .. , en )
  tbl_map ( tbl ) = ( [ mk1 , .. , mkn ] )
  ctrl ( tbl , ( e1 , .. , en ) , ( [ mk1 , .. , mkn ] ) ) = ( f , ( v1 , .. , vm ) )
  ----------------------------------- :: apply_table_v
  ( ext_map , func_map , b_func_map , pars_map , tbl_map ) ( g_scope_list , [ ( funn , [ apply tbl ( e1 , .. , en ) ] , scopes_stack ) ] , ctrl , Running ) -> ( g_scope_list , [ ( funn , [ assign null ( call f ( v1 , .. , vm ) ) ] , scopes_stack ) ] , ctrl , Running )


%%%%%%%%%%%%%%
%Return

  ----------------------------------- :: ret_v
  ctx ( g_scope_list , [ ( funn , [ return v ] , scopes_stack ) ] , ctrl , Running ) -> ( g_scope_list , [ ( funn , [ empty_stmt ] , scopes_stack ) ] , ctrl , Ret v )

%%%%%%%%%%%%%%
%Extern
  ext_fun = lookup_ext_fun ( funn , ext_map )
  ( g_scope_list' , scopes_stack' , ctrl' ) = ext_fun ( g_scope_list , scopes_stack , ctrl )
  ----------------------------------- :: ext
  ( ext_map , func_map , b_func_map , pars_map , tbl_map ) ( g_scope_list , [ ( funn , [ ext ] , scopes_stack ) ] , ctrl , Running ) -> ( g_scope_list' , [ ( funn , [ empty_stmt ] , scopes_stack' ) ] , ctrl' , Running )
 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Reduction of expression rules %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%Reduction step of return expression

  ctx g_scope_list scopes_stack ( e ) ~> ( e' , frame_list )
  ----------------------------------- :: ret_e
  ctx ( g_scope_list , [ ( funn , [ return e ] , scopes_stack ) ] , ctrl , Running ) -> ( g_scope_list , frame_list ++ [ ( funn , [ return e' ] , scopes_stack ) ] , ctrl , Running )


%Reduction step of assign expression
  ctx g_scope_list scopes_stack ( e ) ~> ( e' , frame_list )
  ----------------------------------- :: ass_e
  ctx ( g_scope_list , [ ( funn , [ assign lval e ] , scopes_stack ) ] , ctrl , Running ) -> ( g_scope_list , frame_list ++ [ ( funn , [ assign lval e' ] , scopes_stack ) ] , ctrl , Running )


%Reduction step of condition
  ctx g_scope_list scopes_stack ( e ) ~> ( e' , frame_list )
  ----------------------------------- :: cond_e
  ctx ( g_scope_list , [ ( funn , [ if e then stmt1 else stmt2 ] , scopes_stack ) ] , ctrl , Running ) -> ( g_scope_list , frame_list ++ [ ( funn , [ if e' then stmt1 else stmt2 ] , scopes_stack ) ] , ctrl , Running )


%Reduction step of verify predicate
  ctx g_scope_list scopes_stack ( e ) ~> ( e'' , frame_list )
  ------------------------------------------------- :: verify_e1
  ctx ( g_scope_list , [ ( funn , [ verify e e' ] , scopes_stack ) ] , ctrl , Running ) -> ( g_scope_list , frame_list ++ [ ( funn , [ verify e'' e' ] , scopes_stack ) ] , ctrl , Running )
  

%Reduction step of error message
  ctx g_scope_list scopes_stack ( e ) ~> ( e' , frame_list )
  ------------------------------------------------- :: verify_e2
  ctx ( g_scope_list , [ ( funn , [ verify b e ] , scopes_stack ) ] , ctrl , Running ) -> ( g_scope_list , frame_list ++ [ ( funn , [ verify b e' ] , scopes_stack ) ] , ctrl , Running )


%Reduction step of transition
  ctx g_scope_list scopes_stack ( e ) ~> ( e' , frame_list )
  ------------------------------------------------- :: trans_e
  ctx ( g_scope_list , [ ( funn , [ transition e ] , scopes_stack ) ] , ctrl , Running ) -> ( g_scope_list , frame_list ++ [ ( funn , [ transition e' ] , scopes_stack ) ] , ctrl , Running )


%Reduction step of match-action expression
  index_not_const [ e1 , .. , en ] = i
  e = [ e1 , .. , en ] [ i ]
  ctx g_scope_list scopes_stack ( e ) ~> ( e' , frame_list )
  [ e'1 , .. , e'n ] =' update ( e' , i , [ e1 , .. , en ] )
  ----------------------------------- :: apply_table_e
  ctx ( g_scope_list , [ ( funn , [ apply tbl ( e1 , .. , en ) ] , scopes_stack ) ] , ctrl , Running ) -> ( g_scope_list , frame_list ++ [ ( funn , [ apply tbl ( e'1 , .. , e'n ) ] , scopes_stack ) ] , ctrl , Running )


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Statement semantics (list of frames) %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%TODO: Should this be called "frames" or "frame list"? Use consistently through all code

defns
  frames_sem :: '' ::=
defn
  ctx state -f-> state' :: :: frames_red :: frames_
  {{ com list of frames semantics }}
  {{ tex [[ctx]] \vdash  [[state]] {\longrightarrow}_{\Phi}  [[state']] }}
by

  g_scope_list' = scopes_to_pass ( funn , func_map , b_func_map , g_scope_list )
  %frame_list'' neq empty
  notret( status' , frame_list'' )
  ( ext_map , func_map , b_func_map , pars_map , tbl_map ) ( g_scope_list' , [ ( funn , stmt_stack , scopes_stack ) ] , ctrl , status ) -> ( g_scope_list'' , frame_list' , ctrl' , status' )
  g_scope_list''' = scopes_to_retrieve ( funn , func_map , b_func_map , g_scope_list , g_scope_list'' )
  ----------------------------------- :: comp1
  ( ext_map , func_map , b_func_map , pars_map , tbl_map ) ( g_scope_list , [ ( funn , stmt_stack , scopes_stack ) ] ++ frame_list'' , ctrl , status ) -f-> ( g_scope_list''' , frame_list' ++ frame_list'' , ctrl' , status' )

%Note that stmt must be return v, so ctrl cannot be modified by this reduction
%Note that global scope does not matter for the below statement reduction step (write global scope empty?), so no "scopes_to_pass" needed
  ( ext_map , func_map , b_func_map , pars_map , tbl_map ) ( g_scope_list , [ ( funn , stmt_stack , scopes_stack ) ] , ctrl , Running ) -> ( g_scope_list , [ ( funn , stmt_stack'' , scopes_stack ) ] , ctrl , Ret v )
  g_scope_list' = assign ( ( g_scope_list ) , v , ( star , funn ) )
  ( stmt''' , [ ( x1 , d1 ) , .. , ( xn , dn ) ] ) = lookup_funn_sig_body ( funn , func_map , b_func_map , ext_map )
   g_scope_list'' = scopes_to_retrieve ( funn , func_map , b_func_map , g_scope_list , g_scope_list' )
  ( g_scope_list''' , scopes_stack'''' ) = copyout ( ( x1 , .. , xn ) , [ d1 , .. , dn ] , g_scope_list'' , scopes_stack' , scopes_stack )
  ----------------------------------- :: comp2
  ( ext_map , func_map , b_func_map , pars_map , tbl_map ) ( g_scope_list , [ ( funn , stmt_stack , scopes_stack ) ] ++ ( [ ( funn' , stmt_stack' , scopes_stack' ) ] ++ frame_list ) , ctrl , Running ) -f-> ( g_scope_list''' , [ ( funn' , stmt_stack' , scopes_stack'''' ) ] ++ frame_list , ctrl , Running )


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Architectural-level semantics %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%TODO: Use varn, copyin, copyout in these rules also wherever applicable

defns
  arch_sem :: '' ::=
defn
  actx astate -'> astate' :: :: arch_red :: arch_
  {{ com architecture-level semantics }}
  {{ tex [[actx]] \vdash [[astate]] {\longrightarrow}_{A} [[astate']] }}
by

%Four different phases: Input, programmable block, fixed-function block and output.

  inp = ab_list [ i ]
  ( in_out_list'' , ascope' ) = input_f ( in_out_list , ascope )
  ----------------------------------- :: in
  ( ab_list , pblock_map , ffblock_map , input_f , output_f , copyin_pbl , copyout_pbl , ext_map , func_map ) ( ( i , in_out_list , in_out_list' , ascope ) , g_scope_list , arch_frame_list_empty , ctrl , Running ) -'> ( ( i + 1 , in_out_list'' , in_out_list' , ascope' ) , g_scope_list , arch_frame_list_empty , ctrl , Running )

  pbl f ( e1 , .. , en ) = ab_list [ i ]
  pbl_type ( ( x1 , d1 ) , .. , ( xn , dn ) ) b_func_map decl_list stmt pars_map tbl_map = pblock_map ( f )
  scope' = copyin_pbl ( ( x1 , .. , xn ) , [ d1 , .. , dn ] , [ e1 , .. , en ] , ascope , pbl_type )
  scope'' = declare_list_in_scope ( decl_list , scope' )
  g_scope'' = g_scope_list [0]
  g_scope_list' = [g_scope'']' ++ [ scope'' ]
  ----------------------------------- :: pbl_init
  ( ab_list , pblock_map , ffblock_map , input_f , output_f , copyin_pbl , copyout_pbl , ext_map , func_map ) ( ( i , in_out_list , in_out_list' , ascope ) , g_scope_list , arch_frame_list_empty , ctrl , Running ) -'> ( ( i , in_out_list , in_out_list' , ascope ) , g_scope_list' , [ ( f , [ stmt ] , [ emptyscope ] ) ] , ctrl , Running )

  ffbl x = ab_list [ i ]
  ff = ffblock_map ( x )
  ascope' = ff ( ascope )
  ----------------------------------- :: ffbl
  ( ab_list , pblock_map , ffblock_map , input_f , output_f , copyin_pbl , copyout_pbl , ext_map , func_map ) ( ( i , in_out_list , in_out_list' , ascope ) , g_scope_list , arch_frame_list_empty , ctrl , Running ) -'> ( ( i + 1 , in_out_list , in_out_list' , ascope' ) , g_scope_list , arch_frame_list_empty , ctrl , Running )

%Note that this always sets index to 0. This could be done conditionally, if it would not be ideal
%to have the final state have index 0.
  out = ab_list [ i ]
  ( in_out_list'' , ascope' ) = output_f ( in_out_list' , ascope )
  ----------------------------------- :: out
  ( ab_list , pblock_map , ffblock_map , input_f , output_f , copyin_pbl , copyout_pbl , ext_map , func_map ) ( ( i , in_out_list , in_out_list' , ascope ) , g_scope_list , arch_frame_list_empty , ctrl , Running ) -'> ( ( 0 , in_out_list , in_out_list'' , ascope' ) , g_scope_list , arch_frame_list_empty , ctrl , Running )


%TODO: This could be solved directly at statement level... This is essentially the old pars_state rule
  pbl x ( e1 , .. , en ) = ab_list [ i ]
  parser ( ( x1 , d1 ) , .. , ( xn , dn ) ) b_func_map decl_list stmt pars_map tbl_map = pblock_map ( x )
  not_final_state ( x' )
  stmt' = pars_map ( x' )
  ----------------------------------- :: parser_trans
  ( ab_list , pblock_map , ffblock_map , input_f , output_f , copyin_pbl , copyout_pbl , ext_map , func_map ) ( ( i , in_out_list , in_out_list' , ascope ) , g_scope_list , frame_list , ctrl , Trans x' ) -'> ( ( i , in_out_list , in_out_list' , ascope ) , g_scope_list' , [ ( x' , [ stmt' ] , [ emptyscope ] ) ] , ctrl' , Running )

  pbl x ( e1 , .. , en ) = ab_list [ i ]
  pbl_type ( ( x1 , d1 ) , .. , ( xn , dn ) ) b_func_map decl_list stmt pars_map tbl_map = pblock_map ( x )
  ( ext_map , func_map , b_func_map , pars_map , tbl_map ) ( g_scope_list , frame_list , ctrl , Running ) -f-> ( g_scope_list' , frame_list' , ctrl' , status' )
  ----------------------------------- :: pbl_exec
  ( ab_list , pblock_map , ffblock_map , input_f , output_f , copyin_pbl , copyout_pbl , ext_map , func_map ) ( ( i , in_out_list , in_out_list' , ascope ) , g_scope_list , frame_list , ctrl , Running ) -'> ( ( i , in_out_list , in_out_list' , ascope ) , g_scope_list' , frame_list' , ctrl' , status' )

%... until execution using the regular statement semantics has finished

%TODO: 13.3 of spec says: "An architecture must specify the behavior when the accept and reject states are reached. [...]", so copyout function must take status also

%Note that exiting a parser block also sets the value of parseError
  pbl f ( e1 , .. , en ) = ab_list [ i ]
  pbl_type ( ( x1 , d1 ) , .. , ( xn , dn ) ) b_func_map decl_list stmt pars_map tbl_map = pblock_map ( f )
  state_fin ( status , frame_list )
  status' = set_fin_status ( pbl_type , status )
  %Q: Why no scopes from frame_list after global scopes?
  %A: All copy-out variables exist in block-global scope... TODO: Test this...
  ascope' = copyout_pbl ( g_scope_list , ascope , [ d1 , .. , dn ] , ( x1 , .. , xn ) , pbl_type , status' )
  %TODO: Relax requirement that statement be empty in initial state?
  ----------------------------------- :: pbl_ret
  ( ab_list , pblock_map , ffblock_map , input_f , output_f , copyin_pbl , copyout_pbl , ext_map , func_map ) ( ( i , in_out_list , in_out_list' , ascope ) , g_scope_list , frame_list , ctrl , status ) -'> ( ( i + 1 , in_out_list , in_out_list' , ascope' ) , take 1 g_scope_list , arch_frame_list_empty , ctrl , Running )

%TODO: What should happen when all input has been processed?
%      	    Separate judgment form?
%      	    Set status to Ended? Then all rules would need to exclude having the Ended status
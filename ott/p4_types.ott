embed
{{ hol
open bitstringTheory;
open wordsTheory;
}}

grammar

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Typing scope lists
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



t_scope_list_g {{ tex \overrightarrow{\psi_G} }} :: t_scope_list_g_ ::=
{{ hol (t_scope list) }}
{{ com globals typing scope }}
| [ t_scope ; t_scope' ] :: M :: two
  {{ com global scope and block-global scope }}
  {{ hol ([ [[t_scope]] ; [[t_scope']] ]) }}
  {{ tex [ [[t_scope]], [[t_scope']] ] }}

t_scope_list {{ tex \overrightarrow{\psi} }} :: t_scope_list_ ::=
{{ hol (t_scope list) }}
{{ com ddd}}
| emptytss :: M :: empty
  {{ hol ([]:t_scope list) }}
  {{ tex [\;] }}
| [ t_scope1 , .. , t_scopen ] :: M :: list
  {{ hol ([[t_scope1 .. t_scopen]]) }}
| [ t_scope ] ++ t_scope_list :: M :: scope_concat  
  {{ hol ( [ [[t_scope]] ] ++ [[t_scope_list]]) }}

embed
{{ hol
}}
grammar

t_scopes_tup {{ tex \psi_t }} :: t_scopes_tup_ ::=
{{ hol (t_scope_list_g # t_scope_list) }}
| ( t_scope_list_g , t_scope_list ) :: M :: tup
 {{ hol ([[t_scope_list_g]] , [[t_scope_list]]) }}
 {{ tex ([[t_scope_list_g]] , [[t_scope_list]]) }}



embed
{{ hol
}}
grammar


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Global, local functions names types
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
delta_g {{ tex \Delta_{glb} }} :: delta_g_ ::=
{{ com types of functions defined globally}}
{{ hol (string, Ftau) alist }}
| ( empty ) :: M :: empty
  {{ com empty function map }}
  {{ hol [] }}

delta_b {{ tex \Delta_{blk} }} :: delta_b_ ::=
{{ com types of functions defined locally}}
{{ hol (string, Ftau) alist }}
| ( empty ) :: M :: empty
  {{ com empty function map }}
  {{ hol [] }}

% map between the name of the extern object name to the type it has (which we call instan).
%The option string represent the methods calls of the original extern object.
delta_x {{ tex \Delta_{ext} }} :: delta_x_ ::=
{{ com types of extern instan and methods}}
{{ hol (string, ( Ftau # (string option # Ftau option))) alist }}
| ( empty ) :: M :: empty
  {{ com empty function map }}
  {{ hol [] }}





delta_t {{ tex \Delta_{tbl} }} :: delta_t_ ::=
{{ com types of tables}}
{{ hol (string, taul) alist }}
| ( empty ) :: M :: empty
  {{ com empty function map }}
  {{ hol [] }}

delta {{ tex \Delta }} :: delta_ ::=
{{ hol ( delta_g # delta_b # delta_x # delta_t ) }}
| ( delta_g , delta_b , delta_x , delta_t ) :: M :: tup
  {{ com empty function map }}
  {{ hol ( [[delta_g]] , [[delta_b]] , [[delta_x]] , [[delta_t]] ) }}


order {{ tex \sqsubset }} :: order_ ::=
{{ hol ( funn list ) }}
| [ funn1 , .. , funnn ] :: :: fl



Prs_n {{ tex Prs_n }} :: Prs_n_ ::=
%list contains the names of the table names
{{ hol (string list) }}
| empty :: M :: empty
{{ hol []: string list  }}
| [ x1 , .. , xn ] :: M :: list
{{ hol [[x1 .. xn]] }}
|  Prs_n ++ [ "accept" ; "reject" ] :: M :: waccrej
{{ hol [[Prs_n]] ++ [ "accept" ; "reject"]  }}
| ( Prs_n ) :: M :: paren 
{{ hol ( [[Prs_n]] )}}


T_e {{ tex T_e }} :: T_e_ ::=
{{ hol ( order # funn # delta ) }}
| ( order , funn , delta ) :: M :: tup
{{ hol ( [[order]] , [[funn]] , [[delta]] ) }}




embed
{{ hol


(*************************************************)
(****** Typing Rules Related definitions *********)
(*************************************************)

(* returns the width of the bitstring *)
val bs_width_def = Define `
  bs_width (bl, (n:num)) = n
`;


val WF_def = Define `
(WF order) =    (( !x.   ~order x x ) /\
  		       	 ( !x y.  order x y ==> ~order y x) /\
                 ( !x y z. order x y /\ order y z ==> order x z))`;


(* find the type of the top most scope that contains x 
here the lists of the typing scope lists *)
val lookup_tau_def = Define `
  lookup_tau (ts:t_scope list) (t_scope_list_g:t_scope list) x =
    case lookup_map (ts++t_scope_list_g) x of
    | SOME t => SOME t
    | _ => NONE
`;

(* find the type of functions return value  *)
val find_star_in_globals_def = Define `
  find_star_in_globals (t_scope_list_g:t_scope_list_g) x =
    case lookup_map (t_scope_list_g) x of
    | SOME t => SOME t
    | _ => NONE
`;


(* lookup the functions type *)
val t_lookup_funn_def = Define `
  (t_lookup_funn (funn:funn) (delta_g:delta_g) (delta_b:delta_b) (delta_x:delta_x) =
    case funn of
    | (funn_name x) =>
     (case ALOOKUP delta_b x of
      | SOME (t, tdl) => SOME (t, tdl)
      | NONE =>
       (case ALOOKUP delta_g x of
        | SOME (t, tdl) => SOME (t, tdl)
        | NONE => NONE
       )
     )
    | (funn_inst x) =>
     (case ALOOKUP delta_x x of
      | SOME ((t, tdl), _) => SOME (t, tdl)
      | _ => NONE)
    | (funn_ext x x') =>
     (case ALOOKUP delta_x x of
      | SOME (_, (SOME x' , SOME (t,tdl) )) => SOME (t, tdl)
      | _ => NONE)
  )
`;



(* 
given a record feild names and their types xtl, with result tau and a string x, make sure that 
the string x has the proper type in the record list xtl, and it should be equal to to tau
used in feild access typing *)
val tau_in_rec_def = Define `
tau_in_rec (xtl:(x#tau) list) (x:x) (t:tau) =
    case (FIND (\(xm, tm). xm = x) xtl) of
    | SOME (xm, tm) => 
      if (tm = t) then (SOME T) else ( SOME F)
    | NONE => NONE
`;


(* Syntactic function to make the tau_in_rec retuens a boolean rather than option type*)
val correct_field_type_def = Define `
  correct_field_type (xtl:(x#tau) list) (x:x) (t:tau) =
      if (tau_in_rec xtl x t = (SOME T) )
      then T
      else F
`;


(* checks the lengths of the constants during the slicing operation.
(v,n) is the desired bitvector to slice from the index vec2 to vec1 
*)
val bits_length_chec_def = Define `
bits_length_check w (vec1) (vec2) =
     ( (0 <= vec2) /\ (vec2 <= vec1) /\ (vec1 < w) )
`; 


(* given three bitstrings that are aruments to the slicing operations, convert the 
bitstrings into constants and check if they adhere to teh specification's length requirements *)
val slice_length_check_def = Define `
slice_length_check w (vec1,len1) (vec2,len2) =
      bits_length_check w (v2n vec1) (v2n vec2)
`;

(* convert from a bit vector to constant *)
val vec_to_const_def = Define `
vec_to_const (vec,len) =
      (v2n vec)
`;


(* check if the dir is out, then the boolean b must be lval *)
val out_is_lval_def = Define `
out_is_lval dl bl =
 EVERY (\ (dir,b) . is_d_out dir ==> b ) (ZIP(dl, bl))
`;


(* returns true if the operation is conducted between two bitvectors and returnsa bitvector*)
val is_bv_op_def = Define `
is_bv_op (oper:binop) =
((oper = binop_mul) \/
(oper = binop_div) \/
(oper = binop_mod) \/
(oper = binop_add) \/
(oper = binop_sub) \/
(oper = binop_shl) \/
(oper = binop_shr) \/
(oper = binop_and) \/
(oper = binop_or) \/
(oper = binop_xor)) 
`;

(* returns true if the operation is conducted between two bitvectors and returns bool*)
val is_bv_bool_op_def = Define `
is_bv_bool_op (oper:binop) =
((oper = binop_le) \/
(oper = binop_ge) \/
(oper = binop_lt) \/
(oper = binop_gt) \/
(oper = binop_neq) \/
(oper = binop_eq)) 
`;

(* returns true if the operation is conducted between two bools and returns bool*)
val is_bool_op_def = Define `
is_bool_op (oper:binop) =
((oper = binop_bin_and) \/
(oper = binop_bin_or) \/
(oper = binop_neq) \/
(oper = binop_eq))  (*make sure to ask about this part, shall we create new ones for the bool*)
`;


(* checks if exery literial x in list xl, is a parser state name indeed*)
val literials_in_P_state_def = Define `
literials_in_P_state (xl: x list) (Prs_n:Prs_n) =
EVERY (\(x). MEM x Prs_n) (xl)
`;

(* returns the width of the bitstring *)
val bs_width_def = Define `
  bs_width (bl, (n:num)) = n
`;



val ordered_check_def = Define `
ordered_check (x:funn) y order =
  case INDEX_FIND 0 (\x' . x' = x ) (order) of
  | SOME (n , x ) =>
    ( case INDEX_FIND 0 (\y' . y' = y ) (order) of
      | SOME ( m , y ) => if (n < m) then (SOME T) else (SOME F)
      | NONE => NONE
    )
  | NONE => NONE
`;


val ordered_def = Define `
ordered (x:funn) y order =
  THE (ordered_check (x:funn) y order)
`;



val WF_o_def = Define `
(WF_o order) =    (( !(x:funn).   ~ (ordered x x order) ) /\
  		 ( !x y.  ordered x y order ==> ~ordered y x order) /\
       ( !x y z. ordered x y order/\ ordered y z order ==> ordered x z order))`;





}}

defns
v_typ :: '' ::=
defn
 v : ( tau , boolv )  :: :: v_typ :: v_
{{ com values types }}
{{ tex [[v]] : ( [[tau]] , [[boolv]] ) }}
by

 
----------------------------------- :: bool
  boolv : ( bool , false  )


 w = width bitv
----------------------------------- :: bit
  bitv : ( bs w , false  )


----------------------------------- :: bot
  bot : ( bot , false  )

%in pen and paper it will be presented as a set of possible values
%TODO try to make it a set later
  MEM x [ x1 , .. , xn ]
----------------------------------- :: x
  x : ( [ x1 , .. , xn ] , false  )


  x : ( [ x ] , false  )
----------------------------------- :: err
  errmsg x : ( err , false  )


 v1 , .. , vn : ( [ tau1 , .. , taun ] , false  )
----------------------------------- :: struct
 struct { x1 = v1 ; .. ; xn = vn } : ( struct [ x1 tau1 , .. , xn taun ] , false  )


 boolv : ( bool , false  )
 v1 , .. , vn : ( [ tau1 , .. , taun ] , false  )
----------------------------------- :: header
 header boolv { x1 = v1 ; .. ; xn = vn } : ( header [ x1 tau1 , .. , xn taun ] , false  )




embed
{{ hol

(*finds the domain (variable names) set of a scope *)
val scope_domain_def = Define `
scope_domain (scope:scope) = 
  FDOM (alist_to_fmap scope)
`;

(* finds a typing scope domain *)
val ts_domain_def = Define `
ts_domain (t_scope:t_scope) = 
  FDOM (alist_to_fmap t_scope)
`;

(* fetches the domain of each scope in a typing list*)
val tsl_domain_def = Define `
tsl_domain (tsl: t_scope list) =
 FOLDR  (\(t_scope) l. (ts_domain t_scope)::l ) [] (tsl) 
`;


(*in a list of typing scopes, get the domain of each typing then 
check of varn is a member for every single domain 
used for star checkup in the locals *)
val tsl_check_member_def = Define `
tsl_check_member (f:varn) (tsl) =
 EVERY (\doml. (f IN doml))  (tsl_domain tsl)
`;


val tsl_check_star_member_def = Define `
tsl_check_star_member (tsl) =
  ! x . EVERY (\doml. ~((varn_star x) IN doml)) (tsl_domain tsl)
`;

(* finds the value v of a given variable name vn from a certain scope *)
val fetch_val_from_scope_def = Define `
  fetch_val_from_scope (scope:scope) (vn) =
  case (ALOOKUP (scope) (vn)) of
  | SOME (v,opt) => SOME v
  | _ => NONE
`;


(* fetches the type tau of a given variable name in the typing scope t_scope*)
val fetch_tau_val_from_tscope_def = Define `
  fetch_tau_val_from_tscope (t_scope:t_scope) (vn) =
  case (ALOOKUP (t_scope) (vn)) of
  | SOME (t) => SOME t
  | _ => NONE
`;



(* for variable name vn, check if it well typed *)
val single_vn_typed_def = Define `
single_vn_typed (t_scope:t_scope) (scope:scope) (vn:varn)=
 case (ALOOKUP (scope) (vn)) of
 | SOME (v,opt) => ( case ALOOKUP t_scope vn of
         | SOME t => SOME (v_typ v t F)
	       | NONE => NONE)
| NONE => NONE 
`;




(* create a relation between two scopes *)

(* Single scope similarity *)
val similar_def = Define `
similar R l1 l2 = LIST_REL (\x y . (R (SND x) (SND y) ) /\ (FST x = FST y) ) l1 l2 `;


(*list of scopes similarity*)
val similarl_def = Define `
similarl R ll1 ll2 = LIST_REL (\l1 l2 . similar R l1 l2  ) ll1 ll2 `;



(* checks if a typing scope can type a scope which is the operation 
*      t_scope |- scope   *)

val type_scope_def = Define `
type_scope (scope:scope) (t_scope:t_scope) =
  similar (\x y . (v_typ (FST (x)) (y) F ) ) scope 
`;


(*check if a list of scopes can be typed with respect to a list of typing scopes 
       [t_scope1...t_scopen] |- [scope1 ... scopen]
*)
val type_scopes_list_def = Define `
type_scopes_list (sl:scope list) (tsl:t_scope list) =
 similarl (\x y . (v_typ (FST (x)) (y) F ) ) sl tsl
`;



(* checks if a variable varn is a variable name or not, it is used later to check 
that star is not a member of the local frame. WF property. 
*)
val is_varn_name_def = Define `
  (is_varn_name (varn_name _) = T) /\
  (is_varn_name _ = F)
`;



(*in a given scope and a typing scope, the domain is the same and also all variables are 
 not return /function place holders (aka var star) 
 *)
val star_not_in_s_def = Define `
star_not_in_s (s:scope) =
  ! f . (ALOOKUP s (varn_star f) = NONE)
`;


(*in a given scope list (in one frame) and a typing scope (of one frame), the domain 
 of each scope in the list is the same and also none of the scopes contain 
 a function place holder variable star 
 *)
val star_not_in_sl_def = Define `
star_not_in_sl (sl) =
 EVERY (\s.  (star_not_in_s s)  ) sl
`;



(* To type one single frame, all scopes (list of scopes) should be able to be typed 
   by the typyng list of scopes tsl, and also, the domain of each list is the same.
   The domains should comtain only variable names, and no var star
*)
val type_frame_tsl_def = Define `
type_frame_tsl (sl:scope list) (tsl: t_scope list) =
( similarl (\x y . (v_typ (FST (x)) (y) F ) ) sl tsl   /\
  star_not_in_sl (sl))
`;



(* type the global scope in a state: To type a global it is enough that all variables can 
type each other. NOTE: the global frames we keep the return functions variables stars. 
thus we do not check it's absence 
  ψ_G_list ⊢ γ_g_list
*)
val type_globals_tsl_def = Define `
type_globals_tsl (sl:scope list) (tsl: t_scope list)  =
similarl (\x y . (v_typ (FST (x)) (y) F ) ) sl tsl
`;


(* To type all frame's scopes, all frames's scopes should be able to be typed 
   by the typing list of scopes tsll, and also, the domain of each frame is the same.
*)
val type_state_tsll_def = Define `
type_state_tsll (sll:scope list list) (tsl: t_scope list) =
 type_frame_tsl (FLAT sll) (tsl)
`;

}}


defns
e_typ :: '' ::=
defn
t_scopes_tup T_e |- e : ( tau , boolv ) :: :: e_typ :: e_
{{ com expression types }}
{{ tex [[t_scopes_tup]] [[T_e]] \vdash [[e]] : ( [[tau]] , [[boolv]] ) }}
by


v : ( tau , b )
----------------------------------- :: v
t_scopes_tup T_e |- v : ( tau , b )

not_star (varn)
tau = lookup_tau ( t_scope_list , t_scope_list_g , varn )
----------------------------------- :: var
( t_scope_list_g , t_scope_list ) T_e |- var varn : ( tau , true )


[ tau1 d1 , .. , taun dn ] tau = t_lookup_funn ( funn' , delta_g , delta_b , delta_x )
tau = find_star_in_globals ( t_scope_list_g , ( star , funn' ) )
----------------------------------- :: star
( t_scope_list_g , t_scope_list ) ( order , funn , ( delta_g , delta_b , delta_x , delta_t ) ) |- var ( star , funn' ) : ( tau , true )


t_scopes_tup T_e |-  ( e1 , .. , en ) : ( [ tau1 , .. , taun ] , [ b1 , .. , bn ]  )
----------------------------------- :: struct
t_scopes_tup T_e |- eStruct { f1 = e1 ; .. ; fn = en } : ( struct [ f1 tau1 , .. , fn taun ] , false  )


t_scopes_tup T_e |-  ( e1 , .. , en ) : ( [ tau1 , .. , taun ] , [ b1 , .. , bn ] )
----------------------------------- :: header
t_scopes_tup T_e |- eHeader boolv { f1 = e1 ; .. ; fn = en } : ( header [ f1 tau1 , .. , fn taun ] , false  )


not_bool_neg unop
t_scopes_tup T_e |- e : ( bs w , b )
----------------------------------- :: not_neg
t_scopes_tup T_e |- unop e : ( bs w , false  )


is_bool_neg unop
t_scopes_tup T_e |- e : ( bool , b )
----------------------------------- :: is_neg
t_scopes_tup T_e |- unop e : ( bool , false  )


t_scopes_tup T_e |- e : ( struct_ty [ x1 tau1 , .. , xn taun ] , b )
correct_field_type ( [ x1 tau1 , .. , xn taun ] , x , tau )
----------------------------------- :: acc
t_scopes_tup T_e |- e . x : ( tau , b )


t_scopes_tup T_e |- e : ( bs w1 , b )
t_scopes_tup T_e |- e' : ( bs w2 , b' )
----------------------------------- :: concat
t_scopes_tup T_e |-  concat e e'  : ( bs ( w1 + w2 ) , false  )



w1 = vec_to_const bitv
w2 = vec_to_const bitv'
t_scopes_tup T_e |- e : ( bs w , b )
bits_length_check ( w , w1 , w2 )
----------------------------------- :: slice
t_scopes_tup T_e |- e [ bitv : bitv' ] : ( bs ( ( w1 - w2 ) + 1 ) , b )



t_scopes_tup T_e |- e : ( tau , b' )
( v1 , .. , vn ) : ( tau , b )
----------------------------------- :: select
t_scopes_tup T_e |- select e { v1 : x1 ; .. ; vn : xn } x : ( [ x1 , .. , xn ] ++ [ x ] , false  )



[ tau1 d1 , .. , taun dn ] tau = t_lookup_funn ( funn' , delta_g , delta_b , delta_x ) 
t_scopes_tup ( order , funn , ( delta_g , delta_b , delta_x , delta_t ) ) |-  ( e1 , .. , en ) : ( [ tau1 , .. , taun ] , [ b1 , .. , bn ] )
out_is_lval  [ d1 , .. , dn ]  [ b1 , .. , bn ]
ordered funn' funn order
----------------------------------- :: call
t_scopes_tup ( order , funn , ( delta_g , delta_b , delta_x , delta_t ) ) |- call funn' ( e1 , .. , en ) : ( tau , false  )



t_scopes_tup T_e |-  e   : ( bs w , b )
t_scopes_tup T_e |-  e'  : ( bs w , b' )
is_bv_op binop
------------------------------------ :: binop_bv
t_scopes_tup T_e |-  e binop e' : ( bs w , false  )


t_scopes_tup T_e |-  e   : ( bool , b )
t_scopes_tup T_e |-  e'  : ( bool , b' )
is_bool_op binop
------------------------------------ :: binop_bool
t_scopes_tup T_e |-  e binop e' : ( bool , false  )


t_scopes_tup T_e |-  e   : ( bs w , b )
t_scopes_tup T_e |-  e'  : ( bs w , b' )
is_bv_bool_op binop
------------------------------------ :: binop_bv_bool
t_scopes_tup T_e |-  e binop e' : ( bool , false  )



defns
stmt_typ :: '' ::=
defn
t_scopes_tup T_e Prs_n |- stmt  :: :: stmt_typ :: stmt_
{{ com expression types }}
{{ tex [[t_scopes_tup]] [[T_e]] [[Prs_n]] |- [[stmt]] }}
by



--------------------------------------- :: empty
t_scopes_tup T_e Prs_n |- empty_stmt



t_scopes_tup T_e |- var varn : ( tau , true )
t_scopes_tup T_e |-  e    : ( tau , b )
--------------------------------------- :: assign
t_scopes_tup T_e Prs_n |- assign varn e



t_scopes_tup T_e |-  e  : ( tau , b )
--------------------------------------- :: assign_null
t_scopes_tup T_e Prs_n |- assign null e



t_scopes_tup T_e |-  e  : ( bool , b )
t_scopes_tup T_e Prs_n |- stmt1
t_scopes_tup T_e Prs_n |- stmt2
--------------------------------------- :: if
t_scopes_tup T_e Prs_n |- if e then stmt1 else stmt2



( t_scope_list_g , [ t_scope ] ++ t_scope_list ) T_e Prs_n |- stmt
--------------------------------------- :: decl
( t_scope_list_g , t_scope_list ) T_e Prs_n |- begin t_scope stmt end 



t_scopes_tup T_e Prs_n |- stmt1
t_scopes_tup T_e Prs_n |- stmt2
--------------------------------------- :: seq
t_scopes_tup T_e Prs_n |-  stmt1 ; stmt2 



t_scopes_tup T_e |-  e  : ( bool , b )
t_scopes_tup T_e |-  e'  : ( [ x1 , .. , xn ] , b' )
--------------------------------------- :: verify
t_scopes_tup T_e Prs_n |-  verify e e' 



t_scopes_tup T_e |-  e  : ( [ x1 , .. , xn ] , b )
literials_in_P_state [ x1 , .. , xn ] ( Prs_n ++ [ "accept" ; "reject" ] )
--------------------------------------- :: transition
t_scopes_tup T_e Prs_n |-  transition e 



[ tau1 d1 , .. , taun dn ] tau = t_lookup_funn ( funn , delta_g , delta_b , ( empty ) )
t_scopes_tup ( order , funn , ( delta_g , delta_b , delta_x , delta_t ) ) |-  e  : ( tau , b )
--------------------------------------- :: return
t_scopes_tup ( order , funn , ( delta_g , delta_b , delta_x , delta_t ) ) Prs_n |-  return e



 delta_t ( tbl ) = [ tau1 , .. , taun ]
 t_scopes_tup ( order , funn , ( delta_g , delta_b , delta_x , delta_t ) ) |- ( e1 , .. , en ) : ( [ tau1 , .. , taun ] , [ b1 , .. , bn ] ) 
--------------------------------------- :: apply
t_scopes_tup ( order , funn , ( delta_g , delta_b , delta_x , delta_t )  ) Prs_n |-  apply tbl ( e1 , .. , en ) 


 
--------------------------------------- :: ext
t_scopes_tup T_e Prs_n |-  ext





embed
{{ hol

val type_ith_stmt_def = Define `
type_ith_stmt t_scope_list_g t_scope_list T_e Prs_n stmt_stack =
! i . i < LENGTH stmt_stack ==>
      stmt_typ (t_scope_list_g, ( DROP i t_scope_list)  ) T_e Prs_n (EL i stmt_stack)
`;

}}



defns
stmtl_typ :: '' ::=
defn
t_scopes_tup T_e Prs_n |- stmt_stack  :: :: stmtl_typ :: stmtl_
{{ com expression types }}
{{ tex [[t_scopes_tup]] [[T_e]] [[Prs_n]] |- [[stmt_stack]] }}
by


not_empty [ stmt1 , .. , stmtn ] 
type_ith_stmt t_scope_list_g [ t_scope1 , .. , t_scopen ] T_e Prs_n [ stmt1 , .. , stmtn ] 
--------------------------------------- :: list
( t_scope_list_g , [ t_scope1 , .. , t_scopen ] ) T_e Prs_n |- [ stmt1 , .. , stmtn ]







defns
frame_typ :: '' ::=
defn
t_scopes_tup T_e Prs_n |- ( g_scope_list , scope_list , stmt_stack )  :: :: frame_typ :: frame_
{{ com expression types }}
{{ tex [[t_scopes_tup]] [[T_e]] [[Prs_n]] |- ( [[g_scope_list]] , [[scope_list]] , [[stmt_stack]] )  }}
by

%note that in this rule will be mainly used to rewrite the definitions once we are typing the result frame of an expression reduction.


type_frame_tsl scope_list t_scope_list
type_globals_tsl g_scope_list t_scope_list_g
( t_scope_list_g , t_scope_list ) T_e Prs_n |- stmt_stack
not_empty stmt_stack 
--------------------------------------- :: stmtl
( t_scope_list_g , t_scope_list ) T_e Prs_n |- ( g_scope_list , scope_list , stmt_stack ) 




embed
{{ hol


(*TODO Fix this*)
(*initial implementation of the end statement of some function's body during the call should terminate
so we are looking into the statements if there exsist a return statement
I think we need to BOTH:
1. e terminates 
2. the frame that e can create is always well typed...
*)

val end_stmt_is_ret_def = Define `
  (end_stmt_is_ret (stmt_ret e) = T ) /\
  (end_stmt_is_ret (stmt_ext) = T ) /\   (*this should be false because if P4 you should not call an ext from a function*)
  (end_stmt_is_ret (stmt_empty) = F ) /\
  (end_stmt_is_ret (stmt_verify e e') = F) /\
  (end_stmt_is_ret (stmt_trans e) = F ) /\
  (end_stmt_is_ret (stmt_app x el) = F ) /\
  (end_stmt_is_ret (stmt_cond (e_v (v_bool T)) stmt1 stmt2) = end_stmt_is_ret (stmt1)) /\    (*not sure what to do with the condition if it is simply e ???*)
  (end_stmt_is_ret (stmt_cond (e_v (v_bool F)) stmt1 stmt2) = end_stmt_is_ret (stmt2)) /\
  (end_stmt_is_ret (stmt_block dl stmt) = end_stmt_is_ret (stmt)) /\
  (end_stmt_is_ret (stmt_seq stmt1 stmt2) = (end_stmt_is_ret (stmt1) \/ end_stmt_is_ret (stmt2)) ) 
`;






val mk_varn_def = Define `
mk_varn (xl:string list) =
FOLDR (\x l.  (varn_name x) :: l ) [] (xl)  
`;


(*based on the specs, the extern cannot be called from functions *)
val func_map_typed_def = Define `
func_map_typed (func_map:func_map) order (t_scope_list_g:t_scope_list_g) delta_g  =
! f stmt xdl  tau tdl x (t_scope':t_scope) xl tl.
 ( (f = funn_name x) /\
   (ALOOKUP func_map x = SOME (stmt, xdl)) )
   ==>
   (SOME (tdl,tau) = t_lookup_funn f delta_g [] [] ) /\
   (xl = mk_varn  (FST (UNZIP xdl ))) /\
   (tl = FST (UNZIP tdl )) /\
   (t_scope' = ZIP (xl , tl ) ) /\ 
   ( stmt_typ ( t_scope_list_g  ,  [t_scope'] ) (  order, f , (delta_g,[],[],[])) [] (stmt) ) /\
   ( ALL_DISTINCT (FST (UNZIP(xdl))) ) /\
   ( end_stmt_is_ret stmt)
`;





val func_map_blk_typed_def = Define `
func_map_blk_typed (b_func_map:b_func_map) order t_scope_list_g delta_g delta_b delta_x =
! f stmt xdl  tau tdl x (t_scope':t_scope) xl tl.
 ( (f = funn_name x) /\
   (ALOOKUP b_func_map x = SOME (stmt, xdl))
) ==>
   (SOME (tdl,tau) = t_lookup_funn f [] delta_b [] ) /\
   (xl = mk_varn  (FST (UNZIP xdl ))) /\
   (tl = FST (UNZIP tdl )) /\
   (t_scope' = ZIP (xl , tl ) ) /\ 
   ( stmt_typ ( t_scope_list_g  ,  [t_scope'] ) (  order, f , (delta_g,delta_b,delta_x,[])) [] (stmt) ) /\
   ( ALL_DISTINCT (FST (UNZIP(xdl))) ) /\
   ( end_stmt_is_ret stmt)

`;


(*note the statement here can only be the black box*)



val extern_map_IoE_typed_def = Define `
extern_map_IoE_typed (ext_map: 'a ext_map) order t_scope_list_g delta_x  =

! f (stmt:stmt) (xdl : (string # d) list) x IoE MoE tdl tau (t_scope':t_scope) (a:'a) (a':'a) (g_scope_list:g_scope_list)  scope_list' v local_scope xl tl .
         f = funn_inst x /\
	 ALOOKUP ext_map x = SOME (SOME (stmt,xdl,IoE),MoE) ==>

         SOME (tdl,tau) = t_lookup_funn f [] [] delta_x /\
   (xl = mk_varn  (FST (UNZIP xdl ))) /\
   (tl = FST (UNZIP tdl )) /\
   (t_scope' = ZIP (xl , tl ) ) /\ 
	 (stmt_typ ( t_scope_list_g, [t_scope'] ) ( order, f , ([],[],[],[])) [] (stmt)) /\
	 ALL_DISTINCT (FST (UNZIP xdl)) /\
	 [local_scope] = declare_list_in_fresh_scope ( t_scope' ) /\
	 SOME (a',scope_list', v) = IoE (a,g_scope_list, [ [local_scope] ]) /\
	 v_typ v tau F /\
	 type_scopes_list scope_list' [t_scope']
`;


(* if the above is ok, then uncomment this one for the ext methods calls

val extern_MoE_typed_def = Define `
extern_MoE_typed ext_map order t_scope_list_g delta_x  =

! f stmt xdl x x' IoE MoE tdl tau t_scope' (a:'a) (a':'a) (g_scope_list:g_scope_list)  scope_list' v local_scope .
         f = funn_ext x x' /\
	 ALOOKUP ext_map x = SOME (SOME (stmt,xdl,IoE),MoE) ==>
   
         SOME (tdl,tau) = t_lookup_funn f [] [] delta_x /\
   (xl = mk_varn  (FST (UNZIP xdl ))) /\
   (tl = FST (UNZIP tdl )) /\
   (t_scope' = ZIP (xl , tl ) ) /\ 
	 (stmt_typ ( t_scope_list_g, [t_scope'] ) ( order, f , ([],[],[],[])) [] (stmt)) /\
	 ALL_DISTINCT (FST (UNZIP xdl)) /\
	 [local_scope] = declare_list_in_fresh_scope ( t_scope' ) /\
	 (a',scope_list', v) = MoE (a,g_scope_list, [ [local_scope] ] ) /\
	 v_typ v tau F /\
	 type_scopes_list scope_list' [t_scope']
`;
*)


(*****************)
(*  domain       *)
(*****************)
(* takes two lists and checks if the domains are different*)
val dom_neq_def = Define `
dom_neq l1 l2 =
! f z. ((ALOOKUP l1 f = NONE) /\ (ALOOKUP l2 f = SOME z)) \/
      ((ALOOKUP l2 f = NONE) /\ (ALOOKUP l1 f = SOME z)) \/
      ((ALOOKUP l1 f = NONE) /\ (ALOOKUP l2 f = NONE))
`;


val dom_eq_def = Define `
dom_eq l1 l2 =
! f z1 z2. ((ALOOKUP l1 f = SOME z1) /\ (ALOOKUP l2 f = SOME z2)) 
`;


val dom_map_neq_def = Define `
dom_map_neq (func_map:func_map) (b_func_map:b_func_map) =
  dom_neq func_map b_func_map
`;



val dom_tmap_neq_def = Define `
dom_tmap_neq (delta_g:delta_g) (delta_b:delta_b) =
  dom_neq delta_g delta_b
`;



val dom_g_eq_def = Define `
dom_g_eq (delta_g:delta_g) (func_map:func_map) =
  dom_eq delta_g func_map
`;



val dom_b_eq_def = Define `
dom_b_eq (delta_b:delta_b) (b_func_map:b_func_map) =
  dom_eq delta_b b_func_map
`;


val dom_x_eq_def = Define `
dom_x_eq (delta_x:delta_x) (ext_map: 'a ext_map) =
  dom_eq delta_x ext_map
`;



(* represents 
∀f ∈ domain( Fg ). var(star,f) ∈ domain(gsl_t[1])
*)

val Fg_star_defined_def = Define `
Fg_star_defined (func_map:func_map) (t_scope_list_g:t_scope_list_g) =
! f sig t x. ((f = funn_name x) /\  (ALOOKUP func_map x = SOME sig)) /\
     (ALOOKUP (EL 1 t_scope_list_g)  (varn_star f) = SOME t)
`;



val Fb_star_defined_def = Define `
Fb_star_defined (b_func_map:b_func_map) (t_scope_list_g:t_scope_list_g) =
! f sig t x. ((f = funn_name x) /\  (ALOOKUP b_func_map x = SOME sig)) /\
     (ALOOKUP (EL 0 t_scope_list_g)  (varn_star f) = SOME t)
`;



val X_star_defined_def = Define `
X_star_defined (ext_map: 'a ext_map) (t_scope_list_g:t_scope_list_g) =
! f sig t x x'.
         ((f = funn_inst x \/ f = funn_ext x x') /\
          ALOOKUP ext_map x = SOME sig) /\
         ALOOKUP (EL 1 t_scope_list_g) (varn_star f) = SOME t
`;



val t_scopes_to_pass_def = Define `
 t_scopes_to_pass (funn:funn) (delta_g:delta_g) (delta_b:delta_b) (t_scope_list_g:t_scope_list_g) =
  case funn of
   | (funn_name x) =>
    (case ALOOKUP delta_b x of
     | SOME (t, tl) => SOME t_scope_list_g
     | NONE =>
      (case ALOOKUP delta_g x of
       | SOME (t, tl) => SOME ([ []; EL 1 t_scope_list_g])
       | NONE => SOME t_scope_list_g
      )
    )
   | _ => SOME ([ []; EL 1 t_scope_list_g])
`;

}}



defns
WTFg :: '' ::=
defn
 func_map -| order t_scope_list_g delta_g  :: :: WTFg :: WTFg_
{{ com global functions well typed }}
{{ tex [[func_map]] [[order]] [[t_scope_list_g]] [[delta_g]] }}
by


func_map_typed func_map order t_scope_list_g delta_g
--------------------------------------------------------- :: global
func_map -| order t_scope_list_g delta_g




defns
WTFb :: '' ::=
defn
 b_func_map -| order t_scope_list_g delta_g delta_b delta_x  :: :: WTFb :: WTFb_
{{ com actions and local functions well typed }}
{{ tex  [[b_func_map]] [[order]] [[t_scope_list_g]] [[delta_g]] [[delta_b]] [[delta_x]] }}
by


func_map_blk_typed b_func_map order t_scope_list_g delta_g delta_b delta_x
--------------------------------------------------------- :: block
b_func_map -| order t_scope_list_g delta_g delta_b delta_x




defns
WTX :: '' ::=
defn
 ext_map -| order t_scope_list_g delta_x  :: :: WTX :: WTX_
{{ com extern well typed }}
{{ tex  [[ext_map]] [[order]] [[t_scope_list_g]] [[delta_x]] }}
by

% if this def approved add the WT_XMoE in this rule
extern_map_IoE_typed ext_map order t_scope_list_g delta_x
--------------------------------------------------------- :: ext
ext_map -| order t_scope_list_g delta_x






defns
WT_c :: '' ::=
defn
 ctx -| order t_scope_list_g delta_g delta_b delta_x :: :: WT_c :: WT_c_
{{ com context well typed }}
{{ tex [[ctx]] -| [[order]] [[t_scope_list_g]] [[delta_g]] [[delta_b]] [[delta_x]] }}
by



WF_o order
length_is_2 ( t_scope_list_g )
dom_map_neq ( func_map , b_func_map )
dom_tmap_neq ( delta_g , delta_b )
dom_g_eq ( delta_g , func_map )
dom_b_eq ( delta_b , b_func_map )
dom_x_eq ( delta_x , ext_map )
Fg_star_defined ( func_map , t_scope_list_g )
Fb_star_defined ( b_func_map , t_scope_list_g )
X_star_defined  ( ext_map , t_scope_list_g )
func_map -| order t_scope_list_g delta_g
b_func_map -| order t_scope_list_g delta_g delta_b delta_x
ext_map -| order t_scope_list_g delta_x
--------------------------------------- :: c
( apply_table_f , ext_map , func_map , b_func_map , pars_map , tbl_map ) -| order t_scope_list_g delta_g delta_b delta_x






defns
WT_state :: '' ::=
defn
 ctx state Prs_n order t_scopes_tup delta :: :: WT_state :: WT_state_
{{ com context well typed }}
{{ tex WT [[ctx]] [[state]] [[Prs_n]] [[order]] [[t_scopes_tup]] [[delta]] }}
by

%todo: in the previous setting, the status was supposde to be running.
%This is bad because if it was tran then this will not be WF?

%TODO add last def.


type_state_tsll ( scope_list1 , .. , scope_listn ) t_scope_list
type_globals_tsl g_scope_list t_scope_list_g
ctx -| order t_scope_list_g delta_g delta_b delta_x
---------------------------------------------------------------------- :: state
ctx ( ascope , g_scope_list , [ [ ( funn1 , stmt_stack1 , scope_list1 ) ] , .. , [ ( funnn , stmt_stackn , scope_listn ) ] ] , Running ) Prs_n order ( t_scope_list_g , t_scope_list ) ( delta_g , delta_b , delta_x , delta_t )








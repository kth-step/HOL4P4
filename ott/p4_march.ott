embed
{{ hol
open wordsTheory;
}}
metavar string, var_name, func_name ::=
      {{ lex alphanum }}
      {{ hol string }}
      {{ com string }}
metavar num ::=
      {{ lex numeral }}
      {{ hol num }}
      {{ com natural number }}
metavar bool ::=
      {{ lex numeral }}
      {{ hol bool }}
      {{ com boolean }}
metavar int ::=
      {{ lex numeral }}
      {{ hol word64 }}
      {{ com integer }}
indexvar i, j, k, l ::=
  {{ lex numeral }}
  {{ coq nat }}
  {{ hol num }}
grammar

%%%%%%%%%%%%%%%%%%%
% Execution state %
%%%%%%%%%%%%%%%%%%%
%Note that this is not part of the P4 specification, but made up for verification purposes.

%Execution status.
status :: status_ ::=
 {{ com Execution status }}
| Running :: :: running
| TypeError :: :: type_error

env_stack :: env_stack_ ::=
{{ hol (stack_frame list) }}
{{ com current environment stack }}
| emptyes :: :: empty
  {{ hol ([]:stack_frame list) }}
| stack_frame1 , .. , stack_framei :: :: list
  {{ hol ([[stack_frame1 .. stack_framei]]) }}
| [ stack_frame ] :: :: sing
  {{ hol ([ [[stack_frame]] ]) }}
| env_stack . push ( stack_frame ) :: :: push
  {{ hol (([[stack_frame]]::[[env_stack]])) }}
| env_stack . tail :: :: tail
  {{ hol (TL [[env_stack]]) }}
| env_stack ++ env_stack' :: :: append
  {{ hol ([[env_stack]] ++ [[env_stack']]) }}
| ( env_stack ) :: S :: paren
  {{ hol ([[env_stack]]) }}

temp_stack :: temp_stack_ ::=
{{ com stack of caller env stacks }}
{{ hol (env_stack list) }}
| emptyts :: :: empty
  {{ hol ([]:env_stack list) }}
| env_stack1 , .. , env_stacki :: :: list
  {{ hol (env_stack list) }}
| temp_stack . push ( env_stack ) :: :: push
  {{ hol (([[env_stack]]::[[temp_stack]])) }}
| ( temp_stack ) :: S :: paren
  {{ hol ([[temp_stack]]) }}

stack_frame :: stack_frame_ ::=
{{ hol (string |-> word64) }}
{{ com frame/variable environment of current scope }}
| emptysf :: :: empty
  {{ com empty stack frame }}
  {{ hol FEMPTY }}
| stack_frame + [ string |-> int ] :: :: update
  {{ com update variable mapping }}
  {{ hol (FUPDATE [[stack_frame]] ([[string]], [[int]])) }}

state :: state_ ::=
 {{ com execution state }}
| ( env_stack , temp_stack , status ) :: :: ct


%%%%%%%%%%%%%%%
% Expressions %
%%%%%%%%%%%%%%%

exp :: exp_ ::=
{{ com expression }}
%TODO: Unify all of int, bv, b into a word64 const?
%| bv :: :: bv_const
| bool :: :: bool_const
  {{ com boolean value }}
| int :: :: int_const
  {{ com integer value }}
| var_name :: :: var
  {{ com variable name }}
| exp1 == exp2 :: :: eq
  {{ com equality }}
| exp1 - exp2 :: :: sub
  {{ com subtraction }}


%%%%%%%%%%%%%%
% Statements %
%%%%%%%%%%%%%%

stmt :: stmt_ ::=
{{ com statement }}
| return exp :: :: ret
  {{ com return }}
| assign var_name exp :: :: ass
  {{ com assignment }}
| func_name ( exp1 , .. , expi ) :: :: func
  {{ com function call }}

%TODO Function map is assumed static for now...
func_map :: func_map_ ::=
{{ com function map  }}
{{ hol (string |-> stmt) }}
%TODO Nothing of the below is exported to HOL4...
| empty :: M :: empty
  {{ com empty function map }}
  {{ hol FEMPTY }}
| func_map + [ string |-> stmt ] :: M :: update
  {{ com update variable mapping }}
  {{ hol (FUPDATE [[func_map]] ([[string]], [[stmt]])) }}

%%%%%%%%%%%%%%%%%%%%%%%%
% Expression semantics %
%%%%%%%%%%%%%%%%%%%%%%%%

terminals :: terminals_ ::=
| -> :: :: rightarrow {{ tex \rightarrow }}

formula :: formula_ ::=
{{ com formulas }}
| judgement :: :: judgement
  {{ com judgement }}
| int == int' = bool :: M :: eq
  {{ hol (([[int]] = [[int']]) = [[bool]]) }}
| int - int' = int'' :: M :: sub
  {{ hol ([[int]] - [[int']] = int'') }}
| env_stack ( var_name ) = stack_frame :: M :: find_frame
  {{ com find frame stack of variable }}
  %NOTE: FIND finds the first occurrence, starting from head and going backwards in list
  {{ hol (FIND (\sf. IS_SOME (FLOOKUP sf [[var_name]])) [[env_stack]] = SOME [[stack_frame]]) }}
| stack_frame = env_stack [ num ] :: M :: env_stack_index
  {{ hol ([[stack_frame]] = EL [[num]] [[env_stack]]) }}
| stack_frame ( var_name ) = int :: M :: lookup
  {{ com look-up of variable in stack frame }}
  {{ hol (FLOOKUP [[stack_frame]] [[var_name]] = SOME [[int]]) }}
| env_stack = env_stack' :: M :: env_stack_eq
  {{ com env_stack equality (for manipulation) }}
  {{ hol ([[env_stack]] = [[env_stack']]) }}
%TODO Typeset temp_stack and env_stack equalities differently... But how?
| temp_stack =' temp_stack' :: M :: temp_stack_eq
  {{ com temp_stack equality (for manipulation) }}
  {{ hol ([[temp_stack]] = [[temp_stack']]) }}
| env_stack = temp_stack . top :: M :: temp_stack_top
  {{ hol ([[env_stack]] = HD [[temp_stack]]) }}
| func_map ( func_name ) = stmt :: M :: func_lookup
  {{ com function lookup }}
  {{ hol (FLOOKUP [[func_map]] [[func_name]] = SOME [[stmt]]) }}

defns
  exp_sem :: '' ::=
defn
  [ exp ] state -> [ exp' ] state' :: :: exp_red :: ''
  {{ com expression semantics }}
by
%TODO: Status changes

%%%%%%%%%%%%%%%%%
%Variable look-up

  env_stack ( var_name ) = stack_frame
  stack_frame ( var_name ) = int
  ----------------------------------- :: lookup
  [varname] ( env_stack , temp_stack , status ) -> [int] ( env_stack , temp_stack , status )


%%%%%%%%%%%%%%%%%%%%
%Binary expressions%
%%%%%%%%%%%%%%%%%%%%

%Three rules for every expression:
%Reduce 1st operand
%Reduce 2nd operand, given 1st has been completely reduced
%Evaluate expression on 2 completely reduced operands

%%%%%%%%%%%%
%Subtraction

  [exp] ( env_stack , temp_stack , status ) -> [exp''] ( env_stack' , temp_stack' , status )
  ----------------------------------- :: sub1
  [exp - exp'] ( env_stack , temp_stack , status ) -> [exp'' - exp'] ( env_stack' , temp_stack' , status )

  [exp'] ( env_stack , temp_stack , status ) -> [exp''] ( env_stack' , temp_stack' , status )
  ----------------------------------- :: sub2
  [int - exp'] ( env_stack , temp_stack , status ) -> [int - exp''] ( env_stack' , temp_stack' , status )

  int - int' = int''
  ----------------------------------- :: sub3
  [int - int'] ( env_stack , temp_stack , status ) -> [int''] ( env_stack , temp_stack , status )

%%%%%%%%%%%%
%Equality

  [exp] ( env_stack , temp_stack , status ) -> [exp''] ( env_stack' , temp_stack' , status )
  ----------------------------------- :: eq1
  [exp == exp'] ( env_stack , temp_stack , status ) -> [exp'' == exp'] ( env_stack' , temp_stack' , status )

  [exp'] ( env_stack , temp_stack , status ) -> [exp''] ( env_stack' , temp_stack' , status )
  ----------------------------------- :: eq2
  [int == exp'] ( env_stack , temp_stack , status ) -> [int == exp''] ( env_stack' , temp_stack' , status )

  int == int' = bool
  ----------------------------------- :: eq3
  [int == int'] ( env_stack , temp_stack , status ) -> [bool] ( env_stack , temp_stack , status )


%%%%%%%%%%%%%%%%%%%%%%%
% Statement semantics %
%%%%%%%%%%%%%%%%%%%%%%%

defns
  stmt_sem :: '' ::=
defn
  [ stmt ] state -> [ stmt' ] state' :: :: stmt_red :: ''
  {{ com statement semantics }}
by

%TODO: Add function arguments
%TODO: Add directed arguments (in, out, inout)
  
  stack_frame = env_stack [ 0 ]
  env_stack' = ( emptyes . push ( stack_frame ) ) . push ( emptysf )
  temp_stack' =' temp_stack . push ( env_stack . tail )
  func_map ( func_name ) = stmt
  ----------------------------------- :: func_call
  [func_name ( )] ( env_stack , temp_stack , status ) -> [stmt] ( env_stack' , temp_stack' , status )



  [exp] ( env_stack , temp_stack , status ) -> [exp'] ( env_stack' , temp_stack' , status )
  ----------------------------------- :: ret1
  [return exp] ( env_stack , temp_stack , status ) -> [return exp'] ( env_stack' , temp_stack' , status )

defns
  stmt_sem_fin :: '' ::=
defn
  [ stmt ] state -> [ int ] state' :: :: stmt_red_fin :: ''
  {{ com statement semantics, finalize execution }}
by

  stack_frame = env_stack [ 0 ]
  env_stack' = temp_stack . top
  env_stack'' = ( env_stack' ) ++ ( [ stack_frame ] )
  ----------------------------------- :: ret2
  [return int] ( env_stack , temp_stack , status ) -> [int] ( env_stack' , temp_stack' , status )
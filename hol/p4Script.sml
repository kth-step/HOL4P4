(* generated by Ott 0.33 from: ../ott/p4_types.ott ../ott/p4_sem.ott ../ott/p4.ott *)
(* to compile: Holmake p4Theory.uo   *)
(* for interactive use:
  app load ["pred_setTheory","finite_mapTheory","stringTheory","containerTheory","ottLib"];
*)

open HolKernel boolLib Parse bossLib ottLib;
infix THEN THENC |-> ## ;
local open arithmeticTheory stringTheory containerTheory pred_setTheory listTheory 
  finite_mapTheory in end;

val _ = new_theory "p4";

open bitstringTheory;
open wordsTheory;
open alistTheory;

Type x = ``:string`` (* string *)
Type b = ``:bool`` (* boolean *)
Type bl = ``:bool list`` (* bit-string *)
Type i = ``:num`` (* natural number *)
Type m = ``:num`` (* indices *)

Type bitv = ``:(bl # num)``

Type boolv = ``:bool``

Type num_exp = ``:num``


val _ = Hol_datatype ` 
funn = 
   funn_name of x (* function name *)
 | funn_inst of x (* extern object instantiation *)
 | funn_ext of x => x (* extern method call *)
`;
val _ = Hol_datatype ` 
varn = 
   varn_name of x (* variable name *)
 | varn_star of funn (* function return placeholder *)
`;
val _ = Hol_datatype ` 
v =  (* value *)
   v_bool of boolv (* boolean value *)
 | v_bit of bitv (* bit-string *)
 | v_str of x (* string literal *)
 | v_struct of (x#v) list (* struct *)
 | v_header of boolv => (x#v) list (* header *)
 | v_ext_ref of i (* extern object reference *)
 | v_bot (* no value *)
`;
val _ = Hol_datatype ` 
status =  (* execution status *)
   status_running
 | status_returnv of v
 | status_trans of x (* transition to parser state *)
`;

Type v_list = ``:(v list)``
val _ = Hol_datatype ` 
mk =  (* matching kinds *)
   mk_exact
 | mk_ternary
 | mk_lpm
 | mk_range
 | mk_optional
 | mk_selector
`;


val _ = Hol_datatype ` 
binop = 
   binop_mul (* multiplication *)
 | binop_div (* division *)
 | binop_mod (* modulo *)
 | binop_add (* addition *)
 | binop_sat_add (* saturating addition *)
 | binop_sub (* subtraction *)
 | binop_sat_sub (* saturating subtraction *)
 | binop_shl (* logical left-shift *)
 | binop_shr (* logical right-shift *)
 | binop_le (* less or equal *)
 | binop_ge (* greater or equal *)
 | binop_lt (* less *)
 | binop_gt (* greater *)
 | binop_neq (* not equal *)
 | binop_eq (* equal *)
 | binop_and (* bitwise and *)
 | binop_xor (* bitwise xor *)
 | binop_or (* bitwise or *)
 | binop_bin_and (* binary and *)
 | binop_bin_or (* binary or *)
`;
val _ = Hol_datatype ` 
cast = 
   cast_unsigned of m (* unsigned cast *)
`;
val _ = Hol_datatype ` 
unop = 
   unop_neg (* negation *)
 | unop_compl (* bitwise complement *)
 | unop_neg_signed (* signed negation *)
 | unop_un_plus (* unary plus *)
`;

Type mk_list = ``:(mk list)``
val _ = Hol_datatype ` 
s =  (* set *)
   s_sing of v (* singleton *)
 | s_range of bitv => bitv (* interval *)
 | s_mask of bitv => bitv (* bit mask *)
 | s_univ (* universal *)
`;



Type s_list = ``:(s list)``
val _ = Hol_datatype ` 
e =  (* expression *)
   e_v of v (* value *)
 | e_var of varn (* variable *)
 | e_list of e list (* expression list *)
 | e_acc of e => x (* field access *)
 | e_unop of unop => e (* unary operation *)
 | e_cast of cast => e (* cast *)
 | e_binop of e => binop => e (* binary operation *)
 | e_concat of e => e (* concatenation of bit-strings *)
 | e_slice of e => e => e (* bit-slice *)
 | e_call of funn => e list (* function or extern call *)
 | e_select of e => (s_list#x) list => x (* select *)
 | e_struct of (x#e) list (* struct *)
 | e_header of boolv => (x#e) list (* header *)
`;


val _ = Hol_datatype ` 
lval = 
   lval_varname of varn (* variable name *)
 | lval_null (* null variable *)
 | lval_field of lval => x (* field access *)
 | lval_slice of lval => e => e (* slice array *)
 | lval_paren of lval
`;

Type e_list = ``:(e list)``



Type scope = ``:((varn, (v # lval option)) alist)``

Type g_scope = ``:scope``


val _ = Hol_datatype ` 
struct_ty = 
   struct_ty_struct
 | struct_ty_header
`;
val _ = Hol_datatype ` 
tau =  (* type *)
   tau_bool (* boolean *)
 | tau_bit of num_exp (* bit-string *)
 | tau_bot (* no value *)
 | tau_xtl of struct_ty => (x#tau) list (* struct *)
 | tau_ext (* extern *)
`;
val _ = Hol_datatype ` 
d =  (* parameter direction *)
   d_in
 | d_out
 | d_inout
 | d_none
`;

Type Ftau = ``:( ( tau # x # d ) list # tau)``



Type g_scope_list = ``:(scope list)``

Type x_list = ``:(x list)``

Type scope_list = ``:(scope list)``
val _ = Hol_datatype ` 
t =  (* type *)
   t_tau of tau (* BASE TYPE *)
 | t_string_names_a of x_list (* represents parser states' names ex. a , not literals "a" *)
`;
val _ = Hol_datatype ` 
s_t =  (* value set type *)
   s_t_tau of tau (* base type *)
 | s_t_top (* wildcard type *)
`;

Type taul = ``:(tau list)``

Type s_t_list = ``:(s_t list)``

Type ext_fun = ``:(('a # g_scope_list # scope_list) -> (('a # scope_list # status) option))``

Type ff = ``:('a -> 'a option)``

Type d_list = ``:(d list)``



Type t_scope = ``:((varn, ( tau # lval option)) alist)``


val _ = Hol_datatype ` 
stmt =  (* statement *)
   stmt_empty (* empty statement *)
 | stmt_ass of lval => e (* assignment *)
 | stmt_cond of e => stmt => stmt (* conditional *)
 | stmt_block of t_scope => stmt (* block *)
 | stmt_ret of e (* return *)
 | stmt_seq of stmt => stmt (* sequence *)
 | stmt_trans of e (* transition *)
 | stmt_app of x => e list (* apply *)
 | stmt_ext (* extern *)
`;



Type b_func_map = ``:((string, (stmt # (string # d) list)) alist)``

Type func_map = ``:((string, (stmt # (string # d) list)) alist)``

Type ext_fun_map = ``:((string, ((string # d) list # 'a ext_fun)) alist)``



Type pars_map = ``:((string, stmt) alist)``

Type ext_map = ``:((string, ((((string # d) list # 'a ext_fun) option) # 'a ext_fun_map)) alist)``

Type tbl_map = ``:((string, ((mk list) # (x # e_list))) alist)``
val _ = Hol_datatype ` 
pbl_type =  (* programmable block type *)
   pbl_type_parser
 | pbl_type_control
`;

Type in_out = ``:(bl # num)``


val _ = Hol_datatype ` 
ffblock =  (* fixed-function block *)
   ffblock_ff of 'a ff
`;

Type pblock = ``:(pbl_type # ((string # d) list) # b_func_map # t_scope # pars_map # tbl_map)``



Type ffblock_map = ``:((string, 'a ffblock) alist)``

Type pblock_map = ``:((string, pblock) alist)``

Type in_out_list = ``:(in_out list)``

Type pblock_list = ``:(pblock list)``
val _ = Hol_datatype ` 
arch_block =  (* architectural block *)
   arch_block_inp
 | arch_block_pbl of x => e list
 | arch_block_ffbl of x
 | arch_block_out
`;



Type apply_table_f = ``:((x # e_list # mk_list # (x # e_list) # 'a) -> (x # e_list) option)``

Type copyout_pbl = ``:((g_scope list # 'a # d list # x list # status) -> 'a option)``

Type copyin_pbl = ``:((x list # d list # e list # 'a) -> scope option)``

Type output_f = ``:((in_out_list # 'a) -> (in_out_list # 'a) option)``

Type input_f = ``:((in_out_list # 'a) -> (in_out_list # 'a) option)``

Type ab_list = ``:(arch_block list)``



Type ctx = ``:('a apply_table_f # 'a ext_map # func_map # b_func_map # pars_map # tbl_map)``

Type actx = ``:(ab_list # pblock_map # 'a ffblock_map # 'a input_f # 'a output_f # 'a copyin_pbl # 'a copyout_pbl # 'a apply_table_f # 'a ext_map # func_map)``

Type stmt_stack = ``:(stmt list)``

Type frame = ``:(funn # stmt_stack # scope_list)``



Type frame_list = ``:(frame list)``

Type state = ``:('a # g_scope_list # frame_list # status)``

Type aenv = ``:(num # in_out_list # in_out_list # 'a)``


val _ = Hol_datatype ` 
arch_frame_list =  (* architecture-level frame list *)
   arch_frame_list_empty (* empty architecture-level frame list *)
 | arch_frame_list_regular of frame_list (* regular frame list *)
`;

Type astate = ``:('a aenv # g_scope_list # arch_frame_list # status)``

Type cstate = ``:((in_out_list # in_out_list # 'a) # ((num # g_scope_list # arch_frame_list # status) # (num # g_scope_list # arch_frame_list # status)))``
val is_const_def = Define `
  (is_const (e_v _) = T) /\
  (is_const _ = F)
`;
val is_consts_def = Define `
  is_consts el = ~(EXISTS (\e. ~(is_const e)) el)
`;

(* Access the field f of a struct or a header *)
val acc_f_def = Define `
  (acc_f (v_struct s) f =
    case FIND (\(f', v). f' = f) s of
    | SOME (f'', v) => SOME v
    | _ => NONE) /\
  (acc_f (v_header _ s) f =
    case FIND (\(f', v). f' = f) s of
    | SOME (f'', v) => SOME v
    | _ => NONE) /\
  (acc_f _ f = NONE)
`;

val bitv_bl_unop_def = Define `
  bitv_bl_unop unop (bl, n) = (unop bl, n)
`;

val bitv_cast_def = Define `
  bitv_cast n' (v, n) = (fixwidth n' v, n')
`;

val bool_cast_def = Define `
  bool_cast n' b = (fixwidth n' [b], n')
`;

val bitv_bl_binop_def = Define `
  bitv_bl_binop binop (bl, n) (bl', n') = (fixwidth n (binop bl bl'), n)
`;

val get_word_unop_def = Define `
  (get_word_unop unop_compl = word_1comp) /\
  (get_word_unop unop_neg_signed = word_2comp) /\
  (get_word_unop unop_un_plus = (\w. w))
`;
Definition w2_def:
  w2 w = ((w2v:2 word -> bool list) w,2)
End

Definition w3_def:
  w3 w = ((w2v:3 word -> bool list) w,3)
End

Definition w4_def:
  w4 w = ((w2v:4 word -> bool list) w,4)
End

Definition w5_def:
  w5 w = ((w2v:5 word -> bool list) w,5)
End

Definition w6_def:
  w6 w = ((w2v:6 word -> bool list) w,6)
End

Definition w7_def:
  w7 w = ((w2v:7 word -> bool list) w,7)
End

Definition w8_def:
  w8 w = ((w2v:8 word -> bool list) w,8)
End

Definition w9_def:
  w9 w = ((w2v:9 word -> bool list) w,9)
End

Definition w10_def:
  w10 w = ((w2v:10 word -> bool list) w,10)
End

Definition w11_def:
  w11 w = ((w2v:11 word -> bool list) w,11)
End

Definition w12_def:
  w12 w = ((w2v:12 word -> bool list) w,12)
End

Definition w13_def:
  w13 w = ((w2v:13 word -> bool list) w,13)
End

Definition w14_def:
  w14 w = ((w2v:14 word -> bool list) w,14)
End

Definition w15_def:
  w15 w = ((w2v:15 word -> bool list) w,15)
End

Definition w16_def:
  w16 w = ((w2v:16 word -> bool list) w,16)
End

Definition w17_def:
  w17 w = ((w2v:17 word -> bool list) w,17)
End

Definition w18_def:
  w18 w = ((w2v:18 word -> bool list) w,18)
End

Definition w19_def:
  w19 w = ((w2v:19 word -> bool list) w,19)
End

Definition w20_def:
  w20 w = ((w2v:20 word -> bool list) w,20)
End

Definition w21_def:
  w21 w = ((w2v:21 word -> bool list) w,21)
End

Definition w22_def:
  w22 w = ((w2v:22 word -> bool list) w,22)
End

Definition w23_def:
  w23 w = ((w2v:23 word -> bool list) w,23)
End

Definition w24_def:
  w24 w = ((w2v:24 word -> bool list) w,24)
End

Definition w25_def:
  w25 w = ((w2v:25 word -> bool list) w,25)
End

Definition w26_def:
  w26 w = ((w2v:26 word -> bool list) w,26)
End

Definition w27_def:
  w27 w = ((w2v:27 word -> bool list) w,27)
End

Definition w28_def:
  w28 w = ((w2v:28 word -> bool list) w,28)
End

Definition w29_def:
  w29 w = ((w2v:29 word -> bool list) w,29)
End

Definition w30_def:
  w30 w = ((w2v:30 word -> bool list) w,30)
End

Definition w31_def:
  w31 w = ((w2v:31 word -> bool list) w,31)
End

Definition w32_def:
  w32 w = ((w2v:32 word -> bool list) w,32)
End

Definition w33_def:
  w33 w = ((w2v:33 word -> bool list) w,33)
End

Definition w34_def:
  w34 w = ((w2v:34 word -> bool list) w,34)
End

Definition w35_def:
  w35 w = ((w2v:35 word -> bool list) w,35)
End

Definition w36_def:
  w36 w = ((w2v:36 word -> bool list) w,36)
End

Definition w37_def:
  w37 w = ((w2v:37 word -> bool list) w,37)
End

Definition w38_def:
  w38 w = ((w2v:38 word -> bool list) w,38)
End

Definition w39_def:
  w39 w = ((w2v:39 word -> bool list) w,39)
End

Definition w40_def:
  w40 w = ((w2v:40 word -> bool list) w,40)
End

Definition w41_def:
  w41 w = ((w2v:41 word -> bool list) w,41)
End

Definition w42_def:
  w42 w = ((w2v:42 word -> bool list) w,42)
End

Definition w43_def:
  w43 w = ((w2v:43 word -> bool list) w,43)
End

Definition w44_def:
  w44 w = ((w2v:44 word -> bool list) w,44)
End

Definition w45_def:
  w45 w = ((w2v:45 word -> bool list) w,45)
End

Definition w46_def:
  w46 w = ((w2v:46 word -> bool list) w,46)
End

Definition w47_def:
  w47 w = ((w2v:47 word -> bool list) w,47)
End

Definition w48_def:
  w48 w = ((w2v:48 word -> bool list) w,48)
End

Definition w49_def:
  w49 w = ((w2v:49 word -> bool list) w,49)
End

Definition w50_def:
  w50 w = ((w2v:50 word -> bool list) w,50)
End

Definition w51_def:
  w51 w = ((w2v:51 word -> bool list) w,51)
End

Definition w52_def:
  w52 w = ((w2v:52 word -> bool list) w,52)
End

Definition w53_def:
  w53 w = ((w2v:53 word -> bool list) w,53)
End

Definition w54_def:
  w54 w = ((w2v:54 word -> bool list) w,54)
End

Definition w55_def:
  w55 w = ((w2v:55 word -> bool list) w,55)
End

Definition w56_def:
  w56 w = ((w2v:56 word -> bool list) w,56)
End

Definition w57_def:
  w57 w = ((w2v:57 word -> bool list) w,57)
End

Definition w58_def:
  w58 w = ((w2v:58 word -> bool list) w,58)
End

Definition w59_def:
  w59 w = ((w2v:59 word -> bool list) w,59)
End

Definition w60_def:
  w60 w = ((w2v:60 word -> bool list) w,60)
End

Definition w61_def:
  w61 w = ((w2v:61 word -> bool list) w,61)
End

Definition w62_def:
  w62 w = ((w2v:62 word -> bool list) w,62)
End

Definition w63_def:
  w63 w = ((w2v:63 word -> bool list) w,63)
End

Definition w64_def:
  w64 w = ((w2v:64 word -> bool list) w,64)
End

Definition w65_def:
  w65 w = ((w2v:65 word -> bool list) w,65)
End

Definition w66_def:
  w66 w = ((w2v:66 word -> bool list) w,66)
End

Definition w67_def:
  w67 w = ((w2v:67 word -> bool list) w,67)
End

Definition w68_def:
  w68 w = ((w2v:68 word -> bool list) w,68)
End

Definition w69_def:
  w69 w = ((w2v:69 word -> bool list) w,69)
End

Definition w70_def:
  w70 w = ((w2v:70 word -> bool list) w,70)
End

Definition w71_def:
  w71 w = ((w2v:71 word -> bool list) w,71)
End

Definition w72_def:
  w72 w = ((w2v:72 word -> bool list) w,72)
End

Definition w73_def:
  w73 w = ((w2v:73 word -> bool list) w,73)
End

Definition w74_def:
  w74 w = ((w2v:74 word -> bool list) w,74)
End

Definition w75_def:
  w75 w = ((w2v:75 word -> bool list) w,75)
End

Definition w76_def:
  w76 w = ((w2v:76 word -> bool list) w,76)
End

Definition w77_def:
  w77 w = ((w2v:77 word -> bool list) w,77)
End

Definition w78_def:
  w78 w = ((w2v:78 word -> bool list) w,78)
End

Definition w79_def:
  w79 w = ((w2v:79 word -> bool list) w,79)
End

Definition w80_def:
  w80 w = ((w2v:80 word -> bool list) w,80)
End

Definition w81_def:
  w81 w = ((w2v:81 word -> bool list) w,81)
End

Definition w82_def:
  w82 w = ((w2v:82 word -> bool list) w,82)
End

Definition w83_def:
  w83 w = ((w2v:83 word -> bool list) w,83)
End

Definition w84_def:
  w84 w = ((w2v:84 word -> bool list) w,84)
End

Definition w85_def:
  w85 w = ((w2v:85 word -> bool list) w,85)
End

Definition w86_def:
  w86 w = ((w2v:86 word -> bool list) w,86)
End

Definition w87_def:
  w87 w = ((w2v:87 word -> bool list) w,87)
End

Definition w88_def:
  w88 w = ((w2v:88 word -> bool list) w,88)
End

Definition w89_def:
  w89 w = ((w2v:89 word -> bool list) w,89)
End

Definition w90_def:
  w90 w = ((w2v:90 word -> bool list) w,90)
End

Definition w91_def:
  w91 w = ((w2v:91 word -> bool list) w,91)
End

Definition w92_def:
  w92 w = ((w2v:92 word -> bool list) w,92)
End

Definition w93_def:
  w93 w = ((w2v:93 word -> bool list) w,93)
End

Definition w94_def:
  w94 w = ((w2v:94 word -> bool list) w,94)
End

Definition w95_def:
  w95 w = ((w2v:95 word -> bool list) w,95)
End

Definition w96_def:
  w96 w = ((w2v:96 word -> bool list) w,96)
End

Definition w97_def:
  w97 w = ((w2v:97 word -> bool list) w,97)
End

Definition w98_def:
  w98 w = ((w2v:98 word -> bool list) w,98)
End

Definition w99_def:
  w99 w = ((w2v:99 word -> bool list) w,99)
End

Definition w100_def:
  w100 w = ((w2v:100 word -> bool list) w,100)
End

Definition w101_def:
  w101 w = ((w2v:101 word -> bool list) w,101)
End

Definition w102_def:
  w102 w = ((w2v:102 word -> bool list) w,102)
End

Definition w103_def:
  w103 w = ((w2v:103 word -> bool list) w,103)
End

Definition w104_def:
  w104 w = ((w2v:104 word -> bool list) w,104)
End

Definition w105_def:
  w105 w = ((w2v:105 word -> bool list) w,105)
End

Definition w106_def:
  w106 w = ((w2v:106 word -> bool list) w,106)
End

Definition w107_def:
  w107 w = ((w2v:107 word -> bool list) w,107)
End

Definition w108_def:
  w108 w = ((w2v:108 word -> bool list) w,108)
End

Definition w109_def:
  w109 w = ((w2v:109 word -> bool list) w,109)
End

Definition w110_def:
  w110 w = ((w2v:110 word -> bool list) w,110)
End

Definition w111_def:
  w111 w = ((w2v:111 word -> bool list) w,111)
End

Definition w112_def:
  w112 w = ((w2v:112 word -> bool list) w,112)
End

Definition w113_def:
  w113 w = ((w2v:113 word -> bool list) w,113)
End

Definition w114_def:
  w114 w = ((w2v:114 word -> bool list) w,114)
End

Definition w115_def:
  w115 w = ((w2v:115 word -> bool list) w,115)
End

Definition w116_def:
  w116 w = ((w2v:116 word -> bool list) w,116)
End

Definition w117_def:
  w117 w = ((w2v:117 word -> bool list) w,117)
End

Definition w118_def:
  w118 w = ((w2v:118 word -> bool list) w,118)
End

Definition w119_def:
  w119 w = ((w2v:119 word -> bool list) w,119)
End

Definition w120_def:
  w120 w = ((w2v:120 word -> bool list) w,120)
End

Definition w121_def:
  w121 w = ((w2v:121 word -> bool list) w,121)
End

Definition w122_def:
  w122 w = ((w2v:122 word -> bool list) w,122)
End

Definition w123_def:
  w123 w = ((w2v:123 word -> bool list) w,123)
End

Definition w124_def:
  w124 w = ((w2v:124 word -> bool list) w,124)
End

Definition w125_def:
  w125 w = ((w2v:125 word -> bool list) w,125)
End

Definition w126_def:
  w126 w = ((w2v:126 word -> bool list) w,126)
End

Definition w127_def:
  w127 w = ((w2v:127 word -> bool list) w,127)
End

Definition w128_def:
  w128 w = ((w2v:128 word -> bool list) w,128)
End

val bitv_unop_def = Define `
    (bitv_unop unop (v, 1) = (w2v ((get_word_unop unop) ((v2w v): 1 word)), 1) )
/\  (bitv_unop unop (v, 2) = (w2v ((get_word_unop unop) ((v2w v): 2 word)), 2) )
/\  (bitv_unop unop (v, 3) = (w2v ((get_word_unop unop) ((v2w v): 3 word)), 3) )
/\  (bitv_unop unop (v, 4) = (w2v ((get_word_unop unop) ((v2w v): 4 word)), 4) )
/\  (bitv_unop unop (v, 5) = (w2v ((get_word_unop unop) ((v2w v): 5 word)), 5) )
/\  (bitv_unop unop (v, 6) = (w2v ((get_word_unop unop) ((v2w v): 6 word)), 6) )
/\  (bitv_unop unop (v, 7) = (w2v ((get_word_unop unop) ((v2w v): 7 word)), 7) )
/\  (bitv_unop unop (v, 8) = (w2v ((get_word_unop unop) ((v2w v): 8 word)), 8) )
/\  (bitv_unop unop (v, 9) = (w2v ((get_word_unop unop) ((v2w v): 9 word)), 9) )
/\  (bitv_unop unop (v, 10) = (w2v ((get_word_unop unop) ((v2w v): 10 word)), 10) )
/\  (bitv_unop unop (v, 11) = (w2v ((get_word_unop unop) ((v2w v): 11 word)), 11) )
/\  (bitv_unop unop (v, 12) = (w2v ((get_word_unop unop) ((v2w v): 12 word)), 12) )
/\  (bitv_unop unop (v, 13) = (w2v ((get_word_unop unop) ((v2w v): 13 word)), 13) )
/\  (bitv_unop unop (v, 14) = (w2v ((get_word_unop unop) ((v2w v): 14 word)), 14) )
/\  (bitv_unop unop (v, 15) = (w2v ((get_word_unop unop) ((v2w v): 15 word)), 15) )
/\  (bitv_unop unop (v, 16) = (w2v ((get_word_unop unop) ((v2w v): 16 word)), 16) )
/\  (bitv_unop unop (v, 17) = (w2v ((get_word_unop unop) ((v2w v): 17 word)), 17) )
/\  (bitv_unop unop (v, 18) = (w2v ((get_word_unop unop) ((v2w v): 18 word)), 18) )
/\  (bitv_unop unop (v, 19) = (w2v ((get_word_unop unop) ((v2w v): 19 word)), 19) )
/\  (bitv_unop unop (v, 20) = (w2v ((get_word_unop unop) ((v2w v): 20 word)), 20) )
/\  (bitv_unop unop (v, 21) = (w2v ((get_word_unop unop) ((v2w v): 21 word)), 21) )
/\  (bitv_unop unop (v, 22) = (w2v ((get_word_unop unop) ((v2w v): 22 word)), 22) )
/\  (bitv_unop unop (v, 23) = (w2v ((get_word_unop unop) ((v2w v): 23 word)), 23) )
/\  (bitv_unop unop (v, 24) = (w2v ((get_word_unop unop) ((v2w v): 24 word)), 24) )
/\  (bitv_unop unop (v, 25) = (w2v ((get_word_unop unop) ((v2w v): 25 word)), 25) )
/\  (bitv_unop unop (v, 26) = (w2v ((get_word_unop unop) ((v2w v): 26 word)), 26) )
/\  (bitv_unop unop (v, 27) = (w2v ((get_word_unop unop) ((v2w v): 27 word)), 27) )
/\  (bitv_unop unop (v, 28) = (w2v ((get_word_unop unop) ((v2w v): 28 word)), 28) )
/\  (bitv_unop unop (v, 29) = (w2v ((get_word_unop unop) ((v2w v): 29 word)), 29) )
/\  (bitv_unop unop (v, 30) = (w2v ((get_word_unop unop) ((v2w v): 30 word)), 30) )
/\  (bitv_unop unop (v, 31) = (w2v ((get_word_unop unop) ((v2w v): 31 word)), 31) )
/\  (bitv_unop unop (v, 32) = (w2v ((get_word_unop unop) ((v2w v): 32 word)), 32) )
/\  (bitv_unop unop (v, 33) = (w2v ((get_word_unop unop) ((v2w v): 33 word)), 33) )
/\  (bitv_unop unop (v, 34) = (w2v ((get_word_unop unop) ((v2w v): 34 word)), 34) )
/\  (bitv_unop unop (v, 35) = (w2v ((get_word_unop unop) ((v2w v): 35 word)), 35) )
/\  (bitv_unop unop (v, 36) = (w2v ((get_word_unop unop) ((v2w v): 36 word)), 36) )
/\  (bitv_unop unop (v, 37) = (w2v ((get_word_unop unop) ((v2w v): 37 word)), 37) )
/\  (bitv_unop unop (v, 38) = (w2v ((get_word_unop unop) ((v2w v): 38 word)), 38) )
/\  (bitv_unop unop (v, 39) = (w2v ((get_word_unop unop) ((v2w v): 39 word)), 39) )
/\  (bitv_unop unop (v, 40) = (w2v ((get_word_unop unop) ((v2w v): 40 word)), 40) )
/\  (bitv_unop unop (v, 41) = (w2v ((get_word_unop unop) ((v2w v): 41 word)), 41) )
/\  (bitv_unop unop (v, 42) = (w2v ((get_word_unop unop) ((v2w v): 42 word)), 42) )
/\  (bitv_unop unop (v, 43) = (w2v ((get_word_unop unop) ((v2w v): 43 word)), 43) )
/\  (bitv_unop unop (v, 44) = (w2v ((get_word_unop unop) ((v2w v): 44 word)), 44) )
/\  (bitv_unop unop (v, 45) = (w2v ((get_word_unop unop) ((v2w v): 45 word)), 45) )
/\  (bitv_unop unop (v, 46) = (w2v ((get_word_unop unop) ((v2w v): 46 word)), 46) )
/\  (bitv_unop unop (v, 47) = (w2v ((get_word_unop unop) ((v2w v): 47 word)), 47) )
/\  (bitv_unop unop (v, 48) = (w2v ((get_word_unop unop) ((v2w v): 48 word)), 48) )
/\  (bitv_unop unop (v, 49) = (w2v ((get_word_unop unop) ((v2w v): 49 word)), 49) )
/\  (bitv_unop unop (v, 50) = (w2v ((get_word_unop unop) ((v2w v): 50 word)), 50) )
/\  (bitv_unop unop (v, 51) = (w2v ((get_word_unop unop) ((v2w v): 51 word)), 51) )
/\  (bitv_unop unop (v, 52) = (w2v ((get_word_unop unop) ((v2w v): 52 word)), 52) )
/\  (bitv_unop unop (v, 53) = (w2v ((get_word_unop unop) ((v2w v): 53 word)), 53) )
/\  (bitv_unop unop (v, 54) = (w2v ((get_word_unop unop) ((v2w v): 54 word)), 54) )
/\  (bitv_unop unop (v, 55) = (w2v ((get_word_unop unop) ((v2w v): 55 word)), 55) )
/\  (bitv_unop unop (v, 56) = (w2v ((get_word_unop unop) ((v2w v): 56 word)), 56) )
/\  (bitv_unop unop (v, 57) = (w2v ((get_word_unop unop) ((v2w v): 57 word)), 57) )
/\  (bitv_unop unop (v, 58) = (w2v ((get_word_unop unop) ((v2w v): 58 word)), 58) )
/\  (bitv_unop unop (v, 59) = (w2v ((get_word_unop unop) ((v2w v): 59 word)), 59) )
/\  (bitv_unop unop (v, 60) = (w2v ((get_word_unop unop) ((v2w v): 60 word)), 60) )
/\  (bitv_unop unop (v, 61) = (w2v ((get_word_unop unop) ((v2w v): 61 word)), 61) )
/\  (bitv_unop unop (v, 62) = (w2v ((get_word_unop unop) ((v2w v): 62 word)), 62) )
/\  (bitv_unop unop (v, 63) = (w2v ((get_word_unop unop) ((v2w v): 63 word)), 63) )
/\  (bitv_unop unop (v, 64) = (w2v ((get_word_unop unop) ((v2w v): 64 word)), 64) )
/\  (bitv_unop unop (v, 65) = (w2v ((get_word_unop unop) ((v2w v): 65 word)), 65) )
/\  (bitv_unop unop (v, 66) = (w2v ((get_word_unop unop) ((v2w v): 66 word)), 66) )
/\  (bitv_unop unop (v, 67) = (w2v ((get_word_unop unop) ((v2w v): 67 word)), 67) )
/\  (bitv_unop unop (v, 68) = (w2v ((get_word_unop unop) ((v2w v): 68 word)), 68) )
/\  (bitv_unop unop (v, 69) = (w2v ((get_word_unop unop) ((v2w v): 69 word)), 69) )
/\  (bitv_unop unop (v, 70) = (w2v ((get_word_unop unop) ((v2w v): 70 word)), 70) )
/\  (bitv_unop unop (v, 71) = (w2v ((get_word_unop unop) ((v2w v): 71 word)), 71) )
/\  (bitv_unop unop (v, 72) = (w2v ((get_word_unop unop) ((v2w v): 72 word)), 72) )
/\  (bitv_unop unop (v, 73) = (w2v ((get_word_unop unop) ((v2w v): 73 word)), 73) )
/\  (bitv_unop unop (v, 74) = (w2v ((get_word_unop unop) ((v2w v): 74 word)), 74) )
/\  (bitv_unop unop (v, 75) = (w2v ((get_word_unop unop) ((v2w v): 75 word)), 75) )
/\  (bitv_unop unop (v, 76) = (w2v ((get_word_unop unop) ((v2w v): 76 word)), 76) )
/\  (bitv_unop unop (v, 77) = (w2v ((get_word_unop unop) ((v2w v): 77 word)), 77) )
/\  (bitv_unop unop (v, 78) = (w2v ((get_word_unop unop) ((v2w v): 78 word)), 78) )
/\  (bitv_unop unop (v, 79) = (w2v ((get_word_unop unop) ((v2w v): 79 word)), 79) )
/\  (bitv_unop unop (v, 80) = (w2v ((get_word_unop unop) ((v2w v): 80 word)), 80) )
/\  (bitv_unop unop (v, 81) = (w2v ((get_word_unop unop) ((v2w v): 81 word)), 81) )
/\  (bitv_unop unop (v, 82) = (w2v ((get_word_unop unop) ((v2w v): 82 word)), 82) )
/\  (bitv_unop unop (v, 83) = (w2v ((get_word_unop unop) ((v2w v): 83 word)), 83) )
/\  (bitv_unop unop (v, 84) = (w2v ((get_word_unop unop) ((v2w v): 84 word)), 84) )
/\  (bitv_unop unop (v, 85) = (w2v ((get_word_unop unop) ((v2w v): 85 word)), 85) )
/\  (bitv_unop unop (v, 86) = (w2v ((get_word_unop unop) ((v2w v): 86 word)), 86) )
/\  (bitv_unop unop (v, 87) = (w2v ((get_word_unop unop) ((v2w v): 87 word)), 87) )
/\  (bitv_unop unop (v, 88) = (w2v ((get_word_unop unop) ((v2w v): 88 word)), 88) )
/\  (bitv_unop unop (v, 89) = (w2v ((get_word_unop unop) ((v2w v): 89 word)), 89) )
/\  (bitv_unop unop (v, 90) = (w2v ((get_word_unop unop) ((v2w v): 90 word)), 90) )
/\  (bitv_unop unop (v, 91) = (w2v ((get_word_unop unop) ((v2w v): 91 word)), 91) )
/\  (bitv_unop unop (v, 92) = (w2v ((get_word_unop unop) ((v2w v): 92 word)), 92) )
/\  (bitv_unop unop (v, 93) = (w2v ((get_word_unop unop) ((v2w v): 93 word)), 93) )
/\  (bitv_unop unop (v, 94) = (w2v ((get_word_unop unop) ((v2w v): 94 word)), 94) )
/\  (bitv_unop unop (v, 95) = (w2v ((get_word_unop unop) ((v2w v): 95 word)), 95) )
/\  (bitv_unop unop (v, 96) = (w2v ((get_word_unop unop) ((v2w v): 96 word)), 96) )
/\  (bitv_unop unop (v, 97) = (w2v ((get_word_unop unop) ((v2w v): 97 word)), 97) )
/\  (bitv_unop unop (v, 98) = (w2v ((get_word_unop unop) ((v2w v): 98 word)), 98) )
/\  (bitv_unop unop (v, 99) = (w2v ((get_word_unop unop) ((v2w v): 99 word)), 99) )
/\  (bitv_unop unop (v, 100) = (w2v ((get_word_unop unop) ((v2w v): 100 word)), 100) )
/\  (bitv_unop unop (v, 101) = (w2v ((get_word_unop unop) ((v2w v): 101 word)), 101) )
/\  (bitv_unop unop (v, 102) = (w2v ((get_word_unop unop) ((v2w v): 102 word)), 102) )
/\  (bitv_unop unop (v, 103) = (w2v ((get_word_unop unop) ((v2w v): 103 word)), 103) )
/\  (bitv_unop unop (v, 104) = (w2v ((get_word_unop unop) ((v2w v): 104 word)), 104) )
/\  (bitv_unop unop (v, 105) = (w2v ((get_word_unop unop) ((v2w v): 105 word)), 105) )
/\  (bitv_unop unop (v, 106) = (w2v ((get_word_unop unop) ((v2w v): 106 word)), 106) )
/\  (bitv_unop unop (v, 107) = (w2v ((get_word_unop unop) ((v2w v): 107 word)), 107) )
/\  (bitv_unop unop (v, 108) = (w2v ((get_word_unop unop) ((v2w v): 108 word)), 108) )
/\  (bitv_unop unop (v, 109) = (w2v ((get_word_unop unop) ((v2w v): 109 word)), 109) )
/\  (bitv_unop unop (v, 110) = (w2v ((get_word_unop unop) ((v2w v): 110 word)), 110) )
/\  (bitv_unop unop (v, 111) = (w2v ((get_word_unop unop) ((v2w v): 111 word)), 111) )
/\  (bitv_unop unop (v, 112) = (w2v ((get_word_unop unop) ((v2w v): 112 word)), 112) )
/\  (bitv_unop unop (v, 113) = (w2v ((get_word_unop unop) ((v2w v): 113 word)), 113) )
/\  (bitv_unop unop (v, 114) = (w2v ((get_word_unop unop) ((v2w v): 114 word)), 114) )
/\  (bitv_unop unop (v, 115) = (w2v ((get_word_unop unop) ((v2w v): 115 word)), 115) )
/\  (bitv_unop unop (v, 116) = (w2v ((get_word_unop unop) ((v2w v): 116 word)), 116) )
/\  (bitv_unop unop (v, 117) = (w2v ((get_word_unop unop) ((v2w v): 117 word)), 117) )
/\  (bitv_unop unop (v, 118) = (w2v ((get_word_unop unop) ((v2w v): 118 word)), 118) )
/\  (bitv_unop unop (v, 119) = (w2v ((get_word_unop unop) ((v2w v): 119 word)), 119) )
/\  (bitv_unop unop (v, 120) = (w2v ((get_word_unop unop) ((v2w v): 120 word)), 120) )
/\  (bitv_unop unop (v, 121) = (w2v ((get_word_unop unop) ((v2w v): 121 word)), 121) )
/\  (bitv_unop unop (v, 122) = (w2v ((get_word_unop unop) ((v2w v): 122 word)), 122) )
/\  (bitv_unop unop (v, 123) = (w2v ((get_word_unop unop) ((v2w v): 123 word)), 123) )
/\  (bitv_unop unop (v, 124) = (w2v ((get_word_unop unop) ((v2w v): 124 word)), 124) )
/\  (bitv_unop unop (v, 125) = (w2v ((get_word_unop unop) ((v2w v): 125 word)), 125) )
/\  (bitv_unop unop (v, 126) = (w2v ((get_word_unop unop) ((v2w v): 126 word)), 126) )
/\  (bitv_unop unop (v, 127) = (w2v ((get_word_unop unop) ((v2w v): 127 word)), 127) )
/\  (bitv_unop unop (v, 128) = (w2v ((get_word_unop unop) ((v2w v): 128 word)), 128) )
`;

val get_word_binop_def = Define `
    (get_word_binop binop_mul = word_mul)
/\  (get_word_binop binop_div = word_div)
/\  (get_word_binop binop_mod = word_mod)
/\  (get_word_binop binop_add = word_add)
/\  (get_word_binop binop_sat_add = saturate_add)
/\  (get_word_binop binop_sub = word_sub)
/\  (get_word_binop binop_sat_sub = saturate_sub)
/\  (get_word_binop binop_shl = word_lsl_bv)
/\  (get_word_binop binop_shr = word_lsr_bv)
/\  (get_word_binop binop_and = word_and)
/\  (get_word_binop binop_xor = word_xor)
/\  (get_word_binop binop_or = word_or)
`;

val bitv_binop_inner_def = Define `
    (bitv_binop_inner binop v v' 1 = SOME (w2v ((get_word_binop binop) ((v2w v): 1 word) ((v2w v'): 1 word)), 1) )
/\  (bitv_binop_inner binop v v' 2 = SOME (w2v ((get_word_binop binop) ((v2w v): 2 word) ((v2w v'): 2 word)), 2) )
/\  (bitv_binop_inner binop v v' 3 = SOME (w2v ((get_word_binop binop) ((v2w v): 3 word) ((v2w v'): 3 word)), 3) )
/\  (bitv_binop_inner binop v v' 4 = SOME (w2v ((get_word_binop binop) ((v2w v): 4 word) ((v2w v'): 4 word)), 4) )
/\  (bitv_binop_inner binop v v' 5 = SOME (w2v ((get_word_binop binop) ((v2w v): 5 word) ((v2w v'): 5 word)), 5) )
/\  (bitv_binop_inner binop v v' 6 = SOME (w2v ((get_word_binop binop) ((v2w v): 6 word) ((v2w v'): 6 word)), 6) )
/\  (bitv_binop_inner binop v v' 7 = SOME (w2v ((get_word_binop binop) ((v2w v): 7 word) ((v2w v'): 7 word)), 7) )
/\  (bitv_binop_inner binop v v' 8 = SOME (w2v ((get_word_binop binop) ((v2w v): 8 word) ((v2w v'): 8 word)), 8) )
/\  (bitv_binop_inner binop v v' 9 = SOME (w2v ((get_word_binop binop) ((v2w v): 9 word) ((v2w v'): 9 word)), 9) )
/\  (bitv_binop_inner binop v v' 10 = SOME (w2v ((get_word_binop binop) ((v2w v): 10 word) ((v2w v'): 10 word)), 10) )
/\  (bitv_binop_inner binop v v' 11 = SOME (w2v ((get_word_binop binop) ((v2w v): 11 word) ((v2w v'): 11 word)), 11) )
/\  (bitv_binop_inner binop v v' 12 = SOME (w2v ((get_word_binop binop) ((v2w v): 12 word) ((v2w v'): 12 word)), 12) )
/\  (bitv_binop_inner binop v v' 13 = SOME (w2v ((get_word_binop binop) ((v2w v): 13 word) ((v2w v'): 13 word)), 13) )
/\  (bitv_binop_inner binop v v' 14 = SOME (w2v ((get_word_binop binop) ((v2w v): 14 word) ((v2w v'): 14 word)), 14) )
/\  (bitv_binop_inner binop v v' 15 = SOME (w2v ((get_word_binop binop) ((v2w v): 15 word) ((v2w v'): 15 word)), 15) )
/\  (bitv_binop_inner binop v v' 16 = SOME (w2v ((get_word_binop binop) ((v2w v): 16 word) ((v2w v'): 16 word)), 16) )
/\  (bitv_binop_inner binop v v' 17 = SOME (w2v ((get_word_binop binop) ((v2w v): 17 word) ((v2w v'): 17 word)), 17) )
/\  (bitv_binop_inner binop v v' 18 = SOME (w2v ((get_word_binop binop) ((v2w v): 18 word) ((v2w v'): 18 word)), 18) )
/\  (bitv_binop_inner binop v v' 19 = SOME (w2v ((get_word_binop binop) ((v2w v): 19 word) ((v2w v'): 19 word)), 19) )
/\  (bitv_binop_inner binop v v' 20 = SOME (w2v ((get_word_binop binop) ((v2w v): 20 word) ((v2w v'): 20 word)), 20) )
/\  (bitv_binop_inner binop v v' 21 = SOME (w2v ((get_word_binop binop) ((v2w v): 21 word) ((v2w v'): 21 word)), 21) )
/\  (bitv_binop_inner binop v v' 22 = SOME (w2v ((get_word_binop binop) ((v2w v): 22 word) ((v2w v'): 22 word)), 22) )
/\  (bitv_binop_inner binop v v' 23 = SOME (w2v ((get_word_binop binop) ((v2w v): 23 word) ((v2w v'): 23 word)), 23) )
/\  (bitv_binop_inner binop v v' 24 = SOME (w2v ((get_word_binop binop) ((v2w v): 24 word) ((v2w v'): 24 word)), 24) )
/\  (bitv_binop_inner binop v v' 25 = SOME (w2v ((get_word_binop binop) ((v2w v): 25 word) ((v2w v'): 25 word)), 25) )
/\  (bitv_binop_inner binop v v' 26 = SOME (w2v ((get_word_binop binop) ((v2w v): 26 word) ((v2w v'): 26 word)), 26) )
/\  (bitv_binop_inner binop v v' 27 = SOME (w2v ((get_word_binop binop) ((v2w v): 27 word) ((v2w v'): 27 word)), 27) )
/\  (bitv_binop_inner binop v v' 28 = SOME (w2v ((get_word_binop binop) ((v2w v): 28 word) ((v2w v'): 28 word)), 28) )
/\  (bitv_binop_inner binop v v' 29 = SOME (w2v ((get_word_binop binop) ((v2w v): 29 word) ((v2w v'): 29 word)), 29) )
/\  (bitv_binop_inner binop v v' 30 = SOME (w2v ((get_word_binop binop) ((v2w v): 30 word) ((v2w v'): 30 word)), 30) )
/\  (bitv_binop_inner binop v v' 31 = SOME (w2v ((get_word_binop binop) ((v2w v): 31 word) ((v2w v'): 31 word)), 31) )
/\  (bitv_binop_inner binop v v' 32 = SOME (w2v ((get_word_binop binop) ((v2w v): 32 word) ((v2w v'): 32 word)), 32) )
/\  (bitv_binop_inner binop v v' 33 = SOME (w2v ((get_word_binop binop) ((v2w v): 33 word) ((v2w v'): 33 word)), 33) )
/\  (bitv_binop_inner binop v v' 34 = SOME (w2v ((get_word_binop binop) ((v2w v): 34 word) ((v2w v'): 34 word)), 34) )
/\  (bitv_binop_inner binop v v' 35 = SOME (w2v ((get_word_binop binop) ((v2w v): 35 word) ((v2w v'): 35 word)), 35) )
/\  (bitv_binop_inner binop v v' 36 = SOME (w2v ((get_word_binop binop) ((v2w v): 36 word) ((v2w v'): 36 word)), 36) )
/\  (bitv_binop_inner binop v v' 37 = SOME (w2v ((get_word_binop binop) ((v2w v): 37 word) ((v2w v'): 37 word)), 37) )
/\  (bitv_binop_inner binop v v' 38 = SOME (w2v ((get_word_binop binop) ((v2w v): 38 word) ((v2w v'): 38 word)), 38) )
/\  (bitv_binop_inner binop v v' 39 = SOME (w2v ((get_word_binop binop) ((v2w v): 39 word) ((v2w v'): 39 word)), 39) )
/\  (bitv_binop_inner binop v v' 40 = SOME (w2v ((get_word_binop binop) ((v2w v): 40 word) ((v2w v'): 40 word)), 40) )
/\  (bitv_binop_inner binop v v' 41 = SOME (w2v ((get_word_binop binop) ((v2w v): 41 word) ((v2w v'): 41 word)), 41) )
/\  (bitv_binop_inner binop v v' 42 = SOME (w2v ((get_word_binop binop) ((v2w v): 42 word) ((v2w v'): 42 word)), 42) )
/\  (bitv_binop_inner binop v v' 43 = SOME (w2v ((get_word_binop binop) ((v2w v): 43 word) ((v2w v'): 43 word)), 43) )
/\  (bitv_binop_inner binop v v' 44 = SOME (w2v ((get_word_binop binop) ((v2w v): 44 word) ((v2w v'): 44 word)), 44) )
/\  (bitv_binop_inner binop v v' 45 = SOME (w2v ((get_word_binop binop) ((v2w v): 45 word) ((v2w v'): 45 word)), 45) )
/\  (bitv_binop_inner binop v v' 46 = SOME (w2v ((get_word_binop binop) ((v2w v): 46 word) ((v2w v'): 46 word)), 46) )
/\  (bitv_binop_inner binop v v' 47 = SOME (w2v ((get_word_binop binop) ((v2w v): 47 word) ((v2w v'): 47 word)), 47) )
/\  (bitv_binop_inner binop v v' 48 = SOME (w2v ((get_word_binop binop) ((v2w v): 48 word) ((v2w v'): 48 word)), 48) )
/\  (bitv_binop_inner binop v v' 49 = SOME (w2v ((get_word_binop binop) ((v2w v): 49 word) ((v2w v'): 49 word)), 49) )
/\  (bitv_binop_inner binop v v' 50 = SOME (w2v ((get_word_binop binop) ((v2w v): 50 word) ((v2w v'): 50 word)), 50) )
/\  (bitv_binop_inner binop v v' 51 = SOME (w2v ((get_word_binop binop) ((v2w v): 51 word) ((v2w v'): 51 word)), 51) )
/\  (bitv_binop_inner binop v v' 52 = SOME (w2v ((get_word_binop binop) ((v2w v): 52 word) ((v2w v'): 52 word)), 52) )
/\  (bitv_binop_inner binop v v' 53 = SOME (w2v ((get_word_binop binop) ((v2w v): 53 word) ((v2w v'): 53 word)), 53) )
/\  (bitv_binop_inner binop v v' 54 = SOME (w2v ((get_word_binop binop) ((v2w v): 54 word) ((v2w v'): 54 word)), 54) )
/\  (bitv_binop_inner binop v v' 55 = SOME (w2v ((get_word_binop binop) ((v2w v): 55 word) ((v2w v'): 55 word)), 55) )
/\  (bitv_binop_inner binop v v' 56 = SOME (w2v ((get_word_binop binop) ((v2w v): 56 word) ((v2w v'): 56 word)), 56) )
/\  (bitv_binop_inner binop v v' 57 = SOME (w2v ((get_word_binop binop) ((v2w v): 57 word) ((v2w v'): 57 word)), 57) )
/\  (bitv_binop_inner binop v v' 58 = SOME (w2v ((get_word_binop binop) ((v2w v): 58 word) ((v2w v'): 58 word)), 58) )
/\  (bitv_binop_inner binop v v' 59 = SOME (w2v ((get_word_binop binop) ((v2w v): 59 word) ((v2w v'): 59 word)), 59) )
/\  (bitv_binop_inner binop v v' 60 = SOME (w2v ((get_word_binop binop) ((v2w v): 60 word) ((v2w v'): 60 word)), 60) )
/\  (bitv_binop_inner binop v v' 61 = SOME (w2v ((get_word_binop binop) ((v2w v): 61 word) ((v2w v'): 61 word)), 61) )
/\  (bitv_binop_inner binop v v' 62 = SOME (w2v ((get_word_binop binop) ((v2w v): 62 word) ((v2w v'): 62 word)), 62) )
/\  (bitv_binop_inner binop v v' 63 = SOME (w2v ((get_word_binop binop) ((v2w v): 63 word) ((v2w v'): 63 word)), 63) )
/\  (bitv_binop_inner binop v v' 64 = SOME (w2v ((get_word_binop binop) ((v2w v): 64 word) ((v2w v'): 64 word)), 64) )
/\  (bitv_binop_inner binop v v' 65 = SOME (w2v ((get_word_binop binop) ((v2w v): 65 word) ((v2w v'): 65 word)), 65) )
/\  (bitv_binop_inner binop v v' 66 = SOME (w2v ((get_word_binop binop) ((v2w v): 66 word) ((v2w v'): 66 word)), 66) )
/\  (bitv_binop_inner binop v v' 67 = SOME (w2v ((get_word_binop binop) ((v2w v): 67 word) ((v2w v'): 67 word)), 67) )
/\  (bitv_binop_inner binop v v' 68 = SOME (w2v ((get_word_binop binop) ((v2w v): 68 word) ((v2w v'): 68 word)), 68) )
/\  (bitv_binop_inner binop v v' 69 = SOME (w2v ((get_word_binop binop) ((v2w v): 69 word) ((v2w v'): 69 word)), 69) )
/\  (bitv_binop_inner binop v v' 70 = SOME (w2v ((get_word_binop binop) ((v2w v): 70 word) ((v2w v'): 70 word)), 70) )
/\  (bitv_binop_inner binop v v' 71 = SOME (w2v ((get_word_binop binop) ((v2w v): 71 word) ((v2w v'): 71 word)), 71) )
/\  (bitv_binop_inner binop v v' 72 = SOME (w2v ((get_word_binop binop) ((v2w v): 72 word) ((v2w v'): 72 word)), 72) )
/\  (bitv_binop_inner binop v v' 73 = SOME (w2v ((get_word_binop binop) ((v2w v): 73 word) ((v2w v'): 73 word)), 73) )
/\  (bitv_binop_inner binop v v' 74 = SOME (w2v ((get_word_binop binop) ((v2w v): 74 word) ((v2w v'): 74 word)), 74) )
/\  (bitv_binop_inner binop v v' 75 = SOME (w2v ((get_word_binop binop) ((v2w v): 75 word) ((v2w v'): 75 word)), 75) )
/\  (bitv_binop_inner binop v v' 76 = SOME (w2v ((get_word_binop binop) ((v2w v): 76 word) ((v2w v'): 76 word)), 76) )
/\  (bitv_binop_inner binop v v' 77 = SOME (w2v ((get_word_binop binop) ((v2w v): 77 word) ((v2w v'): 77 word)), 77) )
/\  (bitv_binop_inner binop v v' 78 = SOME (w2v ((get_word_binop binop) ((v2w v): 78 word) ((v2w v'): 78 word)), 78) )
/\  (bitv_binop_inner binop v v' 79 = SOME (w2v ((get_word_binop binop) ((v2w v): 79 word) ((v2w v'): 79 word)), 79) )
/\  (bitv_binop_inner binop v v' 80 = SOME (w2v ((get_word_binop binop) ((v2w v): 80 word) ((v2w v'): 80 word)), 80) )
/\  (bitv_binop_inner binop v v' 81 = SOME (w2v ((get_word_binop binop) ((v2w v): 81 word) ((v2w v'): 81 word)), 81) )
/\  (bitv_binop_inner binop v v' 82 = SOME (w2v ((get_word_binop binop) ((v2w v): 82 word) ((v2w v'): 82 word)), 82) )
/\  (bitv_binop_inner binop v v' 83 = SOME (w2v ((get_word_binop binop) ((v2w v): 83 word) ((v2w v'): 83 word)), 83) )
/\  (bitv_binop_inner binop v v' 84 = SOME (w2v ((get_word_binop binop) ((v2w v): 84 word) ((v2w v'): 84 word)), 84) )
/\  (bitv_binop_inner binop v v' 85 = SOME (w2v ((get_word_binop binop) ((v2w v): 85 word) ((v2w v'): 85 word)), 85) )
/\  (bitv_binop_inner binop v v' 86 = SOME (w2v ((get_word_binop binop) ((v2w v): 86 word) ((v2w v'): 86 word)), 86) )
/\  (bitv_binop_inner binop v v' 87 = SOME (w2v ((get_word_binop binop) ((v2w v): 87 word) ((v2w v'): 87 word)), 87) )
/\  (bitv_binop_inner binop v v' 88 = SOME (w2v ((get_word_binop binop) ((v2w v): 88 word) ((v2w v'): 88 word)), 88) )
/\  (bitv_binop_inner binop v v' 89 = SOME (w2v ((get_word_binop binop) ((v2w v): 89 word) ((v2w v'): 89 word)), 89) )
/\  (bitv_binop_inner binop v v' 90 = SOME (w2v ((get_word_binop binop) ((v2w v): 90 word) ((v2w v'): 90 word)), 90) )
/\  (bitv_binop_inner binop v v' 91 = SOME (w2v ((get_word_binop binop) ((v2w v): 91 word) ((v2w v'): 91 word)), 91) )
/\  (bitv_binop_inner binop v v' 92 = SOME (w2v ((get_word_binop binop) ((v2w v): 92 word) ((v2w v'): 92 word)), 92) )
/\  (bitv_binop_inner binop v v' 93 = SOME (w2v ((get_word_binop binop) ((v2w v): 93 word) ((v2w v'): 93 word)), 93) )
/\  (bitv_binop_inner binop v v' 94 = SOME (w2v ((get_word_binop binop) ((v2w v): 94 word) ((v2w v'): 94 word)), 94) )
/\  (bitv_binop_inner binop v v' 95 = SOME (w2v ((get_word_binop binop) ((v2w v): 95 word) ((v2w v'): 95 word)), 95) )
/\  (bitv_binop_inner binop v v' 96 = SOME (w2v ((get_word_binop binop) ((v2w v): 96 word) ((v2w v'): 96 word)), 96) )
/\  (bitv_binop_inner binop v v' 97 = SOME (w2v ((get_word_binop binop) ((v2w v): 97 word) ((v2w v'): 97 word)), 97) )
/\  (bitv_binop_inner binop v v' 98 = SOME (w2v ((get_word_binop binop) ((v2w v): 98 word) ((v2w v'): 98 word)), 98) )
/\  (bitv_binop_inner binop v v' 99 = SOME (w2v ((get_word_binop binop) ((v2w v): 99 word) ((v2w v'): 99 word)), 99) )
/\  (bitv_binop_inner binop v v' 100 = SOME (w2v ((get_word_binop binop) ((v2w v): 100 word) ((v2w v'): 100 word)), 100) )
/\  (bitv_binop_inner binop v v' 101 = SOME (w2v ((get_word_binop binop) ((v2w v): 101 word) ((v2w v'): 101 word)), 101) )
/\  (bitv_binop_inner binop v v' 102 = SOME (w2v ((get_word_binop binop) ((v2w v): 102 word) ((v2w v'): 102 word)), 102) )
/\  (bitv_binop_inner binop v v' 103 = SOME (w2v ((get_word_binop binop) ((v2w v): 103 word) ((v2w v'): 103 word)), 103) )
/\  (bitv_binop_inner binop v v' 104 = SOME (w2v ((get_word_binop binop) ((v2w v): 104 word) ((v2w v'): 104 word)), 104) )
/\  (bitv_binop_inner binop v v' 105 = SOME (w2v ((get_word_binop binop) ((v2w v): 105 word) ((v2w v'): 105 word)), 105) )
/\  (bitv_binop_inner binop v v' 106 = SOME (w2v ((get_word_binop binop) ((v2w v): 106 word) ((v2w v'): 106 word)), 106) )
/\  (bitv_binop_inner binop v v' 107 = SOME (w2v ((get_word_binop binop) ((v2w v): 107 word) ((v2w v'): 107 word)), 107) )
/\  (bitv_binop_inner binop v v' 108 = SOME (w2v ((get_word_binop binop) ((v2w v): 108 word) ((v2w v'): 108 word)), 108) )
/\  (bitv_binop_inner binop v v' 109 = SOME (w2v ((get_word_binop binop) ((v2w v): 109 word) ((v2w v'): 109 word)), 109) )
/\  (bitv_binop_inner binop v v' 110 = SOME (w2v ((get_word_binop binop) ((v2w v): 110 word) ((v2w v'): 110 word)), 110) )
/\  (bitv_binop_inner binop v v' 111 = SOME (w2v ((get_word_binop binop) ((v2w v): 111 word) ((v2w v'): 111 word)), 111) )
/\  (bitv_binop_inner binop v v' 112 = SOME (w2v ((get_word_binop binop) ((v2w v): 112 word) ((v2w v'): 112 word)), 112) )
/\  (bitv_binop_inner binop v v' 113 = SOME (w2v ((get_word_binop binop) ((v2w v): 113 word) ((v2w v'): 113 word)), 113) )
/\  (bitv_binop_inner binop v v' 114 = SOME (w2v ((get_word_binop binop) ((v2w v): 114 word) ((v2w v'): 114 word)), 114) )
/\  (bitv_binop_inner binop v v' 115 = SOME (w2v ((get_word_binop binop) ((v2w v): 115 word) ((v2w v'): 115 word)), 115) )
/\  (bitv_binop_inner binop v v' 116 = SOME (w2v ((get_word_binop binop) ((v2w v): 116 word) ((v2w v'): 116 word)), 116) )
/\  (bitv_binop_inner binop v v' 117 = SOME (w2v ((get_word_binop binop) ((v2w v): 117 word) ((v2w v'): 117 word)), 117) )
/\  (bitv_binop_inner binop v v' 118 = SOME (w2v ((get_word_binop binop) ((v2w v): 118 word) ((v2w v'): 118 word)), 118) )
/\  (bitv_binop_inner binop v v' 119 = SOME (w2v ((get_word_binop binop) ((v2w v): 119 word) ((v2w v'): 119 word)), 119) )
/\  (bitv_binop_inner binop v v' 120 = SOME (w2v ((get_word_binop binop) ((v2w v): 120 word) ((v2w v'): 120 word)), 120) )
/\  (bitv_binop_inner binop v v' 121 = SOME (w2v ((get_word_binop binop) ((v2w v): 121 word) ((v2w v'): 121 word)), 121) )
/\  (bitv_binop_inner binop v v' 122 = SOME (w2v ((get_word_binop binop) ((v2w v): 122 word) ((v2w v'): 122 word)), 122) )
/\  (bitv_binop_inner binop v v' 123 = SOME (w2v ((get_word_binop binop) ((v2w v): 123 word) ((v2w v'): 123 word)), 123) )
/\  (bitv_binop_inner binop v v' 124 = SOME (w2v ((get_word_binop binop) ((v2w v): 124 word) ((v2w v'): 124 word)), 124) )
/\  (bitv_binop_inner binop v v' 125 = SOME (w2v ((get_word_binop binop) ((v2w v): 125 word) ((v2w v'): 125 word)), 125) )
/\  (bitv_binop_inner binop v v' 126 = SOME (w2v ((get_word_binop binop) ((v2w v): 126 word) ((v2w v'): 126 word)), 126) )
/\  (bitv_binop_inner binop v v' 127 = SOME (w2v ((get_word_binop binop) ((v2w v): 127 word) ((v2w v'): 127 word)), 127) )
/\  (bitv_binop_inner binop v v' 128 = SOME (w2v ((get_word_binop binop) ((v2w v): 128 word) ((v2w v'): 128 word)), 128) )
/\  (bitv_binop_inner binop v v' _ = NONE )
`;
val bitv_binop_def = Define `
  bitv_binop binop (v, n) (v', n') =
    if n = n'
    then bitv_binop_inner binop v v' n
    else NONE
`;

Definition bit_eq_def:
 (bit_eq (T, T) = T) /\
 (bit_eq (T, F) = F) /\
 (bit_eq (F, T) = F) /\
 (bit_eq (F, F) = T)
End

Definition word_eq_def:
 (word_eq w1 w2 =
  AND_EL (MAP bit_eq (ZIP(w2v w1, w2v w2))))
End

val get_word_binpred_def = Define `
    (get_word_binpred binop_le = word_ls)
/\  (get_word_binpred binop_ge = word_hs)
/\  (get_word_binpred binop_lt = word_lo)
/\  (get_word_binpred binop_gt = word_hi)
/\  (get_word_binpred binop_neq = (\w1 w2. ~(word_eq w1 w2)))
/\  (get_word_binpred binop_eq = (\w1 w2. word_eq w1 w2))
`;

val bitv_binpred_inner_def = Define `
    (bitv_binpred_inner binpred v v' 1 = SOME (((get_word_binpred binpred) ((v2w v): 1 word) ((v2w v'): 1 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 2 = SOME (((get_word_binpred binpred) ((v2w v): 2 word) ((v2w v'): 2 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 3 = SOME (((get_word_binpred binpred) ((v2w v): 3 word) ((v2w v'): 3 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 4 = SOME (((get_word_binpred binpred) ((v2w v): 4 word) ((v2w v'): 4 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 5 = SOME (((get_word_binpred binpred) ((v2w v): 5 word) ((v2w v'): 5 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 6 = SOME (((get_word_binpred binpred) ((v2w v): 6 word) ((v2w v'): 6 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 7 = SOME (((get_word_binpred binpred) ((v2w v): 7 word) ((v2w v'): 7 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 8 = SOME (((get_word_binpred binpred) ((v2w v): 8 word) ((v2w v'): 8 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 9 = SOME (((get_word_binpred binpred) ((v2w v): 9 word) ((v2w v'): 9 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 10 = SOME (((get_word_binpred binpred) ((v2w v): 10 word) ((v2w v'): 10 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 11 = SOME (((get_word_binpred binpred) ((v2w v): 11 word) ((v2w v'): 11 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 12 = SOME (((get_word_binpred binpred) ((v2w v): 12 word) ((v2w v'): 12 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 13 = SOME (((get_word_binpred binpred) ((v2w v): 13 word) ((v2w v'): 13 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 14 = SOME (((get_word_binpred binpred) ((v2w v): 14 word) ((v2w v'): 14 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 15 = SOME (((get_word_binpred binpred) ((v2w v): 15 word) ((v2w v'): 15 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 16 = SOME (((get_word_binpred binpred) ((v2w v): 16 word) ((v2w v'): 16 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 17 = SOME (((get_word_binpred binpred) ((v2w v): 17 word) ((v2w v'): 17 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 18 = SOME (((get_word_binpred binpred) ((v2w v): 18 word) ((v2w v'): 18 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 19 = SOME (((get_word_binpred binpred) ((v2w v): 19 word) ((v2w v'): 19 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 20 = SOME (((get_word_binpred binpred) ((v2w v): 20 word) ((v2w v'): 20 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 21 = SOME (((get_word_binpred binpred) ((v2w v): 21 word) ((v2w v'): 21 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 22 = SOME (((get_word_binpred binpred) ((v2w v): 22 word) ((v2w v'): 22 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 23 = SOME (((get_word_binpred binpred) ((v2w v): 23 word) ((v2w v'): 23 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 24 = SOME (((get_word_binpred binpred) ((v2w v): 24 word) ((v2w v'): 24 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 25 = SOME (((get_word_binpred binpred) ((v2w v): 25 word) ((v2w v'): 25 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 26 = SOME (((get_word_binpred binpred) ((v2w v): 26 word) ((v2w v'): 26 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 27 = SOME (((get_word_binpred binpred) ((v2w v): 27 word) ((v2w v'): 27 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 28 = SOME (((get_word_binpred binpred) ((v2w v): 28 word) ((v2w v'): 28 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 29 = SOME (((get_word_binpred binpred) ((v2w v): 29 word) ((v2w v'): 29 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 30 = SOME (((get_word_binpred binpred) ((v2w v): 30 word) ((v2w v'): 30 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 31 = SOME (((get_word_binpred binpred) ((v2w v): 31 word) ((v2w v'): 31 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 32 = SOME (((get_word_binpred binpred) ((v2w v): 32 word) ((v2w v'): 32 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 33 = SOME (((get_word_binpred binpred) ((v2w v): 33 word) ((v2w v'): 33 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 34 = SOME (((get_word_binpred binpred) ((v2w v): 34 word) ((v2w v'): 34 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 35 = SOME (((get_word_binpred binpred) ((v2w v): 35 word) ((v2w v'): 35 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 36 = SOME (((get_word_binpred binpred) ((v2w v): 36 word) ((v2w v'): 36 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 37 = SOME (((get_word_binpred binpred) ((v2w v): 37 word) ((v2w v'): 37 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 38 = SOME (((get_word_binpred binpred) ((v2w v): 38 word) ((v2w v'): 38 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 39 = SOME (((get_word_binpred binpred) ((v2w v): 39 word) ((v2w v'): 39 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 40 = SOME (((get_word_binpred binpred) ((v2w v): 40 word) ((v2w v'): 40 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 41 = SOME (((get_word_binpred binpred) ((v2w v): 41 word) ((v2w v'): 41 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 42 = SOME (((get_word_binpred binpred) ((v2w v): 42 word) ((v2w v'): 42 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 43 = SOME (((get_word_binpred binpred) ((v2w v): 43 word) ((v2w v'): 43 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 44 = SOME (((get_word_binpred binpred) ((v2w v): 44 word) ((v2w v'): 44 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 45 = SOME (((get_word_binpred binpred) ((v2w v): 45 word) ((v2w v'): 45 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 46 = SOME (((get_word_binpred binpred) ((v2w v): 46 word) ((v2w v'): 46 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 47 = SOME (((get_word_binpred binpred) ((v2w v): 47 word) ((v2w v'): 47 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 48 = SOME (((get_word_binpred binpred) ((v2w v): 48 word) ((v2w v'): 48 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 49 = SOME (((get_word_binpred binpred) ((v2w v): 49 word) ((v2w v'): 49 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 50 = SOME (((get_word_binpred binpred) ((v2w v): 50 word) ((v2w v'): 50 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 51 = SOME (((get_word_binpred binpred) ((v2w v): 51 word) ((v2w v'): 51 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 52 = SOME (((get_word_binpred binpred) ((v2w v): 52 word) ((v2w v'): 52 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 53 = SOME (((get_word_binpred binpred) ((v2w v): 53 word) ((v2w v'): 53 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 54 = SOME (((get_word_binpred binpred) ((v2w v): 54 word) ((v2w v'): 54 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 55 = SOME (((get_word_binpred binpred) ((v2w v): 55 word) ((v2w v'): 55 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 56 = SOME (((get_word_binpred binpred) ((v2w v): 56 word) ((v2w v'): 56 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 57 = SOME (((get_word_binpred binpred) ((v2w v): 57 word) ((v2w v'): 57 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 58 = SOME (((get_word_binpred binpred) ((v2w v): 58 word) ((v2w v'): 58 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 59 = SOME (((get_word_binpred binpred) ((v2w v): 59 word) ((v2w v'): 59 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 60 = SOME (((get_word_binpred binpred) ((v2w v): 60 word) ((v2w v'): 60 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 61 = SOME (((get_word_binpred binpred) ((v2w v): 61 word) ((v2w v'): 61 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 62 = SOME (((get_word_binpred binpred) ((v2w v): 62 word) ((v2w v'): 62 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 63 = SOME (((get_word_binpred binpred) ((v2w v): 63 word) ((v2w v'): 63 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 64 = SOME (((get_word_binpred binpred) ((v2w v): 64 word) ((v2w v'): 64 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 65 = SOME (((get_word_binpred binpred) ((v2w v): 65 word) ((v2w v'): 65 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 66 = SOME (((get_word_binpred binpred) ((v2w v): 66 word) ((v2w v'): 66 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 67 = SOME (((get_word_binpred binpred) ((v2w v): 67 word) ((v2w v'): 67 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 68 = SOME (((get_word_binpred binpred) ((v2w v): 68 word) ((v2w v'): 68 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 69 = SOME (((get_word_binpred binpred) ((v2w v): 69 word) ((v2w v'): 69 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 70 = SOME (((get_word_binpred binpred) ((v2w v): 70 word) ((v2w v'): 70 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 71 = SOME (((get_word_binpred binpred) ((v2w v): 71 word) ((v2w v'): 71 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 72 = SOME (((get_word_binpred binpred) ((v2w v): 72 word) ((v2w v'): 72 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 73 = SOME (((get_word_binpred binpred) ((v2w v): 73 word) ((v2w v'): 73 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 74 = SOME (((get_word_binpred binpred) ((v2w v): 74 word) ((v2w v'): 74 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 75 = SOME (((get_word_binpred binpred) ((v2w v): 75 word) ((v2w v'): 75 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 76 = SOME (((get_word_binpred binpred) ((v2w v): 76 word) ((v2w v'): 76 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 77 = SOME (((get_word_binpred binpred) ((v2w v): 77 word) ((v2w v'): 77 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 78 = SOME (((get_word_binpred binpred) ((v2w v): 78 word) ((v2w v'): 78 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 79 = SOME (((get_word_binpred binpred) ((v2w v): 79 word) ((v2w v'): 79 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 80 = SOME (((get_word_binpred binpred) ((v2w v): 80 word) ((v2w v'): 80 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 81 = SOME (((get_word_binpred binpred) ((v2w v): 81 word) ((v2w v'): 81 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 82 = SOME (((get_word_binpred binpred) ((v2w v): 82 word) ((v2w v'): 82 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 83 = SOME (((get_word_binpred binpred) ((v2w v): 83 word) ((v2w v'): 83 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 84 = SOME (((get_word_binpred binpred) ((v2w v): 84 word) ((v2w v'): 84 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 85 = SOME (((get_word_binpred binpred) ((v2w v): 85 word) ((v2w v'): 85 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 86 = SOME (((get_word_binpred binpred) ((v2w v): 86 word) ((v2w v'): 86 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 87 = SOME (((get_word_binpred binpred) ((v2w v): 87 word) ((v2w v'): 87 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 88 = SOME (((get_word_binpred binpred) ((v2w v): 88 word) ((v2w v'): 88 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 89 = SOME (((get_word_binpred binpred) ((v2w v): 89 word) ((v2w v'): 89 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 90 = SOME (((get_word_binpred binpred) ((v2w v): 90 word) ((v2w v'): 90 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 91 = SOME (((get_word_binpred binpred) ((v2w v): 91 word) ((v2w v'): 91 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 92 = SOME (((get_word_binpred binpred) ((v2w v): 92 word) ((v2w v'): 92 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 93 = SOME (((get_word_binpred binpred) ((v2w v): 93 word) ((v2w v'): 93 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 94 = SOME (((get_word_binpred binpred) ((v2w v): 94 word) ((v2w v'): 94 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 95 = SOME (((get_word_binpred binpred) ((v2w v): 95 word) ((v2w v'): 95 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 96 = SOME (((get_word_binpred binpred) ((v2w v): 96 word) ((v2w v'): 96 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 97 = SOME (((get_word_binpred binpred) ((v2w v): 97 word) ((v2w v'): 97 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 98 = SOME (((get_word_binpred binpred) ((v2w v): 98 word) ((v2w v'): 98 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 99 = SOME (((get_word_binpred binpred) ((v2w v): 99 word) ((v2w v'): 99 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 100 = SOME (((get_word_binpred binpred) ((v2w v): 100 word) ((v2w v'): 100 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 101 = SOME (((get_word_binpred binpred) ((v2w v): 101 word) ((v2w v'): 101 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 102 = SOME (((get_word_binpred binpred) ((v2w v): 102 word) ((v2w v'): 102 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 103 = SOME (((get_word_binpred binpred) ((v2w v): 103 word) ((v2w v'): 103 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 104 = SOME (((get_word_binpred binpred) ((v2w v): 104 word) ((v2w v'): 104 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 105 = SOME (((get_word_binpred binpred) ((v2w v): 105 word) ((v2w v'): 105 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 106 = SOME (((get_word_binpred binpred) ((v2w v): 106 word) ((v2w v'): 106 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 107 = SOME (((get_word_binpred binpred) ((v2w v): 107 word) ((v2w v'): 107 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 108 = SOME (((get_word_binpred binpred) ((v2w v): 108 word) ((v2w v'): 108 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 109 = SOME (((get_word_binpred binpred) ((v2w v): 109 word) ((v2w v'): 109 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 110 = SOME (((get_word_binpred binpred) ((v2w v): 110 word) ((v2w v'): 110 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 111 = SOME (((get_word_binpred binpred) ((v2w v): 111 word) ((v2w v'): 111 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 112 = SOME (((get_word_binpred binpred) ((v2w v): 112 word) ((v2w v'): 112 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 113 = SOME (((get_word_binpred binpred) ((v2w v): 113 word) ((v2w v'): 113 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 114 = SOME (((get_word_binpred binpred) ((v2w v): 114 word) ((v2w v'): 114 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 115 = SOME (((get_word_binpred binpred) ((v2w v): 115 word) ((v2w v'): 115 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 116 = SOME (((get_word_binpred binpred) ((v2w v): 116 word) ((v2w v'): 116 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 117 = SOME (((get_word_binpred binpred) ((v2w v): 117 word) ((v2w v'): 117 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 118 = SOME (((get_word_binpred binpred) ((v2w v): 118 word) ((v2w v'): 118 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 119 = SOME (((get_word_binpred binpred) ((v2w v): 119 word) ((v2w v'): 119 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 120 = SOME (((get_word_binpred binpred) ((v2w v): 120 word) ((v2w v'): 120 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 121 = SOME (((get_word_binpred binpred) ((v2w v): 121 word) ((v2w v'): 121 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 122 = SOME (((get_word_binpred binpred) ((v2w v): 122 word) ((v2w v'): 122 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 123 = SOME (((get_word_binpred binpred) ((v2w v): 123 word) ((v2w v'): 123 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 124 = SOME (((get_word_binpred binpred) ((v2w v): 124 word) ((v2w v'): 124 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 125 = SOME (((get_word_binpred binpred) ((v2w v): 125 word) ((v2w v'): 125 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 126 = SOME (((get_word_binpred binpred) ((v2w v): 126 word) ((v2w v'): 126 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 127 = SOME (((get_word_binpred binpred) ((v2w v): 127 word) ((v2w v'): 127 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' 128 = SOME (((get_word_binpred binpred) ((v2w v): 128 word) ((v2w v'): 128 word)):boolv) )
/\  (bitv_binpred_inner binpred v v' _ = NONE )
`;
val bitv_binpred_def = Define `
  bitv_binpred binpred (v, n) (v', n') =
    if n = n'
    then bitv_binpred_inner binpred v v' n
    else NONE
`;
val bitv_concat_def = Define `
  bitv_concat (v, (n:num)) (v', n') = (v ++ v', n + n')
`;

(* The arguments are v vector, n length of that vector, m is the most significant bit
 * l is the least significant bit. It returns the sliced vector with the length *)
val bitv_bitslice_def = Define `
  bitv_bitslice (v, n) m l = (SEG ( m - l + 1 ) (n - m - 1) v, m - l + 1)
`;

val slice_def = Define `
  slice (v, n) (vec1, len1) (vec2, len2) = bitv_bitslice (v , n) (v2n (vec1)) (v2n (vec2))
`;


(* given an lval being a slicing operation, take only the parts that are required in the slicing *)
val slice_lval_def = Define `
  (slice_lval (v_bit (v, bl)) (e1) (e2) =
     ( case e1 of
     | (e_v (v_bit (v1, bl1))) =>
       ( case e2 of
       | (e_v (v_bit (v2, bl2))) => SOME ( v_bit (slice (v, bl) (v1, bl1) (v2, bl2)) )
       | _ => NONE )
     | _ => NONE
     ))
`;


val is_var_def = Define `
  (is_var (e_var _) = T) /\
  (is_var _ = F)
`;

(* Extracts the string that represents the variable name from the expression form *)
val varname_of_e_def = Define `
  (varname_of_e (e_var varn) = SOME varn) /\
  (varname_of_e _ = NONE)
`;

val v_of_e_def = Define `
  (v_of_e (e_v v) = SOME v) /\
  (v_of_e _ = NONE)
`;


val vl_of_el_def = Define `
  vl_of_el el = MAP (\(e). THE (v_of_e e)) (el)
`;


(* Given a list of expresstions e1...en, find the first expression that is not a constant and return its index. 
*  Returns the index of the expression. 
*  This definition is used in the apply tbl e_list
*)
val index_not_const_def = Define `
  index_not_const elist =
    case INDEX_FIND 0 (\e. ~(is_const e)) elist of
    |SOME (i, e) => SOME i
    |_ => NONE
`;

(* Extracts the index of the topmost scope where the variable name x is mapped in *)
val find_topmost_map_def = Define `
  find_topmost_map (ss:((varn#'a) list) list) (x:varn) =
    case INDEX_FIND 0 (\sc. IS_SOME (ALOOKUP sc x)) (ss) of
    | SOME y => SOME y
    | NONE => NONE
`;


(* Extracts the topmost scope where the variable name x is mapped in *)
val topmost_map_def = Define `
  topmost_map  (ss:((varn#'a) list) list) (x:varn) =
    case find_topmost_map ss x of
    | SOME (i, y) => SOME y
    | _ => NONE
`;


(* Fetches the ('a, string option) tuple of the variable name x, 
in the topmost scope where it is mapped *) 
val lookup_map_def = Define `
  lookup_map  (ss:((varn#'a) list) list) (x:varn) =
    case topmost_map ss x of
    | SOME sc => 
      (case ALOOKUP sc x of
       | SOME y => SOME y
       | _ => NONE)
    | _ => NONE
`;

(* Fetches the value of the variable name x from the topmost scope where it is mapped*)
val lookup_v_def = Define `
  lookup_v (ss:scope list) x =
    case lookup_map ss x of
    | SOME (v, str_opt) => SOME v
    | _ => NONE
`;


(* Fetches the (optional) argument variable name that might have been saved if
 * variable name x was mapped as a result of being an out-parameter in a
 * called function from the topmost scope where x is mapped *)
val lookup_out_def = Define `
  lookup_out (ss:scope list) x =
    case lookup_map ss x of
    | SOME (v, str_opt) => SOME str_opt
    | _ => NONE
`;


val lookup_vexp2_def = Define `
  lookup_vexp2 (ss:scope list) (g_scope_list:scope list) x =
    case lookup_map (ss++g_scope_list) x of
    | SOME (v, str_opt) => SOME v
    | _ => NONE
`;



(* Look up the value of a l-value (variables + fields of struct-valued variables + slice) in
 * a scope stack. 
 * for the slicing operation, e1 and e2 needs to be strictly v bits *)
val lookup_lval_def = Define `
  (lookup_lval (ss:scope list) (lval_varname x) = lookup_v ss x) /\
  (lookup_lval (ss:scope list) (lval_field lval f) =
     case lookup_lval ss lval of
     | SOME v => acc_f v f
     | NONE => NONE) /\
 (lookup_lval (ss:scope list) (lval_slice lval e1 e2) =
    case lookup_lval ss lval of
     | SOME (v_bit (v, bl)) => (slice_lval (v_bit (v, bl)) e1 e2)
     | _ => NONE
     ) /\
 (lookup_lval (ss:scope list) (lval_null) = NONE ) /\
 (lookup_lval (ss:scope list) (lval_paren lval) = lookup_lval ss lval) 

`;

(* TODO: This is ambiguous with regard to inout... *)
val is_d_none_in_def = Define `
  (is_d_none_in d_in = T) /\
  (is_d_none_in d_none = T) /\
  (is_d_none_in _ = F)
`;

val is_d_in_def = Define `
  (is_d_in d_in = T) /\
  (is_d_in d_inout = T) /\
  (is_d_in _ = F)
`;

val is_d_out_def = Define `
  (is_d_out d_inout = T) /\
  (is_d_out d_out = T) /\
  (is_d_out _ = F)
`;


val get_lval_of_e_def = Define `
  (get_lval_of_e (e_var x) = SOME (lval_varname x)) /\
  (get_lval_of_e (e_acc e x) =
   case get_lval_of_e e of
   | SOME lval => SOME (lval_field lval x)
   | NONE => NONE) /\
   (get_lval_of_e (e_slice e ev1 ev2) =
   case get_lval_of_e e of
   | SOME lval => SOME (lval_slice lval ev1 ev2)
   | NONE => NONE) /\
  (get_lval_of_e _ = NONE)
`;

val is_e_lval_def = Define `
  (is_e_lval e =
    case get_lval_of_e e of
    | SOME lval => T
    | NONE => F)
`;


(* Takes an expression list, and returns an option tuple (index, exp) of
 * the first index that has an unreduced expression*)
val unred_mem = Define `
  unred_mem elist  = 
    INDEX_FIND 0 (\(e). ~(is_const e)) (elist) 
`;


(* retrives only the index of the unred_mem definition *)
val unred_mem_index_def = Define `
  unred_mem_index  elist  = 
    case unred_mem  elist of
    | SOME (i, e) => SOME i
    | _ => NONE
`;

(* Checks if function arguments have been appropriately reduced. *)
val is_arg_red_def = Define `
  is_arg_red d e =
   ((~(is_d_out d) ==> is_const e) /\ (is_d_out d ==> is_e_lval e))
`;

(* Obtains the minimum index where an unreduced argument is found:
 * for non-out-directed arguments, if it's not a constant, for
 * out-directed arguments, if it's not a lval *)
val find_unred_arg_def = Define `
  find_unred_arg dlist elist = 
    (INDEX_FIND 0 (\(d, e). ~(is_arg_red d e)) (ZIP (dlist, elist)))
`;
val unred_arg_index_def = Define `
  unred_arg_index dlist elist  = 
    case find_unred_arg dlist elist of
    | SOME (i, de) => SOME i
    | _ => NONE
`;

val check_arg_red_def = Define `
  check_arg_red dlist e i =
    is_arg_red (EL i dlist) e
`;
val check_args_red_def = Define `
  check_args_red dlist elist = EVERY (\(d, e). is_arg_red d e) (ZIP(dlist, elist))
`;

val v_size_def = DB.fetch "p4" "v_size_def";

Theorem v1_size_append:
 !v_l1 v_l2. v1_size (v_l1 ++ v_l2) = (v1_size v_l1 + v1_size v_l2)
Proof
 Induct_on `v_l1` >> (
  fs [v_size_def]
 )
QED

Theorem v1_size_mem:
 !x v t. MEM (x,v) t ==> v_size v < v1_size t
Proof
 REPEAT STRIP_TAC >>
 fs [listTheory.MEM_SPLIT, v1_size_append, v_size_def]
QED

val init_out_v_def = TotalDefn.tDefine "init_out_v" `
  (init_out_v (v_bool boolv) = v_bool ARB) /\
  (init_out_v (v_bit (bl, n)) = v_bit (extend ARB n [], n)) /\
  (init_out_v (v_str x) = v_str ARB) /\
  (init_out_v (v_struct ((x,v)::t)) = v_struct (((x, init_out_v v))::(MAP (\(x',v'). (x', init_out_v v')) t))) /\
  (init_out_v (v_struct []) = v_struct []) /\
  (init_out_v (v_header boolv ((x,v)::t)) =
    v_header F (( (x, init_out_v v) )::(MAP (\(x',v'). (x', init_out_v v')) t))) /\
  (init_out_v (v_header boolv []) = v_header F []) /\
  (init_out_v (v_ext_ref i) = v_ext_ref i) /\
  (init_out_v v_bot = v_bot)
`
(WF_REL_TAC `measure v_size` >>
 fs [v_size_def] >>
 REPEAT STRIP_TAC >>
 `v_size v' < v1_size t` suffices_by (
  fs []
 ) >>
 METIS_TAC [v1_size_mem]
);



val tau_size_def = DB.fetch "p4" "tau_size_def";

Theorem tau1_size_append:
 !l1 l2. tau1_size (l1 ++ l2) = (tau1_size l1 + tau1_size l2)
Proof
 Induct_on `l1` >> (
  fs [tau_size_def]
 )
QED

Theorem tau1_size_mem:
 !x t xtl. MEM (x,t) xtl ==> tau_size t < tau1_size xtl
Proof
 REPEAT STRIP_TAC >>
 fs [listTheory.MEM_SPLIT, tau1_size_append, tau_size_def]
QED

(* generate an undetermined value for a given type *)
val arb_from_tau_def = TotalDefn.tDefine "arb_from_tau" `
  (arb_from_tau tau_bool   = (v_bool ARB))  /\
  (arb_from_tau (tau_bit w)  = (v_bit ( (GENLIST (\x.ARB) w ) , w)))  /\
  (arb_from_tau tau_bot    = v_bot)   /\
  (arb_from_tau tau_ext   = (v_ext_ref ARB)) /\
  (arb_from_tau (tau_xtl struct_ty_struct [] ) =  v_struct [] ) /\ 
  (arb_from_tau (tau_xtl struct_ty_struct ((x0,t0)::xtl) ) =  
   v_struct ((x0,arb_from_tau t0)::(MAP (λ(x,t). (x,arb_from_tau t)) xtl))) /\
  (arb_from_tau (tau_xtl struct_ty_header [] ) =  v_header ARB [] ) /\            
  (arb_from_tau (tau_xtl struct_ty_header ((x0,t0)::xtl)) =
    v_header ARB ((x0,arb_from_tau t0)::(MAP (λ(x,t). (x,arb_from_tau t)) xtl))) 
  `
 (WF_REL_TAC `measure tau_size` >>
 REPEAT STRIP_TAC >>
 FULL_SIMP_TAC std_ss [] >>
 fs [tau_size_def] >>  
 `tau_size t < tau1_size xtl` suffices_by (
  fs [] ) >>  
 IMP_RES_TAC tau1_size_mem);




(* Given a direction, an expression (should be a lval), and a scope stack,
 * creates the proper tuple to be be assigned in the fresh scope created by a function call *)
val one_arg_val_for_newscope_def = Define `
 one_arg_val_for_newscope d e ss =
  if is_d_out d
  then
   (case get_lval_of_e e of
    | SOME lval =>
     (case lookup_lval ss lval of
      | SOME v =>
       if is_d_in d
       then SOME (v, SOME lval)
       else SOME (init_out_v v, SOME lval)
      | NONE => NONE)
    | NONE => NONE)
  else
   (case v_of_e e of
    | SOME v => SOME (v, NONE)
    | NONE => NONE)
`;

Definition AUPDATE_def:
 AUPDATE alist (k,v) =
  case ALOOKUP alist k of
   | SOME _ => AFUPDKEY k (\old_v. v) alist
   | NONE => (alist++[(k,v)])
End

Definition AUPDATE_LIST_def:
 AUPDATE_LIST = FOLDL AUPDATE
End

val update_arg_for_newscope_def = Define `
  update_arg_for_newscope ss f_opt (d, x, e) =
    case f_opt of
    | SOME f =>
      (case one_arg_val_for_newscope d e ss of
       | SOME (v, lval_opt) => SOME (AUPDATE f (varn_name x, (v, lval_opt)))
       | NONE => NONE)
    | NONE => NONE
`;

(* Fills a fresh scope with the values of the arguments of a called function.
 * Note: used in e_call_newframe *)
val all_arg_update_for_newscope_def = Define `
  all_arg_update_for_newscope xlist dlist elist ss = 
    FOLDL (update_arg_for_newscope ss) (SOME []) (ZIP (dlist, ZIP(xlist, elist)))
`;


(* full copyin definition *)
val copyin_def = Define `
  copyin xlist dlist elist gsl ss_curr = 
    all_arg_update_for_newscope xlist dlist elist (ss_curr++gsl)
`;

(* in bl' slice from v2 to v1 and in that section add bl in those positions
   relpace_bits ([F;F;F],3) ([T;T;T;T;T;T],6) 3 1 = [T; T; F; F; F; T]
  *)
val relpace_bits_def = Define `
 relpace_bits (bl,(v:num)) (bl',v') v1 v2 =
  (SEG ((v'-v1)-1) 0 bl') ++ bl ++ (SEG v2 (v'-v2) bl')
`;


     
(* assign to slice returns that value being replaces in a slicing assignment.
   i.e. assign the value bit vb to vb' where vb should replace only the positions from ev2 to ev1 in vb' *)

val  assign_to_slice_def = Define `
assign_to_slice vb vb' ev1 ev2 =
( case ev1 of
     | (e_v (v_bit (bl1, n1))) =>
       (case ev2 of
       | (e_v (v_bit (bl2, n2))) => SOME ( v_bit ((relpace_bits vb vb' (v2n bl1) (v2n bl2)), SND vb')  )
       | _ => NONE )
     | _ => NONE
     )`; 

(* Updates a scope stack by mapping the variable name a to the value v
 * in the topmost scope where a is defined,
 * written as ε[a -> v], colloquially known as assignment.
 * Note that this function is used in the assignment and return rules *)
 (*TODO: fix assignment to include the slicing*)
val assign_def = Define `
  (assign ss v (lval_varname x) =
    case find_topmost_map ss x of
    | SOME (i, sc) =>
      (case lookup_out ss x of
       | SOME str_opt =>
         SOME (LUPDATE (AUPDATE sc (x, (v, str_opt))) (i) ss)
       | NONE => NONE)
    | _ => NONE) /\
  (assign ss v (lval_field lval f) =
    case lookup_lval ss lval of
    | SOME (v_struct f_v_l) =>
      (case INDEX_OF f (MAP FST f_v_l) of
       | SOME i => assign ss (v_struct (LUPDATE (f, v) i f_v_l)) lval
       | NONE => NONE)
    | SOME (v_header validity f_v_l) =>
      (case INDEX_OF f (MAP FST f_v_l) of
       | SOME i => assign ss (v_header validity (LUPDATE (f, v) i f_v_l)) lval
       | NONE => NONE)
    | _ => NONE) /\    
  (assign ss v (lval_slice lval ev1 ev2) =
     case v of
     | v_bit vb => (
           case lookup_lval ss lval of
           | SOME (v_bit vb') =>
               (case assign_to_slice vb vb' ev1 ev2 of
                | SOME v_res => assign ss v_res lval
                | _ => NONE )
           | _ => NONE)
     | _ => NONE ) /\
  (assign ss v lval_null =
    SOME ss
  ) /\ (
  assign ss v (lval_paren lval) = 
    assign ss v lval
  )
`;

val oTAKE_def = Define `
  (oTAKE 0 _ = SOME []) /\
  (oTAKE (SUC n) [] = NONE) /\
  (oTAKE (SUC n) (h::t) =
   case oTAKE n t of
   | SOME l => SOME (h::l)
   | NONE => NONE)
`;

val oDROP_def = Define `
  (oDROP 0 l = SOME l) /\
  (oDROP (SUC n) [] = NONE) /\
  (oDROP (SUC n) (h::t) = oDROP n t)
`;

(* Declares a new variable and initialises it to ARB, returns the new scope stack *)
(* TODO: Behaviour when variable already exists? *)
(* Note that this will declare variables in the block-global scope when scope stack is empty *)
(* TODO: REMOVE IT *)
(*
val declare_def = Define `
  (declare g_scope_list (ss:scope_list) x t =
    case ss of
    | [] => (LUPDATE (AUPDATE (EL 1 g_scope_list) (varn_name x, (arb_from_tau t, NONE))) 1 g_scope_list, [])
    | _ =>
     let i = LENGTH ss - 1 in
     let scope = EL i ss in
     (g_scope_list, LUPDATE (AUPDATE scope (varn_name x, (arb_from_tau t, NONE))) i ss)
  )
`;
*)

(* Initialises a new variable in the topmost scope. *)
val initialise_def = Define `
  (initialise (ss:scope_list) varn v =
    LUPDATE (AUPDATE (LAST ss) (varn, (v, NONE))) (LENGTH ss - 1) ss
  )
`;

(* Initialises parseError in a scope. *)
(* NOTE: NoError serialised to 0 *)
val initialise_parse_error_def = Define `
  (initialise_parse_error (scope:scope) =
    AUPDATE scope (varn_name "parseError", (v_bit (fixwidth 32 (n2v 0),32), NONE))
  )
`;

(* Obtains the varn_star updates of a function map *)
val var_star_updates_of_func_map_def = Define `
  (var_star_updates_of_func_map (func_map:func_map) =
   let varnames = (MAP FST func_map) in
   MAP ( \x. (varn_star (funn_name x), (v_bot, (NONE:lval option)))) varnames
  )
`;

(* Obtains the varn_star updates of an extern map *)
val var_star_updates_of_ext_map_def = Define `
 (var_star_updates_of_ext_map ([]:'a ext_map) = []) /\
 (var_star_updates_of_ext_map (((ext_obj_name, ext_obj_funs)::t):'a ext_map) =
  case ext_obj_funs of
  | (SOME _, ext_fun_map) =>
   ((varn_star (funn_inst ext_obj_name), (v_bot, (NONE:lval option)))::(MAP ( \x. (varn_star (funn_ext ext_obj_name x), (v_bot, (NONE:lval option)))) (MAP FST ext_fun_map)))++(var_star_updates_of_ext_map t)
  | (NONE, ext_fun_map) =>
   MAP ( \x. (varn_star (funn_ext ext_obj_name x), (v_bot, (NONE:lval option)))) (MAP FST ext_fun_map)++(var_star_updates_of_ext_map t)
 )
`;

(* Initialises varn_star variables in function maps *)
val initialise_var_stars_def = Define `
  (initialise_var_stars func_map b_func_map ext_map g_scope_list =
   case g_scope_list of
   | [bg_scope; gg_scope] =>
    SOME ([AUPDATE_LIST bg_scope (var_star_updates_of_func_map b_func_map); AUPDATE_LIST gg_scope ((var_star_updates_of_func_map func_map)++(var_star_updates_of_ext_map ext_map))])
   | _ => NONE
  )
`;

(* Takes a list of declaration tuples (x, t) and a scope, and returns a scope
 * where the declarations have been made *)
val declare_list_in_scope_def = Define `
  declare_list_in_scope (t_scope:t_scope, scope:scope) =
    FOLDR (\(x,(t,lvalop) ) f. AUPDATE f (x , (arb_from_tau t, NONE))) (scope:scope) t_scope
`;

(* Same as the above, but with the empty scope
   NOTE: the lvalop here is always none when entering a new block *)
val declare_list_in_fresh_scope_def = Define `
  declare_list_in_fresh_scope (t_scope:t_scope) =
    (MAP (\(x,(t,lvalop)). (x , (arb_from_tau t, NONE))) t_scope)
`;

(* Looks up the function signature and body for an abstract function name. *)
val lookup_funn_sig_body_def = Define `
  (lookup_funn_sig_body (funn:funn) (func_map:func_map) (b_func_map:b_func_map) (ext_map:'a ext_map) =
    case funn of
    | (funn_name x) =>
     (case ALOOKUP b_func_map x of
      | SOME (stmt, x_d_l) => SOME (stmt, x_d_l)
      | NONE =>
       (case ALOOKUP func_map x of
        | SOME (stmt, x_d_l) => SOME (stmt, x_d_l)
        | NONE => NONE
       )
     )
    | (funn_inst x) =>
     (case ALOOKUP ext_map x of
      | SOME (SOME (x_d_l, _), _) => SOME (stmt_ext, x_d_l)
      | _ => NONE)
    | (funn_ext x x') =>
     (case ALOOKUP ext_map x of
      | SOME (_, ext_fun_map) =>
       (case ALOOKUP ext_fun_map x' of
	      | SOME (x_d_l, _) => SOME (stmt_ext, x_d_l)
	      | _ => NONE)
      | _ => NONE)
  )
`;

val lookup_funn_sig_def = Define `
  (lookup_funn_sig funn func_map b_func_map ext_map =
    case lookup_funn_sig_body funn func_map b_func_map ext_map of
    | SOME (_, x_d_l) => SOME x_d_l
    | NONE => NONE
  )
`;

(* TODO: Need a separate definition for this? *)
val lookup_block_body_def = Define `
 lookup_block_body f b_func_map =
  case ALOOKUP b_func_map f of
  | SOME res => SOME $ FST res
  | NONE => NONE
`;

(* Given lists of variable names and directions, a caller's scope stack ss
 * and a callees scope_stack ss_curr, updates the caller's scope stack
 * according to the calling conventions. *)
val update_return_frame_def = Define `
  update_return_frame xlist dlist ss ss_curr = 
    FOLDL
      (\ss_temp_opt (x,d).
        if (is_d_none_in d)
        then ss_temp_opt
        else
          case ss_temp_opt of
          | SOME ss_temp =>
           (case lookup_map ss_curr (varn_name x) of
            | SOME (v, str_opt) =>
              (case str_opt of
               | SOME str => assign ss_temp v str
               | NONE => NONE)
            | _ => NONE)
          | NONE => NONE
      )
      (SOME ss)
      (ZIP(xlist, dlist))
`;

(*
val args_of_pbl_def = Define `
  args_of_pbl (pbl_type, x_d_list, b_func_map, t_scope, pars_map, tbl_map) = x_d_list
`;
*)

(* Implements the whole copyout operation to the caller scope stack. Given list of arguments
 * of the funtion i.e. names and directions, global scope list, caller scope stack and current
 * scope stack, it will return a tuple where first element is a global scope list updated with
 * the copy-outs, and the second element is the caller's scope updated with the copy-outs *)

val copyout_def = Define `
  copyout xlist dlist gsl ss ss_curr =
    case update_return_frame xlist dlist (ss++gsl) [LAST ss_curr] of
    |(SOME updated_return_ss =>
      case (LENGTH updated_return_ss) of
      | 0 => NONE
      | i => SOME (THE (oDROP (i-2) updated_return_ss), THE(oTAKE (i-2) updated_return_ss)))
    | NONE => NONE
`;

(* TODO: Handle partiality earlier and let it result in NONE instead of just F
 *       or being undefined. Since things are being evaluated all the time, we ideally want
 *       this to not evaluate unnecessarily - not trivial since this function is being held
 *       in the state *)
Definition p4_match_mask_def:
 p4_match_mask val mask k =
  (case k of
   | v_bit (v', n') =>
    (case bitv_binop binop_and (v', n') mask of
     | SOME res =>
      (case bitv_binop binop_and val mask of
       | SOME res' => 
        (case bitv_binpred binop_eq res res' of
         | SOME bool => bool
         | NONE => F)
       | NONE => F)
     | NONE => F)
   | _ => F)
End

Definition p4_match_range_def:
 p4_match_range lo hi k =
  case k of
   | v_bit (v', n') =>
    (case bitv_binpred binop_ge (v', n') lo of
     | SOME T =>
      (case bitv_binpred binop_le (v', n') hi of
       | SOME T => T
       | _ => F)
     | _ => F)
   | _ => F
End

Definition match_def:
 match v s =
  case s of
  | s_sing v' => (v = v')
  | s_range bitv bitv' => p4_match_range bitv bitv' v
  | s_mask bitv bitv' => p4_match_mask bitv bitv' v
  | s_univ => T
End

Definition match_all_def:
 (match_all [] = T) /\
 (match_all ((h, h')::t) =
   if match h h'
   then match_all t
   else F)
End

(* TODO: Hack *)
Definition match_all_e_def:
 match_all_e e_l s_l = match_all (ZIP(vl_of_el e_l, s_l))
End

val sel_def = Define `
 sel v (s_list_x_list) x =
  case v of
  | v_struct x_v_list =>
   (case (FIND (\(s_list, x'). match_all (ZIP(SND $ UNZIP x_v_list,s_list))) s_list_x_list) of
    | SOME (s_list, x') => x'
    | NONE => x)
  | _ => x
`;

val fully_reduced_def = Define `
  fully_reduced e =
    case e of
    | (e_v (v_str _)) => T
    | _ => F
`;

val state_fin_def = Define `
 state_fin status frame_list =
  ((status = status_trans "accept") \/
   (status = status_trans "reject") \/
   (?v. status = status_returnv v) \/
   (?funn scope_list. frame_list = [(funn, [stmt_empty], scope_list)] /\
    ((?state_name. status = status_trans state_name) ==>
     ((status = status_trans "accept") \/
      (status = status_trans "reject"))))
  )
`;

val set_fin_status_def = Define `
  set_fin_status pbl_type status =
    case pbl_type of
    | pbl_type_parser =>
     (case status of
      | status_running => (status_trans "reject")
      | _ => status)
    | pbl_type_control => status
`;

val not_top_return_def = Define `
  not_top_return frame_list =
    case frame_list of
    | [(funn, stmt, scope_list)] =>
      (case stmt of
      | stmt_ret e => T
      | stmt_seq (stmt_ret e) _ => T
      | _ => F)
    | _ => F
`;

(* check if the status is not a return *)
val notret_def = Define `
  (notret (status_returnv v) = F) /\
  (notret _ = T)
`;

(* check if the operation is short-circuitable. Needed to prevent non-determinism *)
val is_short_circuitable_def = Define `
  (is_short_circuitable binop_bin_and = T) /\
  (is_short_circuitable binop_bin_or = T) /\
  (is_short_circuitable _ = F)
`;



(* Init the variable name star in the topmost scope and return only the scope *)
val decl_init_star_def = Define `
  decl_init_star scope_list v (varn_star funn) =
    AUPDATE (HD scope_list) ((varn_star funn), (v , NONE))
`;

(* TODO: Use initialise_def? *)
(* Init the variable name star in the topmost scope and return the updated scope stack *)
val init_in_highest_scope_def = Define `
  init_in_highest_scope scope_list v (varn_star funn) =
    LUPDATE (decl_init_star scope_list v (varn_star funn)) 0 scope_list
`;

(* Separate a joined scope stack into its two components:
 * 2 global scopes, the rest local scopes *)
val separate_def = Define `
  separate scope_list =
    let i = (LENGTH scope_list) in
    (oDROP (i-2) scope_list, oTAKE (i-2) scope_list)
`;

val parser_not_finished_def = Define `
  (parser_not_finished [ ( funn , [empty_stmt] , scope_list ) ] = F) /\
  (parser_not_finished _ = T)
`;

val lookup_ext_fun_def = Define `
  (lookup_ext_fun (funn_ext f f') (ext_map:'a ext_map) =
   case ALOOKUP ext_map f of
   | SOME (_, ext_fun_map) =>
    (case ALOOKUP ext_fun_map f' of
     | SOME (_, ext_fun) => SOME ext_fun
     | NONE => NONE)
   | NONE => NONE) /\
  (lookup_ext_fun (funn_inst f) ext_map =
   case ALOOKUP ext_map f of
   | SOME (SOME (_, ext_fun), _) => SOME ext_fun
   | _ => NONE) /\
  (lookup_ext_fun (funn_name f) ext_map = NONE)
`;


(* Passes different global scope lists based on where the function funn is defined.
   If funn is global, then the function will return only the global scope,
   else both the global and block scopes will be returned.
   Note that only functions of the shape "funn_name x" can be declared in blocks. *)
val scopes_to_pass_def = Define `
 scopes_to_pass (funn:funn) (func_map_g:func_map) (b_func_map:b_func_map) (g_scope_list:g_scope_list) =
  case funn of
   | (funn_name x) =>
    (case ALOOKUP b_func_map x of
     | SOME (stmt, x_d_l) => SOME g_scope_list
     | NONE =>
      (case ALOOKUP func_map_g x of
       | SOME (stmt, x_d_l) => SOME ([ []; EL 1 g_scope_list])
        (* If x is not found in b_func_map or func_map_g we must be at
         * base level without having called any function *)
        (* TODO: Should this be a special funn? "funn_base" or something? *)
       | NONE => SOME g_scope_list
      )
    )
   | _ => SOME ([ []; EL 1 g_scope_list])
`;

(* Retrieves the global and block scopes based on where the function funn is defined.
   If funn is defined in the programmable block, then retrieve the regular global scope list.
   Otherwise, if the funn is defined globally then retrieve a regular global scope followed by the
   original block scope: [new_global_scope [0] ; old_block_scope[1] *)
val scopes_to_retrieve_def = Define `
 scopes_to_retrieve (funn:funn) (func_map_g:func_map) (b_func_map:b_func_map) (g_scope_list_og:g_scope_list) (g_scope_list:g_scope_list) =
  case funn of
   | (funn_name x) =>
    (case ALOOKUP b_func_map x of
     | SOME (stmt, x_d_l) => SOME g_scope_list
     | NONE =>
      (case ALOOKUP func_map_g x of
       | SOME (stmt, x_d_l) => SOME ([EL 0 g_scope_list_og; EL 1 g_scope_list])
        (* Base level: g_scope_list started out same as g_scope_list_og, but might have been modified *)
       | NONE => SOME g_scope_list
      )
    )
   | _ => SOME ([EL 0 g_scope_list_og; EL 1 g_scope_list])
`;



(* if the function is defined locally, then the map of the locals will be passed 
   else it should be empty, because functions defined globally or extern should not be calling locals *)

val map_to_pass_def = Define `
 map_to_pass (funn:funn) (b_func_map:b_func_map) =
  case funn of
   | (funn_name x) =>
    (case ALOOKUP b_func_map x of
     | SOME (stmt, x_d_l) => SOME b_func_map
     | NONE => SOME []
    )
   | _ => SOME []
`;


val tbl_to_pass_def = Define `
 tbl_to_pass (funn:funn) (b_func_map:b_func_map) (tbl_map:tbl_map) = 
  case funn of
   | (funn_name x) =>
    (case ALOOKUP b_func_map x of
     | SOME (stmt, x_d_l) => SOME tbl_map
     | NONE => SOME []
    )
   | _ => SOME []
`;



(** definitions *)

(* defns e_sem *)
Inductive e_sem:
(* defn e_red *)

[e_lookup:] (! (ctx:'a ctx) (g_scope_list:g_scope_list) (scope_list:scope_list) (varn:varn) (v:v) .
(clause_name "e_lookup") /\
(( SOME  v  =  lookup_vexp2  scope_list   g_scope_list   varn ))
 ==> 
( ( e_red ctx g_scope_list scope_list (e_var varn) (e_v v)  ([]:frame list)  )))

[e_call_newframe:] (! (e_x_d_list:(e#x#d) list) (apply_table_f:'a apply_table_f) (ext_map:'a ext_map) (func_map:func_map) (b_func_map:b_func_map) (pars_map:pars_map) (tbl_map:tbl_map) (g_scope_list:g_scope_list) (scope_list:scope_list) (funn:funn) (stmt:stmt) (scope':scope) .
(clause_name "e_call_newframe") /\
(( (SOME ( stmt ,  ((MAP (\(e_,x_,d_) . (x_,d_)) e_x_d_list)) ) = lookup_funn_sig_body  funn   func_map   b_func_map   ext_map ) ) /\
( (check_args_red   ( ((MAP (\(e_,x_,d_) . d_) e_x_d_list)) )     ( ((MAP (\(e_,x_,d_) . e_) e_x_d_list)) )  ) ) /\
( (SOME  scope'  = copyin  ((MAP (\(e_,x_,d_) . x_) e_x_d_list))    ( ((MAP (\(e_,x_,d_) . d_) e_x_d_list)) )     ( ((MAP (\(e_,x_,d_) . e_) e_x_d_list)) )    g_scope_list   scope_list ) ))
 ==> 
( ( e_red  ( apply_table_f ,  ext_map ,  func_map ,  b_func_map  ,  pars_map ,  tbl_map )  g_scope_list scope_list (e_call funn ((MAP (\(e_,x_,d_) . e_) e_x_d_list))) (e_var (varn_star funn))  ([   ( funn  ,   ( ([(stmt)]) )   ,   ( ([(scope')]) )  )   ])  )))

[e_call_args:] (! (e_e'_x_d_list:(e#e#x#d) list) (apply_table_f:'a apply_table_f) (ext_map:'a ext_map) (func_map:func_map) (b_func_map:b_func_map) (pars_map:pars_map) (tbl_map:tbl_map) (g_scope_list:g_scope_list) (scope_list:scope_list) (funn:funn) (frame_list:frame_list) (i:i) (e:e) (e':e) .
(clause_name "e_call_args") /\
(( (SOME  ((MAP (\(e_,e'_,x_,d_) . (x_,d_)) e_e'_x_d_list))  = lookup_funn_sig  funn   func_map   b_func_map   ext_map ) ) /\
( (unred_arg_index   ( ((MAP (\(e_,e'_,x_,d_) . d_) e_e'_x_d_list)) )     ( ((MAP (\(e_,e'_,x_,d_) . e_) e_e'_x_d_list)) )   = SOME  i ) ) /\
( ( e  = EL  i    ( ((MAP (\(e_,e'_,x_,d_) . e_) e_e'_x_d_list)) )  ) ) /\
( ( e_red  ( apply_table_f ,  ext_map ,  func_map ,  b_func_map  ,  pars_map ,  tbl_map )  g_scope_list scope_list e e' frame_list )) /\
( (  ( ((MAP (\(e_,e'_,x_,d_) . e'_) e_e'_x_d_list)) )   =   (LUPDATE  e'   i    ( ((MAP (\(e_,e'_,x_,d_) . e_) e_e'_x_d_list)) )  )  ) ))
 ==> 
( ( e_red  ( apply_table_f ,  ext_map ,  func_map ,  b_func_map  ,  pars_map ,  tbl_map )  g_scope_list scope_list (e_call funn ((MAP (\(e_,e'_,x_,d_) . e_) e_e'_x_d_list))) (e_call funn ((MAP (\(e_,e'_,x_,d_) . e'_) e_e'_x_d_list))) frame_list )))

[e_eStruct:] (! (f_e_e'_list:(x#e#e) list) (ctx:'a ctx) (g_scope_list:g_scope_list) (scope_list:scope_list) (frame_list:frame_list) (i:i) (e:e) (e':e) .
(clause_name "e_eStruct") /\
(( (unred_mem_index   ( ((MAP (\(f_,e_,e'_) . e_) f_e_e'_list)) )   = SOME  i ) ) /\
( ( e  = EL  i    ( ((MAP (\(f_,e_,e'_) . e_) f_e_e'_list)) )  ) ) /\
( ( e_red ctx g_scope_list scope_list e e' frame_list )) /\
( (  ( ((MAP (\(f_,e_,e'_) . e'_) f_e_e'_list)) )   =   (LUPDATE  e'   i    ( ((MAP (\(f_,e_,e'_) . e_) f_e_e'_list)) )  )  ) ))
 ==> 
( ( e_red ctx g_scope_list scope_list (e_struct ((MAP (\(f_,e_,e'_) . (f_,e_)) f_e_e'_list))) (e_struct ((MAP (\(f_,e_,e'_) . (f_,e'_)) f_e_e'_list))) frame_list )))

[e_eStruct_to_v:] (! (f_e_v_list:(x#e#v) list) (ctx:'a ctx) (g_scope_list:g_scope_list) (scope_list:scope_list) .
(clause_name "e_eStruct_to_v") /\
(( (is_consts   ( ((MAP (\(f_,e_,v_) . e_) f_e_v_list)) )  ) ) /\
( (  ( ((MAP (\(f_,e_,v_) . v_) f_e_v_list)) )   = vl_of_el   ( ((MAP (\(f_,e_,v_) . e_) f_e_v_list)) )  ) ))
 ==> 
( ( e_red ctx g_scope_list scope_list (e_struct ((MAP (\(f_,e_,v_) . (f_,e_)) f_e_v_list))) (e_v (v_struct ((MAP (\(f_,e_,v_) . (f_,v_)) f_e_v_list))))  ([]:frame list)  )))

[e_s_acc:] (! (f_v_list:(x#v) list) (ctx:'a ctx) (g_scope_list:g_scope_list) (scope_list:scope_list) (f:x) (v:v) .
(clause_name "e_s_acc") /\
(( (FIND (\(k, v). k =  f )  (f_v_list)  = SOME ( f ,  v )) ))
 ==> 
( ( e_red ctx g_scope_list scope_list (e_acc (e_v (v_struct (f_v_list))) f) (e_v v)  ([]:frame list)  )))

[e_acc_arg1:] (! (ctx:'a ctx) (g_scope_list:g_scope_list) (scope_list:scope_list) (e:e) (f:x) (e':e) (frame_list:frame_list) .
(clause_name "e_acc_arg1") /\
(( ( e_red ctx g_scope_list scope_list e e' frame_list )))
 ==> 
( ( e_red ctx g_scope_list scope_list (e_acc e f) (e_acc e' f) frame_list )))

[e_eHeader:] (! (f_e_e'_list:(x#e#e) list) (ctx:'a ctx) (g_scope_list:g_scope_list) (scope_list:scope_list) (boolv:boolv) (frame_list:frame_list) (i:i) (e:e) (e':e) .
(clause_name "e_eHeader") /\
(( (unred_mem_index   ( ((MAP (\(f_,e_,e'_) . e_) f_e_e'_list)) )   = SOME  i ) ) /\
( ( e  = EL  i    ( ((MAP (\(f_,e_,e'_) . e_) f_e_e'_list)) )  ) ) /\
( ( e_red ctx g_scope_list scope_list e e' frame_list )) /\
( (  ( ((MAP (\(f_,e_,e'_) . e'_) f_e_e'_list)) )   =   (LUPDATE  e'   i    ( ((MAP (\(f_,e_,e'_) . e_) f_e_e'_list)) )  )  ) ))
 ==> 
( ( e_red ctx g_scope_list scope_list (e_header boolv ((MAP (\(f_,e_,e'_) . (f_,e_)) f_e_e'_list))) (e_header boolv ((MAP (\(f_,e_,e'_) . (f_,e'_)) f_e_e'_list))) frame_list )))

[e_eHeader_to_v:] (! (f_e_v_list:(x#e#v) list) (ctx:'a ctx) (g_scope_list:g_scope_list) (scope_list:scope_list) (boolv:boolv) .
(clause_name "e_eHeader_to_v") /\
(( (is_consts   ( ((MAP (\(f_,e_,v_) . e_) f_e_v_list)) )  ) ) /\
( (  ( ((MAP (\(f_,e_,v_) . v_) f_e_v_list)) )   = vl_of_el   ( ((MAP (\(f_,e_,v_) . e_) f_e_v_list)) )  ) ))
 ==> 
( ( e_red ctx g_scope_list scope_list (e_header boolv ((MAP (\(f_,e_,v_) . (f_,e_)) f_e_v_list))) (e_v (v_header boolv ((MAP (\(f_,e_,v_) . (f_,v_)) f_e_v_list))))  ([]:frame list)  )))

[e_h_acc:] (! (f_v_list:(x#v) list) (ctx:'a ctx) (g_scope_list:g_scope_list) (scope_list:scope_list) (boolv:boolv) (f:x) (v:v) .
(clause_name "e_h_acc") /\
(( (FIND (\(k, v). k =  f )  (f_v_list)  = SOME ( f ,  v )) ))
 ==> 
( ( e_red ctx g_scope_list scope_list (e_acc (e_v (v_header boolv (f_v_list))) f) (e_v v)  ([]:frame list)  )))

[e_sel_acc:] (! (s_list_x_list:(s_list#x) list) (ctx:'a ctx) (g_scope_list:g_scope_list) (scope_list:scope_list) (v:v) (x:x) (x':x) .
(clause_name "e_sel_acc") /\
(( x'  = sel  v   (s_list_x_list)   x ))
 ==> 
( ( e_red ctx g_scope_list scope_list (e_select (e_v v) (s_list_x_list) x) (e_v (v_str x'))  ([]:frame list)  )))

[e_concat_arg1:] (! (ctx:'a ctx) (g_scope_list:g_scope_list) (scope_list:scope_list) (e:e) (e':e) (e'':e) (frame_list:frame_list) .
(clause_name "e_concat_arg1") /\
(( ( e_red ctx g_scope_list scope_list e e'' frame_list )))
 ==> 
( ( e_red ctx g_scope_list scope_list (e_concat e e') (e_concat e'' e') frame_list )))

[e_concat_arg2:] (! (ctx:'a ctx) (g_scope_list:g_scope_list) (scope_list:scope_list) (bitv:bitv) (e:e) (e':e) (frame_list:frame_list) .
(clause_name "e_concat_arg2") /\
(( ( e_red ctx g_scope_list scope_list e e' frame_list )))
 ==> 
( ( e_red ctx g_scope_list scope_list (e_concat (e_v (v_bit bitv)) e) (e_concat (e_v (v_bit bitv)) e') frame_list )))

[e_concat_v:] (! (ctx:'a ctx) (g_scope_list:g_scope_list) (scope_list:scope_list) (bitv:bitv) (bitv':bitv) (bitv'':bitv) .
(clause_name "e_concat_v") /\
(( ( bitv''  = bitv_concat  bitv   bitv' ) ))
 ==> 
( ( e_red ctx g_scope_list scope_list (e_concat (e_v (v_bit bitv)) (e_v (v_bit bitv'))) (e_v (v_bit bitv''))  ([]:frame list)  )))

[e_slice_arg1:] (! (ctx:'a ctx) (g_scope_list:g_scope_list) (scope_list:scope_list) (e:e) (bitv:bitv) (bitv':bitv) (e':e) (frame_list:frame_list) .
(clause_name "e_slice_arg1") /\
(( ( e_red ctx g_scope_list scope_list e e' frame_list )))
 ==> 
( ( e_red ctx g_scope_list scope_list (e_slice e (e_v (v_bit bitv)) (e_v (v_bit bitv'))) (e_slice e' (e_v (v_bit bitv)) (e_v (v_bit bitv'))) frame_list )))

[e_slice_v:] (! (ctx:'a ctx) (g_scope_list:g_scope_list) (scope_list:scope_list) (bitv:bitv) (bitv':bitv) (bitv'':bitv) (bitv''':bitv) .
(clause_name "e_slice_v") /\
(( bitv'''  = slice  bitv   bitv'   bitv'' ))
 ==> 
( ( e_red ctx g_scope_list scope_list (e_slice (e_v (v_bit bitv)) (e_v (v_bit bitv')) (e_v (v_bit bitv''))) (e_v (v_bit bitv'''))  ([]:frame list)  )))

[e_sel_arg:] (! (s_list_x_list:(s_list#x) list) (ctx:'a ctx) (g_scope_list:g_scope_list) (scope_list:scope_list) (e:e) (x:x) (e':e) (frame_list:frame_list) .
(clause_name "e_sel_arg") /\
(( ( e_red ctx g_scope_list scope_list e e' frame_list )))
 ==> 
( ( e_red ctx g_scope_list scope_list (e_select e (s_list_x_list) x) (e_select e' (s_list_x_list) x) frame_list )))

[e_unop_arg:] (! (ctx:'a ctx) (g_scope_list:g_scope_list) (scope_list:scope_list) (unop:unop) (e:e) (e':e) (frame_list:frame_list) .
(clause_name "e_unop_arg") /\
(( ( e_red ctx g_scope_list scope_list e e' frame_list )))
 ==> 
( ( e_red ctx g_scope_list scope_list (e_unop unop e) (e_unop unop e') frame_list )))

[e_cast_arg:] (! (ctx:'a ctx) (g_scope_list:g_scope_list) (scope_list:scope_list) (cast:cast) (e:e) (e':e) (frame_list:frame_list) .
(clause_name "e_cast_arg") /\
(( ( e_red ctx g_scope_list scope_list e e' frame_list )))
 ==> 
( ( e_red ctx g_scope_list scope_list (e_cast cast e) (e_cast cast e') frame_list )))

[e_binop_arg1:] (! (ctx:'a ctx) (g_scope_list:g_scope_list) (scope_list:scope_list) (e:e) (binop:binop) (e':e) (e'':e) (frame_list:frame_list) .
(clause_name "e_binop_arg1") /\
(( ( e_red ctx g_scope_list scope_list e e'' frame_list )))
 ==> 
( ( e_red ctx g_scope_list scope_list (e_binop e binop e') (e_binop e'' binop e') frame_list )))

[e_binop_arg2:] (! (ctx:'a ctx) (g_scope_list:g_scope_list) (scope_list:scope_list) (v:v) (binop:binop) (e:e) (e':e) (frame_list:frame_list) .
(clause_name "e_binop_arg2") /\
(( (~is_short_circuitable  binop ) ) /\
( ( e_red ctx g_scope_list scope_list e e' frame_list )))
 ==> 
( ( e_red ctx g_scope_list scope_list (e_binop (e_v v) binop e) (e_binop (e_v v) binop e') frame_list )))

[e_neg_bool:] (! (ctx:'a ctx) (g_scope_list:g_scope_list) (scope_list:scope_list) (b:b) (b':b) .
(clause_name "e_neg_bool") /\
(( (~ b  =  b' ) ))
 ==> 
( ( e_red ctx g_scope_list scope_list (e_unop unop_neg (e_v (v_bool  b ))) (e_v (v_bool  b' ))  ([]:frame list)  )))

[e_compl:] (! (ctx:'a ctx) (g_scope_list:g_scope_list) (scope_list:scope_list) (bitv:bitv) (bitv':bitv) .
(clause_name "e_compl") /\
(( (bitv_bl_unop bnot  bitv  =  bitv' ) ))
 ==> 
( ( e_red ctx g_scope_list scope_list (e_unop unop_compl (e_v (v_bit bitv))) (e_v (v_bit bitv'))  ([]:frame list)  )))

[e_neg_signed:] (! (ctx:'a ctx) (g_scope_list:g_scope_list) (scope_list:scope_list) (bitv:bitv) (bitv':bitv) .
(clause_name "e_neg_signed") /\
(( (bitv_unop unop_neg_signed  bitv  =  bitv' ) ))
 ==> 
( ( e_red ctx g_scope_list scope_list (e_unop unop_neg_signed (e_v (v_bit bitv))) (e_v (v_bit bitv'))  ([]:frame list)  )))

[e_un_plus:] (! (ctx:'a ctx) (g_scope_list:g_scope_list) (scope_list:scope_list) (bitv:bitv) (bitv':bitv) .
(clause_name "e_un_plus") /\
(( ( bitv  =  bitv' ) ))
 ==> 
( ( e_red ctx g_scope_list scope_list (e_unop unop_un_plus (e_v (v_bit bitv))) (e_v (v_bit bitv'))  ([]:frame list)  )))

[e_cast_bitv:] (! (ctx:'a ctx) (g_scope_list:g_scope_list) (scope_list:scope_list) (n:m) (bitv:bitv) (bitv':bitv) .
(clause_name "e_cast_bitv") /\
(( (bitv_cast  n   bitv  =  bitv' ) ))
 ==> 
( ( e_red ctx g_scope_list scope_list (e_cast (cast_unsigned n) (e_v (v_bit bitv))) (e_v (v_bit bitv'))  ([]:frame list)  )))

[e_cast_bool:] (! (ctx:'a ctx) (g_scope_list:g_scope_list) (scope_list:scope_list) (n:m) (b:b) (bitv:bitv) .
(clause_name "e_cast_bool") /\
(( (bool_cast  n   b  =  bitv ) ))
 ==> 
( ( e_red ctx g_scope_list scope_list (e_cast (cast_unsigned n) (e_v (v_bool  b ))) (e_v (v_bit bitv))  ([]:frame list)  )))

[e_mul:] (! (ctx:'a ctx) (g_scope_list:g_scope_list) (scope_list:scope_list) (bitv:bitv) (bitv':bitv) (bitv'':bitv) .
(clause_name "e_mul") /\
(( (bitv_binop binop_mul  bitv   bitv'  = SOME  bitv'' ) ))
 ==> 
( ( e_red ctx g_scope_list scope_list (e_binop (e_v (v_bit bitv)) binop_mul (e_v (v_bit bitv'))) (e_v (v_bit bitv''))  ([]:frame list)  )))

[e_div:] (! (ctx:'a ctx) (g_scope_list:g_scope_list) (scope_list:scope_list) (bitv:bitv) (bitv':bitv) (bitv'':bitv) .
(clause_name "e_div") /\
(( (bitv_binop binop_div  bitv   bitv'  = SOME  bitv'' ) ))
 ==> 
( ( e_red ctx g_scope_list scope_list (e_binop (e_v (v_bit bitv)) binop_div (e_v (v_bit bitv'))) (e_v (v_bit bitv''))  ([]:frame list)  )))

[e_mod:] (! (ctx:'a ctx) (g_scope_list:g_scope_list) (scope_list:scope_list) (bitv:bitv) (bitv':bitv) (bitv'':bitv) .
(clause_name "e_mod") /\
(( (bitv_binop binop_mod  bitv   bitv'  = SOME  bitv'' ) ))
 ==> 
( ( e_red ctx g_scope_list scope_list (e_binop (e_v (v_bit bitv)) binop_mod (e_v (v_bit bitv'))) (e_v (v_bit bitv''))  ([]:frame list)  )))

[e_add:] (! (ctx:'a ctx) (g_scope_list:g_scope_list) (scope_list:scope_list) (bitv:bitv) (bitv':bitv) (bitv'':bitv) .
(clause_name "e_add") /\
(( (bitv_binop binop_add  bitv   bitv'  = SOME  bitv'' ) ))
 ==> 
( ( e_red ctx g_scope_list scope_list (e_binop (e_v (v_bit bitv)) binop_add (e_v (v_bit bitv'))) (e_v (v_bit bitv''))  ([]:frame list)  )))

[e_sat_add:] (! (ctx:'a ctx) (g_scope_list:g_scope_list) (scope_list:scope_list) (bitv:bitv) (bitv':bitv) (bitv'':bitv) .
(clause_name "e_sat_add") /\
(( (bitv_binop binop_sat_add  bitv   bitv'  = SOME  bitv'' ) ))
 ==> 
( ( e_red ctx g_scope_list scope_list (e_binop (e_v (v_bit bitv)) binop_sat_add (e_v (v_bit bitv'))) (e_v (v_bit bitv''))  ([]:frame list)  )))

[e_sub:] (! (ctx:'a ctx) (g_scope_list:g_scope_list) (scope_list:scope_list) (bitv:bitv) (bitv':bitv) (bitv'':bitv) .
(clause_name "e_sub") /\
(( (bitv_binop binop_sub  bitv   bitv'  = SOME  bitv'' ) ))
 ==> 
( ( e_red ctx g_scope_list scope_list (e_binop (e_v (v_bit bitv)) binop_sub (e_v (v_bit bitv'))) (e_v (v_bit bitv''))  ([]:frame list)  )))

[e_sat_sub:] (! (ctx:'a ctx) (g_scope_list:g_scope_list) (scope_list:scope_list) (bitv:bitv) (bitv':bitv) (bitv'':bitv) .
(clause_name "e_sat_sub") /\
(( (bitv_binop binop_sat_sub  bitv   bitv'  = SOME  bitv'' ) ))
 ==> 
( ( e_red ctx g_scope_list scope_list (e_binop (e_v (v_bit bitv)) binop_sat_sub (e_v (v_bit bitv'))) (e_v (v_bit bitv''))  ([]:frame list)  )))

[e_shl:] (! (ctx:'a ctx) (g_scope_list:g_scope_list) (scope_list:scope_list) (bitv:bitv) (bitv':bitv) (bitv'':bitv) .
(clause_name "e_shl") /\
(( (bitv_bl_binop shiftl  bitv  ((\(bl, n). (v2n bl, n))  bitv' ) =  bitv'' ) ))
 ==> 
( ( e_red ctx g_scope_list scope_list (e_binop (e_v (v_bit bitv)) binop_shl (e_v (v_bit bitv'))) (e_v (v_bit bitv''))  ([]:frame list)  )))

[e_shr:] (! (ctx:'a ctx) (g_scope_list:g_scope_list) (scope_list:scope_list) (bitv:bitv) (bitv':bitv) (bitv'':bitv) .
(clause_name "e_shr") /\
(( (bitv_bl_binop shiftr  bitv  ((\(bl, n). (v2n bl, n))  bitv' ) =  bitv'' ) ))
 ==> 
( ( e_red ctx g_scope_list scope_list (e_binop (e_v (v_bit bitv)) binop_shr (e_v (v_bit bitv'))) (e_v (v_bit bitv''))  ([]:frame list)  )))

[e_le:] (! (ctx:'a ctx) (g_scope_list:g_scope_list) (scope_list:scope_list) (bitv:bitv) (bitv':bitv) (b:b) .
(clause_name "e_le") /\
(( ((bitv_binpred binop_le  bitv   bitv' ) = SOME  b ) ))
 ==> 
( ( e_red ctx g_scope_list scope_list (e_binop (e_v (v_bit bitv)) binop_le (e_v (v_bit bitv'))) (e_v (v_bool  b ))  ([]:frame list)  )))

[e_ge:] (! (ctx:'a ctx) (g_scope_list:g_scope_list) (scope_list:scope_list) (bitv:bitv) (bitv':bitv) (b:b) .
(clause_name "e_ge") /\
(( ((bitv_binpred binop_ge  bitv   bitv' ) = SOME  b ) ))
 ==> 
( ( e_red ctx g_scope_list scope_list (e_binop (e_v (v_bit bitv)) binop_ge (e_v (v_bit bitv'))) (e_v (v_bool  b ))  ([]:frame list)  )))

[e_lt:] (! (ctx:'a ctx) (g_scope_list:g_scope_list) (scope_list:scope_list) (bitv:bitv) (bitv':bitv) (b:b) .
(clause_name "e_lt") /\
(( ((bitv_binpred binop_lt  bitv   bitv' ) = SOME  b ) ))
 ==> 
( ( e_red ctx g_scope_list scope_list (e_binop (e_v (v_bit bitv)) binop_lt (e_v (v_bit bitv'))) (e_v (v_bool  b ))  ([]:frame list)  )))

[e_gt:] (! (ctx:'a ctx) (g_scope_list:g_scope_list) (scope_list:scope_list) (bitv:bitv) (bitv':bitv) (b:b) .
(clause_name "e_gt") /\
(( ((bitv_binpred binop_gt  bitv   bitv' ) = SOME  b ) ))
 ==> 
( ( e_red ctx g_scope_list scope_list (e_binop (e_v (v_bit bitv)) binop_gt (e_v (v_bit bitv'))) (e_v (v_bool  b ))  ([]:frame list)  )))

[e_neq:] (! (ctx:'a ctx) (g_scope_list:g_scope_list) (scope_list:scope_list) (bitv:bitv) (bitv':bitv) (b:b) .
(clause_name "e_neq") /\
(( (( bitv  <>  bitv' ) <=>  b ) ))
 ==> 
( ( e_red ctx g_scope_list scope_list (e_binop (e_v (v_bit bitv)) binop_neq (e_v (v_bit bitv'))) (e_v (v_bool  b ))  ([]:frame list)  )))

[e_neq_bool:] (! (ctx:'a ctx) (g_scope_list:g_scope_list) (scope_list:scope_list) (b:b) (b':b) (b'':b) .
(clause_name "e_neq_bool") /\
(( (( b  <>  b' ) <=>  b'' ) ))
 ==> 
( ( e_red ctx g_scope_list scope_list (e_binop (e_v (v_bool  b )) binop_neq (e_v (v_bool  b' ))) (e_v (v_bool  b'' ))  ([]:frame list)  )))

[e_eq:] (! (ctx:'a ctx) (g_scope_list:g_scope_list) (scope_list:scope_list) (bitv:bitv) (bitv':bitv) (b:b) .
(clause_name "e_eq") /\
(( (( bitv  =  bitv' ) <=>  b ) ))
 ==> 
( ( e_red ctx g_scope_list scope_list (e_binop (e_v (v_bit bitv)) binop_eq (e_v (v_bit bitv'))) (e_v (v_bool  b ))  ([]:frame list)  )))

[e_eq_bool:] (! (ctx:'a ctx) (g_scope_list:g_scope_list) (scope_list:scope_list) (b:b) (b':b) (b'':b) .
(clause_name "e_eq_bool") /\
(( ( b  =  b'  <=>  b'' ) ))
 ==> 
( ( e_red ctx g_scope_list scope_list (e_binop (e_v (v_bool  b )) binop_eq (e_v (v_bool  b' ))) (e_v (v_bool  b'' ))  ([]:frame list)  )))

[e_and:] (! (ctx:'a ctx) (g_scope_list:g_scope_list) (scope_list:scope_list) (bitv:bitv) (bitv':bitv) (bitv'':bitv) .
(clause_name "e_and") /\
(( (bitv_bl_binop band  bitv   bitv'  =  bitv'' ) ))
 ==> 
( ( e_red ctx g_scope_list scope_list (e_binop (e_v (v_bit bitv)) binop_and (e_v (v_bit bitv'))) (e_v (v_bit bitv''))  ([]:frame list)  )))

[e_xor:] (! (ctx:'a ctx) (g_scope_list:g_scope_list) (scope_list:scope_list) (bitv:bitv) (bitv':bitv) (bitv'':bitv) .
(clause_name "e_xor") /\
(( (bitv_bl_binop bxor  bitv   bitv'  =  bitv'' ) ))
 ==> 
( ( e_red ctx g_scope_list scope_list (e_binop (e_v (v_bit bitv)) binop_xor (e_v (v_bit bitv'))) (e_v (v_bit bitv''))  ([]:frame list)  )))

[e_or:] (! (ctx:'a ctx) (g_scope_list:g_scope_list) (scope_list:scope_list) (bitv:bitv) (bitv':bitv) (bitv'':bitv) .
(clause_name "e_or") /\
(( (bitv_bl_binop bor  bitv   bitv'  =  bitv'' ) ))
 ==> 
( ( e_red ctx g_scope_list scope_list (e_binop (e_v (v_bit bitv)) binop_or (e_v (v_bit bitv'))) (e_v (v_bit bitv''))  ([]:frame list)  )))

[e_bin_and1:] (! (ctx:'a ctx) (g_scope_list:g_scope_list) (scope_list:scope_list) (e:e) .
(clause_name "e_bin_and1")
 ==> 
( ( e_red ctx g_scope_list scope_list (e_binop (e_v (v_bool  F )) binop_bin_and e) (e_v (v_bool  F ))  ([]:frame list)  )))

[e_bin_and2:] (! (ctx:'a ctx) (g_scope_list:g_scope_list) (scope_list:scope_list) (e:e) .
(clause_name "e_bin_and2")
 ==> 
( ( e_red ctx g_scope_list scope_list (e_binop (e_v (v_bool  T )) binop_bin_and e) e  ([]:frame list)  )))

[e_bin_or1:] (! (ctx:'a ctx) (g_scope_list:g_scope_list) (scope_list:scope_list) (e:e) .
(clause_name "e_bin_or1")
 ==> 
( ( e_red ctx g_scope_list scope_list (e_binop (e_v (v_bool  T )) binop_bin_or e) (e_v (v_bool  T ))  ([]:frame list)  )))

[e_bin_or2:] (! (ctx:'a ctx) (g_scope_list:g_scope_list) (scope_list:scope_list) (e:e) .
(clause_name "e_bin_or2")
 ==> 
( ( e_red ctx g_scope_list scope_list (e_binop (e_v (v_bool  F )) binop_bin_or e) e  ([]:frame list)  )))
End
(** definitions *)

(* defns stmt_sem *)
Inductive stmt_sem:
(* defn stmt_red *)

[stmt_ass_v:] (! (ctx:'a ctx) (ascope:'a) (g_scope_list:g_scope_list) (funn:funn) (lval:lval) (v:v) (scope_list:scope_list) (g_scope_list':g_scope_list) (scope_list'':scope_list) (scope_list':scope_list) .
(clause_name "stmt_ass_v") /\
(( (SOME  scope_list'  = assign   (  ( scope_list  ++   (  g_scope_list  )  )  )    v   lval ) ) /\
( ( ( SOME  g_scope_list'  ,  SOME  scope_list''  ) = separate  scope_list'  ) ))
 ==> 
( ( stmt_red ctx  ( ascope ,  g_scope_list ,   ([   ( funn  ,   ( ([((stmt_ass lval (e_v v)))]) )   ,  scope_list )   ])  ,  status_running )   ( ascope ,  g_scope_list' ,   ([   ( funn  ,   ( ([(stmt_empty)]) )   ,  scope_list'' )   ])  ,  status_running )  )))

[stmt_seq1:] (! (ctx:'a ctx) (ascope:'a) (g_scope_list:g_scope_list) (funn:funn) (stmt1:stmt) (stmt2:stmt) (scope_list:scope_list) (ascope':'a) (g_scope_list':g_scope_list) (frame_list:frame_list) (stmt_stack':stmt_stack) (stmt1':stmt) (scope_list':scope_list) .
(clause_name "stmt_seq1") /\
(( ( stmt_red ctx  ( ascope ,  g_scope_list ,   ([   ( funn  ,   ( ([(stmt1)]) )   ,  scope_list )   ])  ,  status_running )   ( ascope' ,  g_scope_list' ,   ( frame_list  ++   ([   ( funn  ,   ( stmt_stack'  ++   ( ([(stmt1')]) )  )   ,  scope_list' )   ])  )  ,  status_running )  )))
 ==> 
( ( stmt_red ctx  ( ascope ,  g_scope_list ,   ([   ( funn  ,   ( ([((stmt_seq stmt1 stmt2))]) )   ,  scope_list )   ])  ,  status_running )   ( ascope' ,  g_scope_list' ,   ( frame_list  ++   ([   ( funn  ,   ( stmt_stack'  ++   ( ([((stmt_seq stmt1' stmt2))]) )  )   ,  scope_list' )   ])  )  ,  status_running )  )))

[stmt_seq2:] (! (ctx:'a ctx) (ascope:'a) (g_scope_list:g_scope_list) (funn:funn) (stmt:stmt) (scope_list:scope_list) .
(clause_name "stmt_seq2")
 ==> 
( ( stmt_red ctx  ( ascope ,  g_scope_list ,   ([   ( funn  ,   ( ([((stmt_seq stmt_empty stmt))]) )   ,  scope_list )   ])  ,  status_running )   ( ascope ,  g_scope_list ,   ([   ( funn  ,   ( ([(stmt)]) )   ,  scope_list )   ])  ,  status_running )  )))

[stmt_seq3:] (! (ctx:'a ctx) (ascope:'a) (g_scope_list:g_scope_list) (funn:funn) (stmt1:stmt) (stmt2:stmt) (scope_list:scope_list) (ascope':'a) (g_scope_list':g_scope_list) (stmt1':stmt) (scope_list':scope_list) (status:status) .
(clause_name "stmt_seq3") /\
(( ( stmt_red ctx  ( ascope ,  g_scope_list ,   ([   ( funn  ,   ( ([(stmt1)]) )   ,  scope_list )   ])  ,  status_running )   ( ascope' ,  g_scope_list' ,   ([   ( funn  ,   ( ([(stmt1')]) )   ,  scope_list' )   ])  ,  status )  )) /\
( (status <> status_running) ))
 ==> 
( ( stmt_red ctx  ( ascope ,  g_scope_list ,   ([   ( funn  ,   ( ([((stmt_seq stmt1 stmt2))]) )   ,  scope_list )   ])  ,  status_running )   ( ascope' ,  g_scope_list' ,   ([   ( funn  ,   ( ([(stmt1')]) )   ,  scope_list' )   ])  ,  status )  )))

[stmt_cond2:] (! (ctx:'a ctx) (ascope:'a) (g_scope_list:g_scope_list) (funn:funn) (stmt1:stmt) (stmt2:stmt) (scope_list:scope_list) .
(clause_name "stmt_cond2")
 ==> 
( ( stmt_red ctx  ( ascope ,  g_scope_list ,   ([   ( funn  ,   ( ([((stmt_cond (e_v (v_bool  T )) stmt1 stmt2))]) )   ,  scope_list )   ])  ,  status_running )   ( ascope ,  g_scope_list ,   ([   ( funn  ,   ( ([(stmt1)]) )   ,  scope_list )   ])  ,  status_running )  )))

[stmt_cond3:] (! (ctx:'a ctx) (ascope:'a) (g_scope_list:g_scope_list) (funn:funn) (stmt1:stmt) (stmt2:stmt) (scope_list:scope_list) .
(clause_name "stmt_cond3")
 ==> 
( ( stmt_red ctx  ( ascope ,  g_scope_list ,   ([   ( funn  ,   ( ([((stmt_cond (e_v (v_bool  F )) stmt1 stmt2))]) )   ,  scope_list )   ])  ,  status_running )   ( ascope ,  g_scope_list ,   ([   ( funn  ,   ( ([(stmt2)]) )   ,  scope_list )   ])  ,  status_running )  )))

[stmt_block_enter:] (! (ctx:'a ctx) (ascope:'a) (g_scope_list:g_scope_list) (funn:funn) (t_scope:t_scope) (stmt:stmt) (scope_list:scope_list) (scope_list':scope_list) (scope:scope) .
(clause_name "stmt_block_enter") /\
((  ( scope )   = declare_list_in_fresh_scope ( t_scope ) ) /\
( ( scope_list'  =   (  ( ([(scope)]) )   ++  scope_list )  ) ))
 ==> 
( ( stmt_red ctx  ( ascope ,  g_scope_list ,   ([   ( funn  ,   ( ([((stmt_block t_scope stmt))]) )   ,  scope_list )   ])  ,  status_running )   ( ascope ,  g_scope_list ,   ([   ( funn  ,   ( stmt  ::   ( ([(stmt_empty)]) )  )   ,  scope_list' )   ])  ,  status_running )  )))

[stmt_block_exec:] (! (apply_table_f:'a apply_table_f) (ext_map:'a ext_map) (func_map:func_map) (b_func_map:b_func_map) (pars_map:pars_map) (tbl_map:tbl_map) (ascope:'a) (g_scope_list:g_scope_list) (funn:funn) (stmt:stmt) (stmt_stack:stmt_stack) (scope_list:scope_list) (status:status) (ascope':'a) (g_scope_list':g_scope_list) (frame_list':frame_list) (stmt_stack':stmt_stack) (scope_list':scope_list) (status':status) .
(clause_name "stmt_block_exec") /\
(( ( stmt  <> stmt_empty) ) /\
( ( stmt_stack  <> []) ) /\
( ( stmt_red  ( apply_table_f ,  ext_map ,  func_map ,  b_func_map  ,  pars_map ,  tbl_map )   ( ascope ,  g_scope_list ,   ([   ( funn  ,   ( ([(stmt)]) )   ,  scope_list )   ])  ,  status )   ( ascope' ,  g_scope_list' ,   ( frame_list'  ++   ([   ( funn  ,  stmt_stack'  ,  scope_list' )   ])  )  ,  status' )  )))
 ==> 
( ( stmt_red  ( apply_table_f ,  ext_map ,  func_map ,  b_func_map  ,  pars_map ,  tbl_map )   ( ascope ,  g_scope_list ,   ([   ( funn  ,   ( stmt  ::  stmt_stack )   ,  scope_list )   ])  ,  status )   ( ascope' ,  g_scope_list' ,   ( frame_list'  ++   ([   ( funn  ,   ( stmt_stack'  ++  stmt_stack )   ,  scope_list' )   ])  )  ,  status' )  )))

[stmt_block_exit:] (! (ctx:'a ctx) (ascope:'a) (g_scope_list:g_scope_list) (funn:funn) (stmt_stack:stmt_stack) (scope_list:scope_list) (status:status) (scope_list':scope_list) .
(clause_name "stmt_block_exit") /\
(( ( stmt_stack  <> []) ) /\
( ( scope_list'  =   (TL  scope_list )  ) ))
 ==> 
( ( stmt_red ctx  ( ascope ,  g_scope_list ,   ([   ( funn  ,   ( stmt_empty  ::  stmt_stack )   ,  scope_list )   ])  ,  status )   ( ascope ,  g_scope_list ,   ([   ( funn  ,  stmt_stack  ,  scope_list' )   ])  ,  status )  )))

[stmt_trans:] (! (ctx:'a ctx) (ascope:'a) (g_scope_list:g_scope_list) (funn:funn) (x:x) (scope_list:scope_list) .
(clause_name "stmt_trans")
 ==> 
( ( stmt_red ctx  ( ascope ,  g_scope_list ,   ([   ( funn  ,   ( ([((stmt_trans (e_v (v_str x))))]) )   ,  scope_list )   ])  ,  status_running )   ( ascope ,  g_scope_list ,   ([   ( funn  ,   ( ([(stmt_empty)]) )   ,  scope_list )   ])  ,  (status_trans x) )  )))

[stmt_apply_table_v:] (! (e'_list:e list) (e_mk_list:(e#mk) list) (v_list:v list) (apply_table_f:'a apply_table_f) (ext_map:'a ext_map) (func_map:func_map) (b_func_map:b_func_map) (pars_map:pars_map) (tbl_map:tbl_map) (ascope:'a) (g_scope_list:g_scope_list) (funn:funn) (tbl:x) (scope_list:scope_list) (f:x) (f':x) .
(clause_name "stmt_apply_table_v") /\
(( (is_consts   ( ((MAP (\(e_,mk_) . e_) e_mk_list)) )  ) ) /\
( ( ALOOKUP  tbl_map   tbl  = SOME (   ( ((MAP (\(e_,mk_) . mk_) e_mk_list)) )   , (  f'  ,   ( (e'_list) )   ) ) ) ) /\
( ( apply_table_f  (  tbl  ,   (  ( ((MAP (\(e_,mk_) . e_) e_mk_list)) )  )   ,   (  ( ((MAP (\(e_,mk_) . mk_) e_mk_list)) )  )   , (  f'  ,   ( (e'_list) )   ),  ascope ) = SOME (  f  ,   (  ( ((MAP (\v_ . (e_v v_)) v_list)) )  )   ) ) ))
 ==> 
( ( stmt_red  ( apply_table_f ,  ext_map ,  func_map ,  b_func_map  ,  pars_map ,  tbl_map )   ( ascope ,  g_scope_list ,   ([   ( funn  ,   ( ([((stmt_app tbl ((MAP (\(e_,mk_) . e_) e_mk_list))))]) )   ,  scope_list )   ])  ,  status_running )   ( ascope ,  g_scope_list ,   ([   ( funn  ,   ( ([((stmt_ass lval_null  ( (e_call (funn_name f) ((MAP (\v_ . (e_v v_)) v_list))) ) ))]) )   ,  scope_list )   ])  ,  status_running )  )))

[stmt_ret_v:] (! (ctx:'a ctx) (ascope:'a) (g_scope_list:g_scope_list) (funn:funn) (v:v) (scope_list:scope_list) .
(clause_name "stmt_ret_v")
 ==> 
( ( stmt_red ctx  ( ascope ,  g_scope_list ,   ([   ( funn  ,   ( ([((stmt_ret (e_v v)))]) )   ,  scope_list )   ])  ,  status_running )   ( ascope ,  g_scope_list ,   ([   ( funn  ,   ( ([(stmt_empty)]) )   ,  scope_list )   ])  ,  (status_returnv v) )  )))

[stmt_ext:] (! (apply_table_f:'a apply_table_f) (ext_map:'a ext_map) (func_map:func_map) (b_func_map:b_func_map) (pars_map:pars_map) (tbl_map:tbl_map) (ascope:'a) (g_scope_list:g_scope_list) (funn:funn) (scope_list:scope_list) (ascope':'a) (scope_list':scope_list) (status:status) (ext_fun:'a ext_fun) .
(clause_name "stmt_ext") /\
(( (SOME  ext_fun  = lookup_ext_fun  funn   ext_map ) ) /\
( (SOME ( ascope' ,  scope_list' ,  status ) =  ext_fun  ( ascope ,  g_scope_list ,  scope_list )) ))
 ==> 
( ( stmt_red  ( apply_table_f ,  ext_map ,  func_map ,  b_func_map  ,  pars_map ,  tbl_map )   ( ascope ,  g_scope_list ,   ([   ( funn  ,   ( ([(stmt_ext)]) )   ,  scope_list )   ])  ,  status_running )   ( ascope' ,  g_scope_list ,   ([   ( funn  ,   ( ([(stmt_empty)]) )   ,  scope_list' )   ])  ,  status )  )))

[stmt_ret_e:] (! (ctx:'a ctx) (ascope:'a) (g_scope_list:g_scope_list) (funn:funn) (e:e) (scope_list:scope_list) (frame_list:frame_list) (e':e) .
(clause_name "stmt_ret_e") /\
(( ( e_red ctx g_scope_list scope_list e e' frame_list )))
 ==> 
( ( stmt_red ctx  ( ascope ,  g_scope_list ,   ([   ( funn  ,   ( ([((stmt_ret e))]) )   ,  scope_list )   ])  ,  status_running )   ( ascope ,  g_scope_list ,   ( frame_list  ++   ([   ( funn  ,   ( ([((stmt_ret e'))]) )   ,  scope_list )   ])  )  ,  status_running )  )))

[stmt_ass_e:] (! (ctx:'a ctx) (ascope:'a) (g_scope_list:g_scope_list) (funn:funn) (lval:lval) (e:e) (scope_list:scope_list) (frame_list:frame_list) (e':e) .
(clause_name "stmt_ass_e") /\
(( ( e_red ctx g_scope_list scope_list e e' frame_list )))
 ==> 
( ( stmt_red ctx  ( ascope ,  g_scope_list ,   ([   ( funn  ,   ( ([((stmt_ass lval e))]) )   ,  scope_list )   ])  ,  status_running )   ( ascope ,  g_scope_list ,   ( frame_list  ++   ([   ( funn  ,   ( ([((stmt_ass lval e'))]) )   ,  scope_list )   ])  )  ,  status_running )  )))

[stmt_cond_e:] (! (ctx:'a ctx) (ascope:'a) (g_scope_list:g_scope_list) (funn:funn) (e:e) (stmt1:stmt) (stmt2:stmt) (scope_list:scope_list) (frame_list:frame_list) (e':e) .
(clause_name "stmt_cond_e") /\
(( ( e_red ctx g_scope_list scope_list e e' frame_list )))
 ==> 
( ( stmt_red ctx  ( ascope ,  g_scope_list ,   ([   ( funn  ,   ( ([((stmt_cond e stmt1 stmt2))]) )   ,  scope_list )   ])  ,  status_running )   ( ascope ,  g_scope_list ,   ( frame_list  ++   ([   ( funn  ,   ( ([((stmt_cond e' stmt1 stmt2))]) )   ,  scope_list )   ])  )  ,  status_running )  )))

[stmt_trans_e:] (! (ctx:'a ctx) (ascope:'a) (g_scope_list:g_scope_list) (funn:funn) (e:e) (scope_list:scope_list) (frame_list:frame_list) (e':e) .
(clause_name "stmt_trans_e") /\
(( ( e_red ctx g_scope_list scope_list e e' frame_list )))
 ==> 
( ( stmt_red ctx  ( ascope ,  g_scope_list ,   ([   ( funn  ,   ( ([((stmt_trans e))]) )   ,  scope_list )   ])  ,  status_running )   ( ascope ,  g_scope_list ,   ( frame_list  ++   ([   ( funn  ,   ( ([((stmt_trans e'))]) )   ,  scope_list )   ])  )  ,  status_running )  )))

[stmt_apply_table_e:] (! (e_e'_list:(e#e) list) (ctx:'a ctx) (ascope:'a) (g_scope_list:g_scope_list) (funn:funn) (tbl:x) (scope_list:scope_list) (frame_list:frame_list) (i:i) (e:e) (e':e) .
(clause_name "stmt_apply_table_e") /\
(( (index_not_const   ( ((MAP (\(e_,e'_) . e_) e_e'_list)) )   = SOME  i ) ) /\
( ( e  = EL  i    ( ((MAP (\(e_,e'_) . e_) e_e'_list)) )  ) ) /\
( ( e_red ctx g_scope_list scope_list e e' frame_list )) /\
( (  ( ((MAP (\(e_,e'_) . e'_) e_e'_list)) )   =   (LUPDATE  e'   i    ( ((MAP (\(e_,e'_) . e_) e_e'_list)) )  )  ) ))
 ==> 
( ( stmt_red ctx  ( ascope ,  g_scope_list ,   ([   ( funn  ,   ( ([((stmt_app tbl ((MAP (\(e_,e'_) . e_) e_e'_list))))]) )   ,  scope_list )   ])  ,  status_running )   ( ascope ,  g_scope_list ,   ( frame_list  ++   ([   ( funn  ,   ( ([((stmt_app tbl ((MAP (\(e_,e'_) . e'_) e_e'_list))))]) )   ,  scope_list )   ])  )  ,  status_running )  )))
End
(** definitions *)

(* defns frames_sem *)
Inductive frames_sem:
(* defn frames_red *)

[frames_comp1:] (! (apply_table_f:'a apply_table_f) (ext_map:'a ext_map) (func_map:func_map) (b_func_map:b_func_map) (pars_map:pars_map) (tbl_map:tbl_map) (ascope:'a) (g_scope_list:g_scope_list) (funn:funn) (stmt_stack:stmt_stack) (scope_list:scope_list) (frame_list'':frame_list) (status:status) (ascope':'a) (g_scope_list''':g_scope_list) (frame_list':frame_list) (status':status) (g_scope_list':g_scope_list) (b_func_map':b_func_map) (tbl_map':tbl_map) (g_scope_list'':g_scope_list) .
(clause_name "frames_comp1") /\
(( (SOME g_scope_list'  = scopes_to_pass  funn   func_map   b_func_map   g_scope_list ) ) /\
( SOME  b_func_map'  = map_to_pass  funn   b_func_map ) /\
( SOME  tbl_map'  = tbl_to_pass  funn   b_func_map   tbl_map ) /\
( ( stmt_red  ( apply_table_f ,  ext_map ,  func_map ,  b_func_map'  ,  pars_map ,  tbl_map' )   ( ascope ,  g_scope_list' ,   ([   ( funn  ,  stmt_stack  ,  scope_list )   ])  ,  status )   ( ascope' ,  g_scope_list'' ,  frame_list' ,  status' )  )) /\
( ( ( frame_list''  <> []) ==> notret  status'  ) ) /\
( (SOME g_scope_list'''  = scopes_to_retrieve  funn   func_map   b_func_map   g_scope_list   g_scope_list'' ) ))
 ==> 
( ( frames_red  ( apply_table_f ,  ext_map ,  func_map ,  b_func_map  ,  pars_map ,  tbl_map )   ( ascope ,  g_scope_list ,   (  ([   ( funn  ,  stmt_stack  ,  scope_list )   ])   ++  frame_list'' )  ,  status )   ( ascope' ,  g_scope_list''' ,   ( frame_list'  ++  frame_list'' )  ,  status' )  )))

[frames_comp2:] (! (x_d_list:(x#d) list) (apply_table_f:'a apply_table_f) (ext_map:'a ext_map) (func_map:func_map) (b_func_map:b_func_map) (pars_map:pars_map) (tbl_map:tbl_map) (ascope:'a) (g_scope_list:g_scope_list) (funn:funn) (stmt_stack:stmt_stack) (scope_list:scope_list) (funn':funn) (stmt_stack':stmt_stack) (scope_list':scope_list) (frame_list:frame_list) (ascope':'a) (g_scope_list''''''':g_scope_list) (scope_list''':scope_list) (g_scope_list':g_scope_list) (b_func_map':b_func_map) (tbl_map':tbl_map) (g_scope_list'':g_scope_list) (stmt_stack'':stmt_stack) (scope_list'':scope_list) (v:v) (stmt''':stmt) (g_scope_list''':g_scope_list) (g_scope_list'''':g_scope_list) (g_scope_list''''':g_scope_list) (g_scope_list'''''':g_scope_list) .
(clause_name "frames_comp2") /\
(( (SOME g_scope_list'  = scopes_to_pass  funn   func_map   b_func_map   g_scope_list ) ) /\
( SOME  b_func_map'  = map_to_pass  funn   b_func_map ) /\
( SOME  tbl_map'  = tbl_to_pass  funn   b_func_map   tbl_map ) /\
( ( stmt_red  ( apply_table_f ,  ext_map ,  func_map ,  b_func_map'  ,  pars_map ,  tbl_map' )   ( ascope ,  g_scope_list' ,   ([   ( funn  ,  stmt_stack  ,  scope_list )   ])  ,  status_running )   ( ascope' ,  g_scope_list'' ,   ([   ( funn  ,  stmt_stack''  ,  scope_list'' )   ])  ,  (status_returnv v) )  )) /\
( (SOME ( stmt''' ,  (x_d_list) ) = lookup_funn_sig_body  funn   func_map   b_func_map   ext_map ) ) /\
( (SOME   (  g_scope_list'''  )   = assign   (  (  g_scope_list''  )  )    v   (lval_varname (varn_star funn)) ) ) /\
( (SOME g_scope_list''''  = scopes_to_retrieve  funn   func_map   b_func_map   g_scope_list   g_scope_list''' ) ) /\
( (SOME g_scope_list'''''  = scopes_to_pass  funn'   func_map   b_func_map   g_scope_list'''' ) ) /\
( ( SOME (  g_scope_list''''''  ,  scope_list'''  ) = copyout  ((MAP (\(x_,d_) . x_) x_d_list))    ( ((MAP (\(x_,d_) . d_) x_d_list)) )    g_scope_list'''''   scope_list'   scope_list''  ) ) /\
( (SOME g_scope_list'''''''  = scopes_to_retrieve  funn'   func_map   b_func_map   g_scope_list''''   g_scope_list'''''' ) ))
 ==> 
( ( frames_red  ( apply_table_f ,  ext_map ,  func_map ,  b_func_map  ,  pars_map ,  tbl_map )   ( ascope ,  g_scope_list ,   (  ([   ( funn  ,  stmt_stack  ,  scope_list )   ])   ++   (  (  ([   ( funn'  ,  stmt_stack'  ,  scope_list' )   ])   ++  frame_list )  )  )  ,  status_running )   ( ascope' ,  g_scope_list''''''' ,   (  ([   ( funn'  ,  stmt_stack'  ,  scope_list''' )   ])   ++  frame_list )  ,  status_running )  )))
End
(** definitions *)

(* defns arch_sem *)
Inductive arch_sem:
(* defn arch_red *)

[arch_in:] (! (ab_list:ab_list) (pblock_map:pblock_map) (ffblock_map:'a ffblock_map) (input_f:'a input_f) (output_f:'a output_f) (copyin_pbl:'a copyin_pbl) (copyout_pbl:'a copyout_pbl) (apply_table_f:'a apply_table_f) (ext_map:'a ext_map) (func_map:func_map) (i:i) (in_out_list:in_out_list) (in_out_list':in_out_list) (ascope:'a) (g_scope_list:g_scope_list) (in_out_list'':in_out_list) (ascope':'a) .
(clause_name "arch_in") /\
(( (  arch_block_inp  = EL  i   ab_list  ) ) /\
( ( SOME (  in_out_list''  ,  ascope'  ) =  input_f  (  in_out_list  ,  ascope  ) ) ))
 ==> 
( ( arch_red  ( ab_list ,  pblock_map ,  ffblock_map ,  input_f ,  output_f ,  copyin_pbl ,  copyout_pbl ,  apply_table_f ,  ext_map ,  func_map )   (  (  i  ,  in_out_list ,  in_out_list' ,  ascope )  ,  g_scope_list ,  arch_frame_list_empty ,  status_running )   (  (  (   i   +   1   )  ,  in_out_list'' ,  in_out_list' ,  ascope' )  ,  g_scope_list ,  arch_frame_list_empty ,  status_running )  )))

[arch_pbl_init:] (! (e_x_d_list:(e#x#d) list) (ab_list:ab_list) (pblock_map:pblock_map) (ffblock_map:'a ffblock_map) (input_f:'a input_f) (output_f:'a output_f) (copyin_pbl:'a copyin_pbl) (copyout_pbl:'a copyout_pbl) (apply_table_f:'a apply_table_f) (ext_map:'a ext_map) (func_map:func_map) (i:i) (in_out_list:in_out_list) (in_out_list':in_out_list) (ascope:'a) (g_scope_list:g_scope_list) (g_scope_list''':g_scope_list) (f:x) (stmt:stmt) (pbl_type:pbl_type) (b_func_map:b_func_map) (t_scope:t_scope) (pars_map:pars_map) (tbl_map:tbl_map) (scope':scope) (scope'':scope) (g_scope_list':g_scope_list) (g_scope_list'':g_scope_list) .
(clause_name "arch_pbl_init") /\
(( (  (arch_block_pbl f ((MAP (\(e_,x_,d_) . e_) e_x_d_list)))  = EL  i   ab_list  ) ) /\
( (ALOOKUP  pblock_map   f  = SOME (  pbl_type  ,  ((MAP (\(e_,x_,d_) . (x_,d_)) e_x_d_list))  ,  b_func_map  ,  t_scope  ,  pars_map  ,  tbl_map  )) ) /\
( (SOME  stmt  = lookup_block_body  f   b_func_map ) ) /\
( (SOME  scope'  =  copyin_pbl  ( ((MAP (\(e_,x_,d_) . x_) e_x_d_list)) ,   ( ((MAP (\(e_,x_,d_) . d_) e_x_d_list)) )  ,   ( ((MAP (\(e_,x_,d_) . e_) e_x_d_list)) )  ,  ascope )) ) /\
( scope''  = declare_list_in_scope ( t_scope ,  scope' ) ) /\
( (  (  g_scope_list'  )   =   (   (LASTN   1    g_scope_list )   )  ) ) /\
( (  (  g_scope_list''  )   =   (  ( ([(scope'')]) )   ++   (  g_scope_list'  )  )  ) ) /\
( (SOME  g_scope_list'''  = initialise_var_stars  func_map   b_func_map   ext_map   g_scope_list'' ) ))
 ==> 
( ( arch_red  ( ab_list ,  pblock_map ,  ffblock_map ,  input_f ,  output_f ,  copyin_pbl ,  copyout_pbl ,  apply_table_f ,  ext_map ,  func_map )   (  (  i  ,  in_out_list ,  in_out_list' ,  ascope )  ,  g_scope_list ,  arch_frame_list_empty ,  status_running )   (  (  i  ,  in_out_list ,  in_out_list' ,  ascope )  ,  g_scope_list''' ,  (arch_frame_list_regular  ([   ( (funn_name f)  ,   ( ([(stmt)]) )   ,   ( ([( [] )]) )  )   ]) ) ,  status_running )  )))

[arch_ffbl:] (! (ab_list:ab_list) (pblock_map:pblock_map) (ffblock_map:'a ffblock_map) (input_f:'a input_f) (output_f:'a output_f) (copyin_pbl:'a copyin_pbl) (copyout_pbl:'a copyout_pbl) (apply_table_f:'a apply_table_f) (ext_map:'a ext_map) (func_map:func_map) (i:i) (in_out_list:in_out_list) (in_out_list':in_out_list) (ascope:'a) (g_scope_list:g_scope_list) (ascope':'a) (x:x) (ff:'a ff) .
(clause_name "arch_ffbl") /\
(( (  (arch_block_ffbl x)  = EL  i   ab_list  ) ) /\
( (ALOOKUP  ffblock_map   x  = SOME  (ffblock_ff ff) ) ) /\
( (SOME  ascope'  =  ff  ( ascope ) ) ))
 ==> 
( ( arch_red  ( ab_list ,  pblock_map ,  ffblock_map ,  input_f ,  output_f ,  copyin_pbl ,  copyout_pbl ,  apply_table_f ,  ext_map ,  func_map )   (  (  i  ,  in_out_list ,  in_out_list' ,  ascope )  ,  g_scope_list ,  arch_frame_list_empty ,  status_running )   (  (  (   i   +   1   )  ,  in_out_list ,  in_out_list' ,  ascope' )  ,  g_scope_list ,  arch_frame_list_empty ,  status_running )  )))

[arch_out:] (! (ab_list:ab_list) (pblock_map:pblock_map) (ffblock_map:'a ffblock_map) (input_f:'a input_f) (output_f:'a output_f) (copyin_pbl:'a copyin_pbl) (copyout_pbl:'a copyout_pbl) (apply_table_f:'a apply_table_f) (ext_map:'a ext_map) (func_map:func_map) (i:i) (in_out_list:in_out_list) (in_out_list':in_out_list) (ascope:'a) (g_scope_list:g_scope_list) (in_out_list'':in_out_list) (ascope':'a) .
(clause_name "arch_out") /\
(( (  arch_block_out  = EL  i   ab_list  ) ) /\
( ( SOME (  in_out_list''  ,  ascope'  ) =  output_f  (  in_out_list'  ,  ascope  ) ) ))
 ==> 
( ( arch_red  ( ab_list ,  pblock_map ,  ffblock_map ,  input_f ,  output_f ,  copyin_pbl ,  copyout_pbl ,  apply_table_f ,  ext_map ,  func_map )   (  (  i  ,  in_out_list ,  in_out_list' ,  ascope )  ,  g_scope_list ,  arch_frame_list_empty ,  status_running )   (  (  0  ,  in_out_list ,  in_out_list'' ,  ascope' )  ,  g_scope_list ,  arch_frame_list_empty ,  status_running )  )))

[arch_parser_trans:] (! (x_d_list:(x#d) list) (e_list:e list) (ab_list:ab_list) (pblock_map:pblock_map) (ffblock_map:'a ffblock_map) (input_f:'a input_f) (output_f:'a output_f) (copyin_pbl:'a copyin_pbl) (copyout_pbl:'a copyout_pbl) (apply_table_f:'a apply_table_f) (ext_map:'a ext_map) (func_map:func_map) (i:i) (in_out_list:in_out_list) (in_out_list':in_out_list) (ascope:'a) (g_scope_list:g_scope_list) (frame_list:frame_list) (x':x) (g_scope_list':g_scope_list) (stmt':stmt) (x:x) (b_func_map:b_func_map) (t_scope:t_scope) (pars_map:pars_map) (tbl_map:tbl_map) .
(clause_name "arch_parser_trans") /\
(( (  (arch_block_pbl x (e_list))  = EL  i   ab_list  ) ) /\
( (ALOOKUP  pblock_map   x  = SOME (  pbl_type_parser  ,  (x_d_list)  ,  b_func_map  ,  t_scope  ,  pars_map  ,  tbl_map  )) ) /\
( (( x'  <> "accept") /\ ( x'  <> "reject")) ) /\
( (ALOOKUP  pars_map   x'  = SOME ( stmt' )) ))
 ==> 
( ( arch_red  ( ab_list ,  pblock_map ,  ffblock_map ,  input_f ,  output_f ,  copyin_pbl ,  copyout_pbl ,  apply_table_f ,  ext_map ,  func_map )   (  (  i  ,  in_out_list ,  in_out_list' ,  ascope )  ,  g_scope_list ,  (arch_frame_list_regular frame_list) ,  (status_trans x') )   (  (  i  ,  in_out_list ,  in_out_list' ,  ascope )  ,  g_scope_list' ,  (arch_frame_list_regular  ([   ( (funn_name x')  ,   ( ([(stmt')]) )   ,   ( ([( [] )]) )  )   ]) ) ,  status_running )  )))

[arch_pbl_exec:] (! (x_d_list:(x#d) list) (e_list:e list) (ab_list:ab_list) (pblock_map:pblock_map) (ffblock_map:'a ffblock_map) (input_f:'a input_f) (output_f:'a output_f) (copyin_pbl:'a copyin_pbl) (copyout_pbl:'a copyout_pbl) (apply_table_f:'a apply_table_f) (ext_map:'a ext_map) (func_map:func_map) (i:i) (in_out_list:in_out_list) (in_out_list':in_out_list) (ascope:'a) (g_scope_list:g_scope_list) (frame_list:frame_list) (ascope':'a) (g_scope_list':g_scope_list) (frame_list':frame_list) (status':status) (x:x) (pbl_type:pbl_type) (b_func_map:b_func_map) (t_scope:t_scope) (pars_map:pars_map) (tbl_map:tbl_map) .
(clause_name "arch_pbl_exec") /\
(( (  (arch_block_pbl x (e_list))  = EL  i   ab_list  ) ) /\
( (ALOOKUP  pblock_map   x  = SOME (  pbl_type  ,  (x_d_list)  ,  b_func_map  ,  t_scope  ,  pars_map  ,  tbl_map  )) ) /\
( ( frames_red  ( apply_table_f ,  ext_map ,  func_map ,  b_func_map  ,  pars_map ,  tbl_map )   ( ascope ,  g_scope_list ,  frame_list ,  status_running )   ( ascope' ,  g_scope_list' ,  frame_list' ,  status' )  )))
 ==> 
( ( arch_red  ( ab_list ,  pblock_map ,  ffblock_map ,  input_f ,  output_f ,  copyin_pbl ,  copyout_pbl ,  apply_table_f ,  ext_map ,  func_map )   (  (  i  ,  in_out_list ,  in_out_list' ,  ascope )  ,  g_scope_list ,  (arch_frame_list_regular frame_list) ,  status_running )   (  (  i  ,  in_out_list ,  in_out_list' ,  ascope' )  ,  g_scope_list' ,  (arch_frame_list_regular frame_list') ,  status' )  )))

[arch_pbl_ret:] (! (e_x_d_list:(e#x#d) list) (ab_list:ab_list) (pblock_map:pblock_map) (ffblock_map:'a ffblock_map) (input_f:'a input_f) (output_f:'a output_f) (copyin_pbl:'a copyin_pbl) (copyout_pbl:'a copyout_pbl) (apply_table_f:'a apply_table_f) (ext_map:'a ext_map) (func_map:func_map) (i:i) (in_out_list:in_out_list) (in_out_list':in_out_list) (ascope:'a) (g_scope_list:g_scope_list) (frame_list:frame_list) (status:status) (ascope':'a) (f:x) (pbl_type:pbl_type) (b_func_map:b_func_map) (t_scope:t_scope) (pars_map:pars_map) (tbl_map:tbl_map) (stmt:stmt) (status':status) .
(clause_name "arch_pbl_ret") /\
(( (  (arch_block_pbl f ((MAP (\(e_,x_,d_) . e_) e_x_d_list)))  = EL  i   ab_list  ) ) /\
( (ALOOKUP  pblock_map   f  = SOME (  pbl_type  ,  ((MAP (\(e_,x_,d_) . (x_,d_)) e_x_d_list))  ,  b_func_map  ,  t_scope  ,  pars_map  ,  tbl_map  )) ) /\
( (SOME  stmt  = lookup_block_body  f   b_func_map ) ) /\
( (state_fin  status   frame_list ) ) /\
( ( status'  = set_fin_status  pbl_type   status ) ) /\
( (SOME  ascope'  =  copyout_pbl  (  (  g_scope_list  )  ,  ascope ,   ( ((MAP (\(e_,x_,d_) . d_) e_x_d_list)) )  ,  ((MAP (\(e_,x_,d_) . x_) e_x_d_list)) ,  status' )) ))
 ==> 
( ( arch_red  ( ab_list ,  pblock_map ,  ffblock_map ,  input_f ,  output_f ,  copyin_pbl ,  copyout_pbl ,  apply_table_f ,  ext_map ,  func_map )   (  (  i  ,  in_out_list ,  in_out_list' ,  ascope )  ,  g_scope_list ,  (arch_frame_list_regular frame_list) ,  status )   (  (  (   i   +   1   )  ,  in_out_list ,  in_out_list' ,  ascope' )  ,   (LASTN   1    g_scope_list )  ,  arch_frame_list_empty ,  status_running )  )))
End
(** definitions *)

(* defns conc_sem *)
Inductive conc_sem:
(* defn conc_red *)

[conc_conc1:] (! (ab_list:ab_list) (pblock_map:pblock_map) (ffblock_map:'a ffblock_map) (input_f:'a input_f) (output_f:'a output_f) (copyin_pbl:'a copyin_pbl) (copyout_pbl:'a copyout_pbl) (apply_table_f:'a apply_table_f) (ext_map:'a ext_map) (func_map:func_map) (in_out_list:in_out_list) (in_out_list':in_out_list) (ascope:'a) (i:i) (g_scope_list:g_scope_list) (arch_frame_list:arch_frame_list) (status:status) (i':i) (g_scope_list':g_scope_list) (arch_frame_list':arch_frame_list) (status':status) (in_out_list'':in_out_list) (in_out_list''':in_out_list) (ascope':'a) (i'':i) (g_scope_list'':g_scope_list) (arch_frame_list'':arch_frame_list) (status'':status) .
(clause_name "conc_conc1") /\
(( ( arch_red  ( ab_list ,  pblock_map ,  ffblock_map ,  input_f ,  output_f ,  copyin_pbl ,  copyout_pbl ,  apply_table_f ,  ext_map ,  func_map )   (  (  i  ,  in_out_list ,  in_out_list' ,  ascope )  ,  g_scope_list ,  arch_frame_list ,  status )   (  (  i''  ,  in_out_list'' ,  in_out_list''' ,  ascope' )  ,  g_scope_list'' ,  arch_frame_list'' ,  status'' )  )))
 ==> 
( ( conc_red  ( ab_list ,  pblock_map ,  ffblock_map ,  input_f ,  output_f ,  copyin_pbl ,  copyout_pbl ,  apply_table_f ,  ext_map ,  func_map )   ((   in_out_list  ,  in_out_list'  ,  ascope  ) , ( (   i   ,  g_scope_list  ,  arch_frame_list  ,  status  ) , (   i'   ,  g_scope_list'  ,  arch_frame_list'  ,  status'  ) ))   ((   in_out_list''  ,  in_out_list'''  ,  ascope'  ) , ( (   i''   ,  g_scope_list''  ,  arch_frame_list''  ,  status''  ) , (   i'   ,  g_scope_list'  ,  arch_frame_list'  ,  status'  ) ))  )))

[conc_conc2:] (! (ab_list:ab_list) (pblock_map:pblock_map) (ffblock_map:'a ffblock_map) (input_f:'a input_f) (output_f:'a output_f) (copyin_pbl:'a copyin_pbl) (copyout_pbl:'a copyout_pbl) (apply_table_f:'a apply_table_f) (ext_map:'a ext_map) (func_map:func_map) (in_out_list:in_out_list) (in_out_list':in_out_list) (ascope:'a) (i:i) (g_scope_list:g_scope_list) (arch_frame_list:arch_frame_list) (status:status) (i':i) (g_scope_list':g_scope_list) (arch_frame_list':arch_frame_list) (status':status) (in_out_list'':in_out_list) (in_out_list''':in_out_list) (ascope':'a) (i'':i) (g_scope_list'':g_scope_list) (arch_frame_list'':arch_frame_list) (status'':status) .
(clause_name "conc_conc2") /\
(( ( arch_red  ( ab_list ,  pblock_map ,  ffblock_map ,  input_f ,  output_f ,  copyin_pbl ,  copyout_pbl ,  apply_table_f ,  ext_map ,  func_map )   (  (  i'  ,  in_out_list ,  in_out_list' ,  ascope )  ,  g_scope_list' ,  arch_frame_list' ,  status' )   (  (  i''  ,  in_out_list'' ,  in_out_list''' ,  ascope' )  ,  g_scope_list'' ,  arch_frame_list'' ,  status'' )  )))
 ==> 
( ( conc_red  ( ab_list ,  pblock_map ,  ffblock_map ,  input_f ,  output_f ,  copyin_pbl ,  copyout_pbl ,  apply_table_f ,  ext_map ,  func_map )   ((   in_out_list  ,  in_out_list'  ,  ascope  ) , ( (   i   ,  g_scope_list  ,  arch_frame_list  ,  status  ) , (   i'   ,  g_scope_list'  ,  arch_frame_list'  ,  status'  ) ))   ((   in_out_list''  ,  in_out_list'''  ,  ascope'  ) , ( (   i   ,  g_scope_list  ,  arch_frame_list  ,  status  ) , (   i''   ,  g_scope_list''  ,  arch_frame_list''  ,  status''  ) ))  )))
End
open bitstringTheory;
open wordsTheory;


Type t_scope_list_g = ``:(t_scope list)``

Type t_scope_list = ``:(t_scope list)``


Type t_scopes_tup = ``:(t_scope_list_g # t_scope_list)``

Type t_scopes_frames = ``:(t_scope_list list)``

val _ = Hol_datatype ` 
order_elem =  (* the individual elements of the order in the state are fun name or tables names *)
   order_elem_f of funn
 | order_elem_t of x
`;

Type delta_t = ``:(string, taul) alist``

Type delta_x = ``:(string, ( Ftau option # (string , Ftau ) alist )) alist``

Type delta_b = ``:(string, Ftau) alist``

Type delta_g = ``:(string, Ftau) alist``

Type delta = ``:( delta_g # delta_b # delta_x # delta_t )``

Type funn_list = ``:( funn list )``


Type order = ``:(order_elem -> order_elem -> bool )``

Type T_e = ``:( order # funn # delta )``

Type Prs_n = ``:(string list)``


(*************************************************)
(****** Typing Rules Related definitions *********)
(*************************************************)

(* returns the width of the bitstring *)
val bs_width_def = Define `
  bs_width (bl, (n:num)) = n
`;


val star_not_in_ts_def = Define `
star_not_in_ts (s:t_scope) =
  ! f . (ALOOKUP s (varn_star f) = NONE)
`;

val Err_not_in_ts_def = Define `
Err_not_in_ts (s:t_scope) =
   (ALOOKUP s (varn_name "parseError") = NONE)
`;


val star_Err_not_in_ts_def = Define `
star_Err_not_in_ts (s:t_scope) =
  (Err_not_in_ts s /\ star_not_in_ts s)
`;

(*TODO: rename this, it is actually NONE *)
val lvalop_not_none_def = Define `
lvalop_not_none (s:t_scope) =
   EVERY (\(x,t,lop). lop = NONE) s
`;

(*
val parseError_in_gs_def  = Define `
parseError_in_gs (t_scope_list_g:t_scope list) ( t_scope_list_list : t_scope list list) =
  ((ALOOKUP (EL 1 t_scope_list_g) (varn_name "parseError") = SOME (tau_err,NONE)) /\
   (ALOOKUP (EL 0 t_scope_list_g) (varn_name "parseError") = NONE) /\
  (! i . i < LENGTH t_scope_list_list ==> lookup_map (EL i t_scope_list_list) (varn_name "parseError") = NONE ))
`;  
*)

(* find the type of the top most scope that contains x 
here the lists of the typing scope lists *)
val lookup_tau_def = Define `
  lookup_tau (ts:t_scope list) (t_scope_list_g:t_scope list) x =
    case lookup_map (ts++t_scope_list_g) x of
    | SOME t => SOME (FST t)
    | _ => NONE
`;

(* find the type of functions return value  *)
val find_star_in_globals_def = Define `
  find_star_in_globals (t_scope_list_g:t_scope_list_g) x =
    case lookup_map (t_scope_list_g) x of
    | SOME t => SOME (FST t)
    | _ => NONE
`;


(* lookup the functions type *)

val t_lookup_funn_def = Define `
  (t_lookup_funn (funn:funn) (delta_g:delta_g) (delta_b:delta_b) (delta_x:delta_x) =
    case funn of
    | (funn_name x) =>
     (case ALOOKUP delta_b x of
      | SOME (txdl, t) => SOME (txdl, t)
      | NONE =>
       (case ALOOKUP delta_g x of
        | SOME (txdl, t) => SOME (txdl, t)
        | NONE => NONE
       )
     )
    | (funn_inst x) =>
     (case ALOOKUP delta_x x of
      | SOME (SOME(txdl, t), _) => SOME (txdl, t)
      | _ => NONE)
    | (funn_ext x x') =>
     (case ALOOKUP delta_x x of
      | SOME (_, ext_MoE) =>
       (case ALOOKUP ext_MoE x' of
	      | SOME (txdl, t) => SOME (txdl, t)
	      | _ => NONE)
      | _ => NONE)
  )
`;





val ext_is_defined_def = Define `
ext_is_defined (delta_x:delta_x) funn =
! f . funn = funn_name f ⇒
( ALOOKUP delta_x f = NONE )
  ∧                            
(! x . funn = funn_inst x ⇒
       ( ∃ a1 ext_MoE . ALOOKUP delta_x x = SOME (a1,ext_MoE)))
  ∧                            
(! x x' . funn = funn_ext x x' ⇒
       ( ∃ a1 ext_MoE txdl t. ALOOKUP delta_x x = SOME (a1,ext_MoE) ∧
         ALOOKUP ext_MoE x' = SOME (txdl, t)))
`;



val ext_not_defined_def = Define `
    ext_not_defined delta_g delta_b funn =
((∀f.    funn = funn_name f ⇒
            ALOOKUP delta_g f = NONE ∧ ALOOKUP delta_b f = NONE) ∧
(∀x.    funn = funn_inst x ⇒
            ALOOKUP delta_g x = NONE ∧ ALOOKUP delta_b x = NONE) ∧
(∀x x'. funn = funn_ext x x' ⇒
         ALOOKUP delta_g x = NONE ∧ ALOOKUP delta_b x = NONE))   `;  





(* 
given a record feild names and their types xtl, with result tau and a string x, make sure that 
the string x has the proper type in the record list xtl, and it should be equal to to tau
used in feild access typing *)
val tau_in_rec_def = Define `
tau_in_rec (xtl:(x#tau) list) (x:x) (t:tau) =
    case (FIND (\(xm, tm). xm = x) xtl) of
    | SOME (xm, tm) => 
      if (tm = t) then (SOME T) else ( SOME F)
    | NONE => NONE
`;


(* Syntactic function to make the tau_in_rec retuens a boolean rather than option type*)
val correct_field_type_def = Define `
  correct_field_type (xtl:(x#tau) list) (x:x) (t:tau) =
      if (tau_in_rec xtl x t = (SOME T) )
      then T
      else F
`;


(* checks the lengths of the constants during the slicing operation.
(v,n) is the desired bitvector to slice from the index vec2 to vec1 
*)
val bits_length_chec_def = Define `
bits_length_check w (vec1) (vec2) =
     ( (0 <= vec2) /\ (vec2 <= vec1) /\ (vec1 < w) )
`; 


(* given three bitstrings that are aruments to the slicing operations, convert the 
bitstrings into constants and check if they adhere to the specification's length requirements *)
val slice_length_check_def = Define `
slice_length_check w (vec1,len1) (vec2,len2) =
      bits_length_check w (v2n vec1) (v2n vec2)
`;

Definition is_struct_def:
 is_struct e =
  case e of
    e_v v =>
   (case v of
      v_struct x_v_list => T
    | _ => F)
  | e_struct x_e_list => T
  | _ => F
End

(* 13.6 Select Expressions of P4 spec: of the possible types, only Boolean and bitvector are
 * possible in HOL4P4 *)
(* TODO: Nested tuples are not yet allowed by HOL4P4: this would require generalising the s datatype
 *       and adjusting the import tool *)
Definition correct_value_set_types''_def:
 (correct_value_set_types'' [] = T) /\
 (correct_value_set_types'' ((ty,s_ty)::t) =
  case s_ty of
  | s_t_tau tau =>
   if ty = tau
   then correct_value_set_types'' t
   else F
  | s_t_top =>
   correct_value_set_types'' t
 )
End

Definition correct_value_set_types'_def:
 (correct_value_set_types' value_types [] = T) /\
 (correct_value_set_types' value_types (h::t) =
  if correct_value_set_types'' (ZIP (value_types, h))
  then correct_value_set_types' value_types t
  else F
 )
End

(* First, check that the lengths agree *)
Definition correct_value_set_types_def:
 correct_value_set_types value_types value_set_types =
  if EVERY (\l. LENGTH l = LENGTH value_types) value_set_types
  then correct_value_set_types' value_types value_set_types
  else F
End

(* convert from a bit vector to constant *)
val vec_to_const_def = Define `
vec_to_const (vec,len) =
      (v2n vec)
`;


(* check if the dir is out, then the boolean b must be lval *)

val out_is_lval_def = Define `
out_is_lval dl bl =
 ! i .  (i < LENGTH dl) ==> (is_d_out (EL i dl) ==> (EL i bl))
`;


(* returns true if the operation is conducted between two bitvectors and returnsa bitvector*)
val is_bv_op_def = Define `
is_bv_op (oper:binop) =
((oper = binop_mul) \/
(oper = binop_div) \/
(oper = binop_mod) \/
(oper = binop_add) \/
(oper = binop_sub) \/
(oper = binop_shl) \/
(oper = binop_shr) \/
(oper = binop_and) \/
(oper = binop_or) \/
(oper = binop_xor)) 
`;

(* returns true if the operation is conducted between two bitvectors and returns bool*)
val is_bv_bool_op_def = Define `
is_bv_bool_op (oper:binop) =
((oper = binop_le) \/
(oper = binop_ge) \/
(oper = binop_lt) \/
(oper = binop_gt) \/
(oper = binop_neq) \/
(oper = binop_eq)) 
`;

(* returns true if the operation is conducted between two bools and returns bool*)
val is_bool_op_def = Define `
is_bool_op (oper:binop) =
((oper = binop_bin_and) \/
(oper = binop_bin_or) \/
(oper = binop_neq) \/
(oper = binop_eq))
`;

val is_err_bool_def = Define `
is_err_bool (oper:binop) =
((oper = binop_neq) \/
(oper = binop_eq))  
`;

(* checks if exery literial x in list xl, is a parser state name indeed*)
val literials_in_P_state_def = Define `
literials_in_P_state (xl: x list) (Prs_n:Prs_n) =
EVERY (\(x). MEM x Prs_n) (xl)
`;


(* "order" is a STRICT partial relation that relates two components.
   This has the features of irreflexivity, antisymmetry, & transitivity 
   with order we mean that x defined before y *)

val WF_o_def = Define `
(WF_o order) =    (( !(x:order_elem).   ~ (order x x) ) /\
  		 ( !x y.   order x y  ==> ~order y x ) /\
       ( !x y z. order x y /\ order y z  ==> order x z ))`;


(* given a list l and an order given by the configuration order *)
val ordered_list_def = Define `
ordered_list order l  =
    ! i . i < LENGTH l - 2  ==> order (EL i l) (EL (SUC i) l)
`;






(** definitions *)

(* defns v_typ *)
Inductive v_typ:
(* defn v_typ *)

[v_typ_bool:] (! (boolv:boolv) .
(clause_name "v_typ_bool")
 ==> 
( ( v_typ (v_bool boolv) (t_tau tau_bool)  F  )))

[v_typ_bit:] (! (bitv:bitv) (w:i) .
(clause_name "v_typ_bit") /\
(( ( w  = bs_width  bitv ) ))
 ==> 
( ( v_typ (v_bit bitv) (t_tau (tau_bit  w ))  F  )))

[v_typ_bot:] (
(clause_name "v_typ_bot")
 ==> 
( ( v_typ v_bot (t_tau tau_bot)  F  )))

[v_typ_string_literal:] (! (x_list:x list) (x:x) .
(clause_name "v_typ_string_literal") /\
(( ( MEM  x    ( (x_list) )   ) ))
 ==> 
( ( v_typ (v_str x) (t_string_names_a  ( (x_list) ) )  F  )))

[v_typ_struct:] (! (x_v_tau_list:(x#v#tau) list) .
(clause_name "v_typ_struct") /\
(( !i. (i< LENGTH   ( ((MAP (\(x_,v_,tau_) . v_) x_v_tau_list)) )  ) ==> ( v_typ (EL i   ( ((MAP (\(x_,v_,tau_) . v_) x_v_tau_list)) )  ) (t_tau ( EL i   ( ((MAP (\(x_,v_,tau_) . tau_) x_v_tau_list)) )   )) F ) ))
 ==> 
( ( v_typ (v_struct ((MAP (\(x_,v_,tau_) . (x_,v_)) x_v_tau_list))) (t_tau (tau_xtl struct_ty_struct ((MAP (\(x_,v_,tau_) . (x_,tau_)) x_v_tau_list))))  F  )))

[v_typ_header:] (! (x_v_tau_list:(x#v#tau) list) (boolv:boolv) .
(clause_name "v_typ_header") /\
(( ( v_typ (v_bool boolv) (t_tau tau_bool)  F  )) /\
( !i. (i< LENGTH   ( ((MAP (\(x_,v_,tau_) . v_) x_v_tau_list)) )  ) ==> ( v_typ (EL i   ( ((MAP (\(x_,v_,tau_) . v_) x_v_tau_list)) )  ) (t_tau ( EL i   ( ((MAP (\(x_,v_,tau_) . tau_) x_v_tau_list)) )   )) F ) ))
 ==> 
( ( v_typ (v_header boolv ((MAP (\(x_,v_,tau_) . (x_,v_)) x_v_tau_list))) (t_tau (tau_xtl struct_ty_header ((MAP (\(x_,v_,tau_) . (x_,tau_)) x_v_tau_list))))  F  )))

[v_typ_ext_ref:] (! (i:i) .
(clause_name "v_typ_ext_ref")
 ==> 
( ( v_typ (v_ext_ref i) (t_tau tau_ext)  F  )))
End
(** definitions *)

(* defns s_typ *)
Inductive s_typ:
(* defn s_typ *)

[s_typ_sing:] (! (v:v) (tau:tau) (b:b) .
(clause_name "s_typ_sing") /\
(( ( v_typ v (t_tau tau)  b  )))
 ==> 
( ( s_typ (s_sing v) (s_t_tau tau) )))

[s_typ_range:] (! (bitv:bitv) (bitv':bitv) (w:i) .
(clause_name "s_typ_range") /\
(( ( w  = bs_width  bitv ) ) /\
( ( w  = bs_width  bitv' ) ))
 ==> 
( ( s_typ (s_range bitv bitv') (s_t_tau (tau_bit  w )) )))

[s_typ_mask:] (! (bitv:bitv) (bitv':bitv) (w:i) .
(clause_name "s_typ_mask") /\
(( ( w  = bs_width  bitv ) ) /\
( ( w  = bs_width  bitv' ) ))
 ==> 
( ( s_typ (s_mask bitv bitv') (s_t_tau (tau_bit  w )) )))

[s_typ_univ:] (
(clause_name "s_typ_univ")
 ==> 
( ( s_typ s_univ s_t_top )))
End


(* create a relation between two scopes *)

(* Single scope similarity *)
val similar_def = Define `
similar R l1 l2 = LIST_REL (\x y . (R (SND x) (SND y) ) /\ (FST x = FST y) ) l1 l2 `;


(*list of scopes similarity*)
val similarl_def = Define `
similarl R ll1 ll2 = LIST_REL (\l1 l2 . similar R l1 l2  ) ll1 ll2 `;



(*check if a list of scopes can be typed with respect to a list of typing scopes 
       [t_scope1...t_scopen] |- [scope1 ... scopen]
       Here we also check that the lvals are the same in the scope and the typing scope
*)
val type_scopes_list_def = Define `
type_scopes_list (sl:scope list) (tsl:t_scope list) =
 similarl (\(v,lop1) (t,lop2). v_typ v (t_tau t) F ∧ lop1 = lop2) sl tsl
`;



(* checks if a variable varn is a variable name or not, it is used later to check 
that star is not a member of the local frame. WF property. 
*)
val is_varn_name_def = Define `
  (is_varn_name (varn_name _) = T) /\
  (is_varn_name _ = F)
`;



(*in a given scope and a typing scope, the domain is the same and also all variables are 
 not return /function place holders (aka var star) 
 *)
val star_not_in_s_def = Define `
star_not_in_s (s:scope) =
  ! f . (ALOOKUP s (varn_star f) = NONE)
`;


(*in a given scope list (in one frame) and a typing scope (of one frame), the domain 
 of each scope in the list is the same and also none of the scopes contain 
 a function place holder variable star 
 *)
val star_not_in_sl_def = Define `
star_not_in_sl (sl) =
 EVERY (\s.  (star_not_in_s s)  ) sl
`;



(* To type one single frame, all scopes (list of scopes) should be able to be typed 
   by the typyng list of scopes tsl, and also, the domain of each list is the same.
   The domains should comtain only variable names, and no var star
*)
val type_frame_tsl_def = Define `
type_frame_tsl (sl:scope list) (tsl: t_scope list) =
( type_scopes_list sl tsl   /\
  star_not_in_sl (sl))
`;



(* type the global scope in a state: To type a global it is enough that all variables can 
type each other. NOTE: the global frames we keep the return functions variables stars. 
thus we do not check it's absence 
  ψ_G_list ⊢ γ_g_list
  TODO: remove it, unused.
*)
val type_globals_tsl_def = Define `
type_globals_tsl (sl:scope list) (tsl: t_scope list)  =
 similarl (\(v,lop1) (t,lop2). v_typ v (t_tau t) F ∧ lop1 = lop2) sl tsl
`;


(* To type all frame's scopes, all frames's scopes should be able to be typed 
   by the typing list of scopes tsll, and also, the domain of each frame is the same.
*)
val type_state_tsll_def = Define `
type_state_tsll (sll:scope_list list) (tsll: t_scope_list list) =
 ! i . i < LENGTH sll ==>
type_frame_tsl (EL i sll) (EL i tsll)
`;


(** definitions *)

(* defns e_typ *)
Inductive e_typ:
(* defn e_typ *)

[e_typ_v:] (! (t_scopes_tup:t_scopes_tup) (T_e:T_e) (v:v) (t:t) (b:b) .
(clause_name "e_typ_v") /\
(( ( v_typ v t  b  )))
 ==> 
( ( e_typ t_scopes_tup T_e (e_v v) t  b  )))

[e_typ_var:] (! (t_scope_list_g:t_scope_list_g) (t_scope_list:t_scope_list) (T_e:T_e) (varn:varn) (tau:tau) .
(clause_name "e_typ_var") /\
(( ( ! funn.   varn  <> (varn_star funn) ) ) /\
( SOME  tau  =  lookup_tau  t_scope_list   t_scope_list_g   varn ))
 ==> 
( ( e_typ  ( t_scope_list_g  ,  t_scope_list )  T_e (e_var varn) (t_tau tau)  T  )))

[e_typ_star:] (! (tau_x_d_list:(tau#x#d) list) (t_scope_list_g:t_scope_list_g) (t_scope_list:t_scope_list) (order:order) (funn:funn) (delta_g:delta_g) (delta_b:delta_b) (delta_x:delta_x) (delta_t:delta_t) (funn':funn) (tau:tau) .
(clause_name "e_typ_star") /\
(( SOME ( (tau_x_d_list) , tau ) = t_lookup_funn  funn'   delta_g   delta_b   delta_x ) /\
( SOME  tau  =  find_star_in_globals  t_scope_list_g   (varn_star funn') ))
 ==> 
( ( e_typ  ( t_scope_list_g  ,  t_scope_list )   (  order  ,  funn  ,   (  delta_g  ,  delta_b  ,  delta_x  ,  delta_t  )   )  (e_var (varn_star funn')) (t_tau tau)  T  )))

[e_typ_struct:] (! (f_e_tau_b_list:(x#e#tau#b) list) (t_scopes_tup:t_scopes_tup) (T_e:T_e) .
(clause_name "e_typ_struct") /\
(( !i. (i< LENGTH  ((MAP (\(f_,e_,tau_,b_) . e_) f_e_tau_b_list)) ) ==> ( e_typ  t_scopes_tup   T_e  (EL i  ((MAP (\(f_,e_,tau_,b_) . e_) f_e_tau_b_list)) ) (t_tau (EL i  ((MAP (\(f_,e_,tau_,b_) . tau_) f_e_tau_b_list)) )) (EL i  ((MAP (\(f_,e_,tau_,b_) . b_) f_e_tau_b_list)) ) ) ))
 ==> 
( ( e_typ t_scopes_tup T_e (e_struct ((MAP (\(f_,e_,tau_,b_) . (f_,e_)) f_e_tau_b_list))) (t_tau (tau_xtl struct_ty_struct ((MAP (\(f_,e_,tau_,b_) . (f_,tau_)) f_e_tau_b_list))))  F  )))

[e_typ_header:] (! (f_e_tau_b_list:(x#e#tau#b) list) (t_scopes_tup:t_scopes_tup) (T_e:T_e) (boolv:boolv) .
(clause_name "e_typ_header") /\
(( ( v_typ (v_bool boolv) (t_tau tau_bool)  F  )) /\
( !i. (i< LENGTH  ((MAP (\(f_,e_,tau_,b_) . e_) f_e_tau_b_list)) ) ==> ( e_typ  t_scopes_tup   T_e  (EL i  ((MAP (\(f_,e_,tau_,b_) . e_) f_e_tau_b_list)) ) (t_tau (EL i  ((MAP (\(f_,e_,tau_,b_) . tau_) f_e_tau_b_list)) )) (EL i  ((MAP (\(f_,e_,tau_,b_) . b_) f_e_tau_b_list)) ) ) ))
 ==> 
( ( e_typ t_scopes_tup T_e (e_header boolv ((MAP (\(f_,e_,tau_,b_) . (f_,e_)) f_e_tau_b_list))) (t_tau (tau_xtl struct_ty_header ((MAP (\(f_,e_,tau_,b_) . (f_,tau_)) f_e_tau_b_list))))  F  )))

[e_typ_not_neg:] (! (t_scopes_tup:t_scopes_tup) (T_e:T_e) (unop:unop) (e:e) (w:i) (b:b) .
(clause_name "e_typ_not_neg") /\
(( (( unop  <> unop_neg)) ) /\
( ( w  > 0 /\  w  <= 64 ) ) /\
( ( e_typ t_scopes_tup T_e e (t_tau (tau_bit  w ))  b  )))
 ==> 
( ( e_typ t_scopes_tup T_e (e_unop unop e) (t_tau (tau_bit  w ))  F  )))

[e_typ_is_neg:] (! (t_scopes_tup:t_scopes_tup) (T_e:T_e) (unop:unop) (e:e) (b:b) .
(clause_name "e_typ_is_neg") /\
(( (( unop  = unop_neg)) ) /\
( ( e_typ t_scopes_tup T_e e (t_tau tau_bool)  b  )))
 ==> 
( ( e_typ t_scopes_tup T_e (e_unop unop e) (t_tau tau_bool)  F  )))

[e_typ_acc:] (! (x_tau_list:(x#tau) list) (t_scopes_tup:t_scopes_tup) (T_e:T_e) (e:e) (x:x) (tau:tau) (b:b) (struct_ty:struct_ty) .
(clause_name "e_typ_acc") /\
(( ( e_typ t_scopes_tup T_e e (t_tau (tau_xtl struct_ty (x_tau_list)))  b  )) /\
( correct_field_type  (x_tau_list)   x   tau ))
 ==> 
( ( e_typ t_scopes_tup T_e (e_acc e x) (t_tau tau)  b  )))

[e_typ_concat:] (! (t_scopes_tup:t_scopes_tup) (T_e:T_e) (e:e) (e':e) (w1:i) (w2:i) (b:b) (b':b) .
(clause_name "e_typ_concat") /\
(( ( e_typ t_scopes_tup T_e e (t_tau (tau_bit  w1 ))  b  )) /\
( ( e_typ t_scopes_tup T_e e' (t_tau (tau_bit  w2 ))  b'  )))
 ==> 
( ( e_typ t_scopes_tup T_e (e_concat e e') (t_tau (tau_bit  (   (   w1   +   w2   )   ) ))  F  )))

[e_typ_slice:] (! (t_scopes_tup:t_scopes_tup) (T_e:T_e) (e:e) (bitv:bitv) (bitv':bitv) (w1:i) (w2:i) (b:b) (w:i) .
(clause_name "e_typ_slice") /\
(( (  w1  = vec_to_const  bitv  ) ) /\
( (  w2  = vec_to_const  bitv'  ) ) /\
( ( e_typ t_scopes_tup T_e e (t_tau (tau_bit  w ))  b  )) /\
( bits_length_check  w   w1   w2 ))
 ==> 
( ( e_typ t_scopes_tup T_e (e_slice e (e_v (v_bit bitv)) (e_v (v_bit bitv'))) (t_tau (tau_bit  (   (   (   (   w1   -   w2   )   )   +   1   )   ) ))  b  )))

[e_typ_select:] (! (s_list_x_s_t_list_list:(s_list#x#s_t_list) list) (x'_tau_list:(x#tau) list) (t_scopes_tup:t_scopes_tup) (T_e:T_e) (e:e) (x:x) (struct_ty:struct_ty) (b:b) .
(clause_name "e_typ_select") /\
(( is_struct  e ) /\
( ( e_typ t_scopes_tup T_e e (t_tau (tau_xtl struct_ty (x'_tau_list)))  b  )) /\
( !i. (i < LENGTH  ((MAP (\(s_list_,x_,s_t_list_) . s_list_) s_list_x_s_t_list_list)) ) ==> !j. (j < LENGTH (EL i  ((MAP (\(s_list_,x_,s_t_list_) . s_list_) s_list_x_s_t_list_list)) )) ==> ( s_typ (EL j (EL i  ((MAP (\(s_list_,x_,s_t_list_) . s_list_) s_list_x_s_t_list_list)) )) (EL j (EL i  ((MAP (\(s_list_,x_,s_t_list_) . s_t_list_) s_list_x_s_t_list_list)) )) ) ) /\
( correct_value_set_types  ((MAP (\(x'_,tau_) . tau_) x'_tau_list))   ((MAP (\(s_list_,x_,s_t_list_) . s_t_list_) s_list_x_s_t_list_list)) ))
 ==> 
( ( e_typ t_scopes_tup T_e (e_select e ((MAP (\(s_list_,x_,s_t_list_) . (s_list_,x_)) s_list_x_s_t_list_list)) x) (t_string_names_a  (  ( ((MAP (\(s_list_,x_,s_t_list_) . x_) s_list_x_s_t_list_list)) )   ++   ( ([(x)]) )  ) )  F  )))

[e_typ_call:] (! (e_tau_x_d_b_list:(e#tau#x#d#b) list) (t_scopes_tup:t_scopes_tup) (order:order) (funn:funn) (delta_g:delta_g) (delta_b:delta_b) (delta_x:delta_x) (delta_t:delta_t) (funn':funn) (tau:tau) .
(clause_name "e_typ_call") /\
(( SOME ( ((MAP (\(e_,tau_,x_,d_,b_) . (tau_,x_,d_)) e_tau_x_d_b_list)) , tau ) = t_lookup_funn  funn'   delta_g   delta_b   delta_x ) /\
( !i. (i< LENGTH  ((MAP (\(e_,tau_,x_,d_,b_) . e_) e_tau_x_d_b_list)) ) ==> ( e_typ  t_scopes_tup    (  order  ,  funn  ,   (  delta_g  ,  delta_b  ,  delta_x  ,  delta_t  )   )   (EL i  ((MAP (\(e_,tau_,x_,d_,b_) . e_) e_tau_x_d_b_list)) ) (t_tau (EL i  ((MAP (\(e_,tau_,x_,d_,b_) . tau_) e_tau_x_d_b_list)) )) (EL i  ((MAP (\(e_,tau_,x_,d_,b_) . b_) e_tau_x_d_b_list)) ) ) ) /\
( ( out_is_lval  ((MAP (\(e_,tau_,x_,d_,b_) . d_) e_tau_x_d_b_list))   ((MAP (\(e_,tau_,x_,d_,b_) . b_) e_tau_x_d_b_list))  ) ) /\
( ( order  (order_elem_f  funn' ) (order_elem_f  funn )) ))
 ==> 
( ( e_typ t_scopes_tup  (  order  ,  funn  ,   (  delta_g  ,  delta_b  ,  delta_x  ,  delta_t  )   )  (e_call funn' ((MAP (\(e_,tau_,x_,d_,b_) . e_) e_tau_x_d_b_list))) (t_tau tau)  F  )))

[e_typ_binop_bv:] (! (t_scopes_tup:t_scopes_tup) (T_e:T_e) (e:e) (binop:binop) (e':e) (w:i) (b:b) (b':b) .
(clause_name "e_typ_binop_bv") /\
(( ( w  > 0 /\  w  <= 64 ) ) /\
( ( e_typ t_scopes_tup T_e e (t_tau (tau_bit  w ))  b  )) /\
( ( e_typ t_scopes_tup T_e e' (t_tau (tau_bit  w ))  b'  )) /\
( is_bv_op  binop ))
 ==> 
( ( e_typ t_scopes_tup T_e (e_binop e binop e') (t_tau (tau_bit  w ))  F  )))

[e_typ_binop_bool:] (! (t_scopes_tup:t_scopes_tup) (T_e:T_e) (e:e) (binop:binop) (e':e) (b:b) (b':b) .
(clause_name "e_typ_binop_bool") /\
(( ( e_typ t_scopes_tup T_e e (t_tau tau_bool)  b  )) /\
( ( e_typ t_scopes_tup T_e e' (t_tau tau_bool)  b'  )) /\
( is_bool_op  binop ))
 ==> 
( ( e_typ t_scopes_tup T_e (e_binop e binop e') (t_tau tau_bool)  F  )))

[e_typ_binop_bv_bool:] (! (t_scopes_tup:t_scopes_tup) (T_e:T_e) (e:e) (binop:binop) (e':e) (w:i) (b:b) (b':b) .
(clause_name "e_typ_binop_bv_bool") /\
(( ( w  > 0 /\  w  <= 64 ) ) /\
( ( e_typ t_scopes_tup T_e e (t_tau (tau_bit  w ))  b  )) /\
( ( e_typ t_scopes_tup T_e e' (t_tau (tau_bit  w ))  b'  )) /\
( is_bv_bool_op  binop ))
 ==> 
( ( e_typ t_scopes_tup T_e (e_binop e binop e') (t_tau tau_bool)  F  )))

[e_typ_cast_bool:] (! (t_scopes_tup:t_scopes_tup) (T_e:T_e) (n:m) (e:e) (tau:tau) (b:b) .
(clause_name "e_typ_cast_bool") /\
(( ( n  > 0 /\  n  <= 64 ) ) /\
( ? b tp. ( e_typ  t_scopes_tup   T_e   e  tp b /\ ? n . ( tp = t_tau (tau_bit n) \/ tp = t_tau (tau_bool ) ) ) ))
 ==> 
( ( e_typ t_scopes_tup T_e (e_cast (cast_unsigned n) e) (t_tau (tau_bit  n ))  F  )))
End
(** definitions *)

(* defns lval_typ *)
Inductive lval_typ:
(* defn lval_typ *)

[lval_typ_var:] (! (t_scope_list_g:t_scope_list_g) (t_scope_list:t_scope_list) (T_e:T_e) (varn:varn) (tau:tau) .
(clause_name "lval_typ_var") /\
(( ( e_typ  ( t_scope_list_g  ,  t_scope_list )  T_e (e_var varn) (t_tau tau)  T  )))
 ==> 
( ( lval_typ  ( t_scope_list_g  ,  t_scope_list )  T_e (lval_varname varn) (t_tau tau) )))

[lval_typ_acc:] (! (x_tau_list:(x#tau) list) (t_scopes_tup:t_scopes_tup) (T_e:T_e) (lval:lval) (x:x) (tau:tau) (struct_ty:struct_ty) .
(clause_name "lval_typ_acc") /\
(( ( lval_typ t_scopes_tup T_e lval (t_tau (tau_xtl struct_ty (x_tau_list))) )) /\
( correct_field_type  (x_tau_list)   x   tau ))
 ==> 
( ( lval_typ t_scopes_tup T_e (lval_field lval x) (t_tau tau) )))

[lval_typ_slice:] (! (t_scopes_tup:t_scopes_tup) (T_e:T_e) (lval:lval) (bitv:bitv) (bitv':bitv) (w1:i) (w2:i) (w:i) .
(clause_name "lval_typ_slice") /\
(( (  w1  = vec_to_const  bitv  ) ) /\
( (  w2  = vec_to_const  bitv'  ) ) /\
( ( lval_typ t_scopes_tup T_e lval (t_tau (tau_bit  w )) )) /\
( bits_length_check  w   w1   w2 ))
 ==> 
( ( lval_typ t_scopes_tup T_e (lval_slice lval (e_v (v_bit bitv)) (e_v (v_bit bitv'))) (t_tau (tau_bit  (   (   (   (   w1   -   w2   )   )   +   1   )   ) )) )))
End
(** definitions *)

(* defns stmt_typ *)
Inductive stmt_typ:
(* defn stmt_typ *)

[stmt_typ_empty:] (! (t_scopes_tup:t_scopes_tup) (T_e:T_e) (Prs_n:Prs_n) .
(clause_name "stmt_typ_empty")
 ==> 
( ( stmt_typ t_scopes_tup T_e Prs_n stmt_empty )))

[stmt_typ_assign:] (! (t_scopes_tup:t_scopes_tup) (T_e:T_e) (Prs_n:Prs_n) (lval:lval) (e:e) (tau:tau) (b:b) .
(clause_name "stmt_typ_assign") /\
(( ( lval_typ t_scopes_tup T_e lval (t_tau tau) )) /\
( ( e_typ t_scopes_tup T_e e (t_tau tau)  b  )))
 ==> 
( ( stmt_typ t_scopes_tup T_e Prs_n (stmt_ass lval e) )))

[stmt_typ_assign_null:] (! (t_scopes_tup:t_scopes_tup) (T_e:T_e) (Prs_n:Prs_n) (e:e) (tau:tau) (b:b) .
(clause_name "stmt_typ_assign_null") /\
(( ( e_typ t_scopes_tup T_e e (t_tau tau)  b  )))
 ==> 
( ( stmt_typ t_scopes_tup T_e Prs_n (stmt_ass lval_null e) )))

[stmt_typ_if:] (! (t_scopes_tup:t_scopes_tup) (T_e:T_e) (Prs_n:Prs_n) (e:e) (stmt1:stmt) (stmt2:stmt) (b:b) .
(clause_name "stmt_typ_if") /\
(( ( e_typ t_scopes_tup T_e e (t_tau tau_bool)  b  )) /\
( ( stmt_typ t_scopes_tup T_e Prs_n stmt1 )) /\
( ( stmt_typ t_scopes_tup T_e Prs_n stmt2 )))
 ==> 
( ( stmt_typ t_scopes_tup T_e Prs_n (stmt_cond e stmt1 stmt2) )))

[stmt_typ_decl:] (! (t_scope_list_g:t_scope_list_g) (t_scope_list:t_scope_list) (T_e:T_e) (Prs_n:Prs_n) (t_scope:t_scope) (stmt:stmt) .
(clause_name "stmt_typ_decl") /\
(( ( lvalop_not_none  t_scope  ) ) /\
( (star_not_in_ts  t_scope ) ) /\
( ( stmt_typ  ( t_scope_list_g  ,   ( [  t_scope  ] ++  t_scope_list )  )  T_e Prs_n stmt )))
 ==> 
( ( stmt_typ  ( t_scope_list_g  ,  t_scope_list )  T_e Prs_n (stmt_block t_scope stmt) )))

[stmt_typ_seq:] (! (t_scopes_tup:t_scopes_tup) (T_e:T_e) (Prs_n:Prs_n) (stmt1:stmt) (stmt2:stmt) .
(clause_name "stmt_typ_seq") /\
(( ( stmt_typ t_scopes_tup T_e Prs_n stmt1 )) /\
( ( stmt_typ t_scopes_tup T_e Prs_n stmt2 )))
 ==> 
( ( stmt_typ t_scopes_tup T_e Prs_n (stmt_seq stmt1 stmt2) )))

[stmt_typ_transition:] (! (x_list:x list) (t_scopes_tup:t_scopes_tup) (T_e:T_e) (Prs_n:Prs_n) (e:e) (b:b) .
(clause_name "stmt_typ_transition") /\
(( ( e_typ t_scopes_tup T_e e (t_string_names_a  ( (x_list) ) )  b  )) /\
( (literials_in_P_state  (x_list)    (   Prs_n  ++ [ "accept" ; "reject"]   )  ) ))
 ==> 
( ( stmt_typ t_scopes_tup T_e Prs_n (stmt_trans e) )))

[stmt_typ_return:] (! (tau_x_d_list:(tau#x#d) list) (t_scopes_tup:t_scopes_tup) (order:order) (funn:funn) (delta_g:delta_g) (delta_b:delta_b) (delta_x:delta_x) (delta_t:delta_t) (Prs_n:Prs_n) (e:e) (tau:tau) (b:b) .
(clause_name "stmt_typ_return") /\
(( SOME ( (tau_x_d_list) , tau ) = t_lookup_funn  funn   delta_g   delta_b    []  ) /\
( ( e_typ t_scopes_tup  (  order  ,  funn  ,   (  delta_g  ,  delta_b  ,  delta_x  ,  delta_t  )   )  e (t_tau tau)  b  )))
 ==> 
( ( stmt_typ t_scopes_tup  (  order  ,  funn  ,   (  delta_g  ,  delta_b  ,  delta_x  ,  delta_t  )   )  Prs_n (stmt_ret e) )))

[stmt_typ_apply:] (! (e_tau_b_list:(e#tau#b) list) (t_scopes_tup:t_scopes_tup) (order:order) (funn:funn) (delta_g:delta_g) (delta_b:delta_b) (delta_x:delta_x) (delta_t:delta_t) (Prs_n:Prs_n) (tbl:x) .
(clause_name "stmt_typ_apply") /\
(( ( order  (order_elem_t  tbl ) (order_elem_f  funn )) ) /\
( (ALOOKUP  delta_t   tbl  = SOME ( ((MAP (\(e_,tau_,b_) . tau_) e_tau_b_list)) )) ) /\
( !i. (i< LENGTH  ((MAP (\(e_,tau_,b_) . e_) e_tau_b_list)) ) ==> ( e_typ  t_scopes_tup    (  order  ,  funn  ,   (  delta_g  ,  delta_b  ,  delta_x  ,  delta_t  )   )   (EL i  ((MAP (\(e_,tau_,b_) . e_) e_tau_b_list)) ) (t_tau (EL i  ((MAP (\(e_,tau_,b_) . tau_) e_tau_b_list)) )) (EL i  ((MAP (\(e_,tau_,b_) . b_) e_tau_b_list)) ) ) ))
 ==> 
( ( stmt_typ t_scopes_tup  (  order  ,  funn  ,   (  delta_g  ,  delta_b  ,  delta_x  ,  delta_t  )   )  Prs_n (stmt_app tbl ((MAP (\(e_,tau_,b_) . e_) e_tau_b_list))) )))

[stmt_typ_ext:] (! (t_scopes_tup:t_scopes_tup) (order:order) (funn:funn) (delta_g:delta_g) (delta_b:delta_b) (delta_x:delta_x) (delta_t:delta_t) (Prs_n:Prs_n) .
(clause_name "stmt_typ_ext") /\
(( ext_is_defined  delta_x   funn ) /\
( ext_not_defined  delta_g   delta_b   funn ))
 ==> 
( ( stmt_typ t_scopes_tup  (  order  ,  funn  ,   (  delta_g  ,  delta_b  ,  delta_x  ,  delta_t  )   )  Prs_n stmt_ext )))
End

val type_ith_stmt_def = Define `
type_ith_stmt t_scope_list_g t_scope_list T_e Prs_n stmt_stack =
! i . i < LENGTH stmt_stack ==>
      stmt_typ (t_scope_list_g, ( DROP i t_scope_list)  ) T_e Prs_n (EL i stmt_stack)
`;


(* checks if the first (initial) typing scope of the frame contains the same types as the one expected from 
   the functions args in the context tl *)
val args_t_same_def = Define `
args_t_same (tl:tau list) (t_scope_list:t_scope_list) =
(MAP (\(x,t,lvop).t) (LAST t_scope_list) = tl)  
`;




(* given a list of strings, mk_varn makes a list of variable names for that list *)

val mk_varn_def = Define `
mk_varn (xl:string list) =
    MAP (\x. varn_name x ) xl
`;



val extract_elem_tri_def = Define ‘
   extract_elem_tri l =
     (MAP (λ(a,b,c). a) l, MAP (λ(a,b,c). b) l , MAP (λ(a,b,c). c) l )                                        
’;


val out_lval_consistent_def = Define ‘
   out_lval_consistent (lol:lval option list) (dl:d list) =
   LIST_REL (λ lop d. lop ≠ NONE ⇔ is_d_out d)  lol dl             
’;


val sig_tscope_consistent_def = Define ‘
    sig_tscope_consistent (f:funn) delta_g delta_b delta_x (t_scope_list:t_scope_list) =

    (∀txdl tau xl tl dl varnl tl' lol.
      t_lookup_funn f delta_g delta_b delta_x = SOME (txdl,tau) ⇒
                
      extract_elem_tri txdl = (tl,xl,dl) ∧
      extract_elem_tri (LAST t_scope_list) = (varnl,tl',lol) ⇒
      
      mk_varn xl = varnl ∧ tl = tl' ∧ out_lval_consistent lol dl)
’;



val t_scopes_consistent_def = Define ‘
    t_scopes_consistent T_e (t_scope_list_caller:t_scope_list) (t_scope_list_g: t_scope_list_g) (t_scope_list_called: t_scope_list) =
    ∀ x t lop. ALOOKUP (LAST t_scope_list_called) x = SOME (t, SOME lop) ⇒
                       lval_typ (t_scope_list_g,t_scope_list_caller) T_e lop (t_tau t)
’;







(** definitions *)

(* defns stmtl_typ *)
Inductive stmtl_typ:
(* defn stmtl_typ *)

[stmtl_typ_list:] (! (stmt_list:stmt list) (t_scope_list:t_scope list) (t_scope_list_g:t_scope_list_g) (T_e:T_e) (Prs_n:Prs_n) .
(clause_name "stmtl_typ_list") /\
(( (LENGTH  (t_scope_list)   >= LENGTH  (stmt_list)  ) ) /\
( (  ( (stmt_list) )   <> []) ) /\
( ( type_ith_stmt  t_scope_list_g    ( (t_scope_list) )    T_e   Prs_n    ( (stmt_list) )   ) ))
 ==> 
( ( stmtl_typ  ( t_scope_list_g  ,   ( (t_scope_list) )  )  T_e Prs_n  ( (stmt_list) )  )))
End
(** definitions *)

(* defns frame_typ *)
Inductive frame_typ:
(* defn frame_typ *)

[frame_typ_stmtl:] (! (tau_x_d_list:(tau#x#d) list) (t_scope_list_g:t_scope_list_g) (t_scope_list:t_scope_list) (order:order) (funn:funn) (delta_g:delta_g) (delta_b:delta_b) (delta_x:delta_x) (delta_t:delta_t) (Prs_n:Prs_n) (g_scope_list:g_scope_list) (scope_list:scope_list) (stmt_stack:stmt_stack) (tau:tau) .
(clause_name "frame_typ_stmtl") /\
(( SOME ( (tau_x_d_list) , tau ) = t_lookup_funn  funn   delta_g   delta_b   delta_x ) /\
( sig_tscope_consistent  funn   delta_g   delta_b   delta_x   t_scope_list ) /\
( (args_t_same  ( ((MAP (\(tau_,x_,d_) . tau_) tau_x_d_list)) ) t_scope_list ) ) /\
( (star_not_in_sl  scope_list  ) ) /\
( ( type_frame_tsl  scope_list   t_scope_list  ) ) /\
( ( type_scopes_list  g_scope_list   t_scope_list_g  ) ) /\
( ( stmtl_typ  ( t_scope_list_g  ,  t_scope_list )   (  order  ,  funn  ,   (  delta_g  ,  delta_b  ,  delta_x  ,  delta_t  )   )  Prs_n stmt_stack )) /\
( ( stmt_stack  <> []) ))
 ==> 
( ( frame_typ  ( t_scope_list_g  ,  t_scope_list )   (  order  ,  funn  ,   (  delta_g  ,  delta_b  ,  delta_x  ,  delta_t  )   )  Prs_n g_scope_list scope_list stmt_stack )))
End



(* given a statement, check whether the end statement is a return statement *)

val end_stmt_is_ret_def = Define `
  (end_stmt_is_ret (stmt_ret e) = T ) /\
  (end_stmt_is_ret (stmt_ext) = T ) /\   (*this should be false because if P4 you should not call an ext from a function*)
  (end_stmt_is_ret (stmt_empty) = F ) /\
 (* (end_stmt_is_ret (stmt_verify e e') = F) /\ *)
  (end_stmt_is_ret (stmt_trans e) = F ) /\
  (end_stmt_is_ret (stmt_app x el) = F ) /\
  (end_stmt_is_ret (stmt_cond e stmt1 stmt2) = (end_stmt_is_ret (stmt1) /\ end_stmt_is_ret (stmt2) )) /\ 
  (end_stmt_is_ret (stmt_block dl stmt) = end_stmt_is_ret (stmt)) /\
  (end_stmt_is_ret (stmt_seq stmt1 stmt2) = (end_stmt_is_ret (stmt1) \/ end_stmt_is_ret (stmt2)) ) 
`;


(* given a list of (tau,string,dir) list and a list of lval, return a typing scope *)
    val mk_tscope_def = Define `
    mk_tscope (txdl: (tau#string#d) list) (lol: (lval option) list) =
    ZIP (mk_varn  (MAP (\(t,x,d). x) txdl ) ,  ZIP ( (MAP (\(t,x,d). t) txdl ) , lol) )
`;

(* check if the direction list is the same in both lists *)
  val same_dir_x_def = Define `
    same_dir_x xdl txdl =
   (xdl = MAP SND txdl)
   `;



val t_scopes_to_pass_def = Define `
 t_scopes_to_pass (funn:funn) (delta_g:delta_g) (delta_b:delta_b) (t_scope_list_g:t_scope_list_g) =
  case funn of
   | (funn_name x) =>
    (case ALOOKUP delta_b x of
     | SOME (stmt, x_d_l) => SOME t_scope_list_g
     | NONE =>
      (case ALOOKUP delta_g x of
       | SOME (stmt, x_d_l) => SOME ([ []; EL 1 t_scope_list_g])
       | NONE => SOME t_scope_list_g
      )
    )
   | _ => SOME ([ []; EL 1 t_scope_list_g])
`;



 val not_parseError_str =  Define `
not_parseError_str xdl =
   EVERY (\(x,d). x ≠ "parseError") xdl
`;


(* should we simplify it? we already know t_scopes_to_pass should always the second part? *)
(*based on the specs, the extern cannot be called from functions *)
(* lol is lval option list *)
val func_map_typed_def = Define `
func_map_typed (func_map:func_map) order (t_scope_list_g:t_scope_list_g) delta_g delta_b delta_x Prs_n =
! f stmt xdl x lol .
 ( (f = funn_name x) /\
   (ALOOKUP func_map x = SOME (stmt, xdl)) )
   ==>

   ? tau txdl (t_scope':t_scope) t_scope_list_g'. 
   (SOME (txdl,tau) = t_lookup_funn f delta_g [] [] /\ 
     find_star_in_globals t_scope_list_g (varn_star f) = SOME tau /\
   (same_dir_x xdl txdl) /\
   (* not_parseError_str xdl /\ *)
   (t_scopes_to_pass f delta_g delta_b t_scope_list_g = SOME t_scope_list_g') /\
   (t_scope' = mk_tscope txdl lol) /\
   ( stmt_typ ( t_scope_list_g'  ,  [t_scope'] ) (  order, f , (delta_g,[],delta_x,[])) Prs_n (stmt) ) /\
   ( ALL_DISTINCT (MAP FST xdl) ) /\
   ( end_stmt_is_ret stmt))
`;





val func_map_blk_typed_def = Define `
func_map_blk_typed (b_func_map:b_func_map) order t_scope_list_g delta_g delta_b delta_x delta_t Prs_n =
! f stmt xdl x lol.
 ( (f = funn_name x) /\
   (ALOOKUP b_func_map x = SOME (stmt, xdl))
) ==>

   ? tau txdl (t_scope':t_scope) t_scope_list_g'.
   (SOME (txdl,tau) = t_lookup_funn f [] delta_b [] ) /\
   find_star_in_globals t_scope_list_g (varn_star f) = SOME tau /\
   (same_dir_x xdl txdl) /\
  (* not_parseError_str xdl /\ *)
   (t_scopes_to_pass f delta_g delta_b t_scope_list_g = SOME t_scope_list_g') /\
   (t_scope' = mk_tscope txdl lol ) /\
   ( stmt_typ ( t_scope_list_g'  ,  [t_scope'] ) (  order, f , (delta_g,delta_b,delta_x,delta_t)) Prs_n (stmt) ) /\
   ( ALL_DISTINCT (MAP FST xdl) ) /\
   ( end_stmt_is_ret stmt)

`;



(* a definition to check that the lval op is always NONE 
   and also the varn names are still the same, this we get from similarl definition *)
val ext_sc_same_as_input_def = Define `
ext_sc_same_as_input (scopest: scope_list) (scopest_out : scope_list) =
similarl (\ si so . (SND si = SND so)) scopest scopest_out `;




(*note the statement here can only be the black box*)

(* t_scope' is unused, remove it*)
val extern_map_IoE_typed_def = Define `
extern_map_IoE_typed (ext_map: 'a ext_map) t_scope_list_g delta_g delta_b delta_x  =

! f (xdl : (string # d) list) x IoE MoE.
         f = funn_inst x /\
	 ALOOKUP ext_map x = SOME (SOME (xdl,IoE),MoE) ==>

   ! (a:'a) (g_scope_list:g_scope_list) local_scopes lol.

   ? txdl tau (t_scope':t_scope) (a':'a)  scope_list' status t_scope_list_g'.

   SOME (txdl,tau) = t_lookup_funn f [] [] delta_x /\
   find_star_in_globals t_scope_list_g (varn_star f) = SOME tau /\
   (same_dir_x xdl txdl) /\
   (* not_parseError_str xdl /\ *)
   ( ALL_DISTINCT (MAP FST xdl) ) /\
   (t_scopes_to_pass f delta_g delta_b t_scope_list_g = SOME t_scope_list_g') /\
   (t_scope' = mk_tscope txdl lol ) /\

	 SOME (a',scope_list', status) = IoE (a,g_scope_list, local_scopes ) /\

	 ( ! v . status = status_returnv v ==> v_typ v (t_tau tau) F ) /\

   star_not_in_sl (scope_list') /\
   (! t_scopel''. (type_scopes_list local_scopes t_scopel'') ==> (type_scopes_list scope_list' t_scopel''))
`;


val extern_MoE_typed_def = Define `
extern_MoE_typed (ext_map: 'a ext_map) t_scope_list_g delta_g delta_b delta_x  =

! f xdl x x' IoEsig MoE MoE_map  .
         f = funn_ext x x' /\
	 ALOOKUP ext_map x = SOME (IoEsig, MoE) /\
	 ALOOKUP MoE x'    = SOME (xdl, MoE_map) ==>
  
  !  (a:'a) (g_scope_list:g_scope_list) local_scopes lol.

  ? txdl tau t_scope'  (a':'a)  (scope_list': scope list) (status) t_scope_list_g' .

   SOME (txdl,tau) = t_lookup_funn f [] [] delta_x /\
   find_star_in_globals t_scope_list_g (varn_star f) = SOME tau /\
   (same_dir_x xdl txdl) /\
  (*  not_parseError_str xdl /\ *)
   (t_scopes_to_pass f delta_g delta_b t_scope_list_g = SOME t_scope_list_g') /\
   (t_scope' = mk_tscope txdl lol) /\ 
   ( ALL_DISTINCT (MAP FST xdl) ) /\

	 (SOME (a',scope_list', status) = MoE_map (a,g_scope_list, local_scopes  )) /\
	 ( ! v .status = status_returnv v ==> v_typ v (t_tau tau) F ) /\
   star_not_in_sl (scope_list') /\
   (! t_scopel''. (type_scopes_list local_scopes t_scopel'') ==> (type_scopes_list scope_list' t_scopel''))
`;



(************************************)
(* f from table call is well typed **)
(************************************)


(* f'  : default action 
   el' : keys to match with 
   f   : is the action to accply 
   vl  : is action data   
   the action can never be an extern *)




val is_directionless_def = Define `
is_directionless dl =  EVERY (\d. d = d_none) dl
`;


(* el is the key list, f' is default action, el' default action's data/args
Here we mean that the function/action being called from the table can be in either global or local  *)
val table_map_typed_def = Define `
table_map_typed (tbl_map: tbl_map) (apply_table_f: 'a apply_table_f) delta_g delta_b order =

!  s mkl f' f el' el vl ascope  .
    ALOOKUP tbl_map s = SOME (mkl,f',el') /\
    apply_table_f (s,el,mkl, (f',el'),ascope) = SOME (f,vl) ==>
     ? txdl .
       LENGTH mkl = LENGTH el /\
       SOME (txdl,tau_bot) = t_lookup_funn (funn_name f) delta_g delta_b [] /\
       is_consts vl /\
       is_directionless (MAP (\(t,x,d).d) txdl) /\
       LENGTH txdl = LENGTH vl /\
       (! i . i < LENGTH txdl ==>
              v_typ (EL i ( vl_of_el vl)) (t_tau (EL i (MAP (\(t,x,d).t) txdl))) F) /\
       order ( order_elem_f (funn_name f)) (order_elem_t s )        
`;            

(*****************)
(*  domain       *)
(*****************)
(* takes two lists and checks if the current contents of the domains are different*)



(* use this definition whereever the equivelent holds *)
val is_lookup_defined_def = Define `
    is_lookup_defined l1 x =
     ? y . ALOOKUP l1 x = SOME y 
`;


(* NOTE: this will be used for functions maps and the types of the functions *)
val dom_eq_def = Define `
dom_eq l1 l2 =
! f . ((is_lookup_defined l1 f) <=> (is_lookup_defined l2 f)) 
`;


(* domain empty intersection, given two assosiative lists, the domains should not intersect 
   with eachother *)
val dom_empty_intersection_def = Define `
dom_empty_intersection l1 l2 =
! f . (ALOOKUP l1 f = NONE \/ ALOOKUP l2 f = NONE)
`;


(* functions map empty intersection *)
val dom_map_ei_def = Define `
dom_map_ei (func_map:func_map) (b_func_map:b_func_map) =
  dom_empty_intersection func_map b_func_map
`;


(* domain of the typing function map *)
val dom_tmap_ei_def = Define `
dom_tmap_ei (delta_g:delta_g) (delta_b:delta_b) =
  dom_empty_intersection delta_g delta_b
`;


val typying_domains_ei_def = Define `
typying_domains_ei (delta_g:delta_g) (delta_b:delta_b) (delta_x:delta_x) =
  (dom_empty_intersection delta_g delta_x /\
  dom_empty_intersection delta_b delta_x /\
  dom_empty_intersection delta_g delta_b)
`;


val dom_g_eq_def = Define `
dom_g_eq (delta_g:delta_g) (func_map:func_map) =
  dom_eq delta_g func_map
`;



val dom_b_eq_def = Define `
dom_b_eq (delta_b:delta_b) (b_func_map:b_func_map) =
  dom_eq delta_b b_func_map
`;

val dom_t_eq_def = Define `
dom_t_eq (delta_t:delta_t) (tbl_map:tbl_map) =
  dom_eq delta_t tbl_map
`;


val dom_x_eq_def = Define `
dom_x_eq (delta_x:delta_x) (ext_map: 'a ext_map) =
! f .
	 (dom_eq delta_x ext_map) /\  
   (! a1 a2 ext_fun_map ext_MoE.
	       ( ALOOKUP delta_x f = SOME (a1,ext_MoE) /\
          ALOOKUP ext_map f = SOME (a2,ext_fun_map) ) ==>

	         IS_SOME(a1)= IS_SOME(a2) /\
          (dom_eq ext_MoE ext_fun_map)
	 )
`;








val f_in_apply_tbl_def = Define ‘
     f_in_apply_tbl (tbl_map:tbl_map) (apply_table_f: 'a apply_table_f) =
∀ s mk x el key_list ascope.
ALOOKUP tbl_map s = SOME (mk, x ,el) ⇒
 ∃ f vl .   apply_table_f (s,key_list,mk,(x,el),ascope) = SOME (f,vl)    
    ’;



(* represents 
!f ∈ domain( Fg ). var(star,f) ∈ domain(gsl_t[1])
*)

val Fg_star_defined_def = Define `
Fg_star_defined (func_map:func_map) (t_scope_list_g:t_scope_list_g) =
! x . (is_lookup_defined func_map x)
             <=>
      (is_lookup_defined (EL 1 t_scope_list_g) (varn_star (funn_name x)))
`;


val Fb_star_defined_def = Define `
Fb_star_defined (b_func_map:b_func_map) (t_scope_list_g:t_scope_list_g) =
! x . (is_lookup_defined b_func_map x)
             <=>
      (is_lookup_defined (EL 0 t_scope_list_g) (varn_star (funn_name x)))
`;



val X_star_defined_def = Define `
X_star_defined (ext_map: 'a ext_map) (t_scope_list_g:t_scope_list_g) =
! f x x' . (f = funn_inst x \/ f = funn_ext x x') ==> (
           (is_lookup_defined ext_map x)
             <=>
            (is_lookup_defined (EL 1 t_scope_list_g) (varn_star f)))
`;




val X_star_not_defined_def = Define `
X_star_not_defined (t_scope_list_g:t_scope_list_g) =
! f x x' . (f = funn_inst x \/ f = funn_ext x x') ==> (
            ~ (is_lookup_defined (EL 0 t_scope_list_g) (varn_star f)))
`;


(** definitions *)

(* defns WTFg *)
Inductive WTFg:
(* defn WTFg *)

[WTFg_global:] (! (func_map:func_map) (order:order) (t_scope_list_g:t_scope_list_g) (delta_g:delta_g) (delta_b:delta_b) (delta_x:delta_x) (Prs_n:Prs_n) .
(clause_name "WTFg_global") /\
(( ( func_map_typed  func_map   order   t_scope_list_g   delta_g   delta_b   delta_x   Prs_n  ) ))
 ==> 
( ( WTFg func_map order t_scope_list_g delta_g delta_b delta_x Prs_n )))
End
(** definitions *)

(* defns WTFb *)
Inductive WTFb:
(* defn WTFb *)

[WTFb_block:] (! (b_func_map:b_func_map) (order:order) (t_scope_list_g:t_scope_list_g) (delta_g:delta_g) (delta_b:delta_b) (delta_x:delta_x) (delta_t:delta_t) (Prs_n:Prs_n) .
(clause_name "WTFb_block") /\
(( ( func_map_blk_typed  b_func_map   order   t_scope_list_g   delta_g   delta_b   delta_x   delta_t   Prs_n  ) ))
 ==> 
( ( WTFb b_func_map order t_scope_list_g delta_g delta_b delta_x delta_t Prs_n )))
End
(** definitions *)

(* defns WTX *)
Inductive WTX:
(* defn WTX *)

[WTX_ext:] (! (ext_map:'a ext_map) (order:order) (t_scope_list_g:t_scope_list_g) (delta_g:delta_g) (delta_b:delta_b) (delta_x:delta_x) .
(clause_name "WTX_ext") /\
(( ( extern_map_IoE_typed  ext_map   t_scope_list_g   delta_g   delta_b   delta_x  ) ) /\
( extern_MoE_typed  ext_map   t_scope_list_g   delta_g   delta_b   delta_x ))
 ==> 
( ( WTX ext_map order t_scope_list_g delta_g delta_b delta_x )))
End
(** definitions *)

(* defns WT_c *)
Inductive WT_c:
(* defn WT_c *)

[WT_c_c:] (! (apply_table_f:'a apply_table_f) (ext_map:'a ext_map) (func_map:func_map) (b_func_map:b_func_map) (pars_map:pars_map) (tbl_map:tbl_map) (order:order) (t_scope_list_g:t_scope_list_g) (delta_g:delta_g) (delta_b:delta_b) (delta_x:delta_x) (delta_t:delta_t) (Prs_n:Prs_n) .
(clause_name "WT_c_c") /\
(( ( WF_o  order  ) ) /\
( ( 2 = LENGTH  t_scope_list_g  ) ) /\
( (LENGTH  delta_b  = LENGTH  b_func_map  ) ) /\
( (LENGTH  delta_t  = LENGTH  tbl_map  ) ) /\
( ( dom_map_ei  func_map   b_func_map  ) ) /\
( ( dom_tmap_ei  delta_g   delta_b  ) ) /\
( ( typying_domains_ei  delta_g   delta_b   delta_x  ) ) /\
( ( dom_g_eq  delta_g   func_map  ) ) /\
( ( dom_b_eq  delta_b   b_func_map  ) ) /\
( ( dom_x_eq  delta_x   ext_map  ) ) /\
( ( dom_t_eq  delta_t   tbl_map  ) ) /\
( ( Fg_star_defined  func_map   t_scope_list_g  ) ) /\
( ( Fb_star_defined  b_func_map    t_scope_list_g  ) ) /\
( ( X_star_defined  ext_map    t_scope_list_g  ) ) /\
( (X_star_not_defined  t_scope_list_g ) ) /\
( ( WTFg func_map order t_scope_list_g delta_g delta_b delta_x Prs_n )) /\
( ( WTFb b_func_map order t_scope_list_g delta_g delta_b delta_x delta_t Prs_n )) /\
( ( WTX ext_map order t_scope_list_g delta_g delta_b delta_x )) /\
( ( table_map_typed  tbl_map   apply_table_f   delta_g   delta_b   order  ) ) /\
( ( f_in_apply_tbl  tbl_map   apply_table_f  ) ))
 ==> 
( ( WT_c  ( apply_table_f ,  ext_map ,  func_map ,  b_func_map  ,  pars_map ,  tbl_map )  order t_scope_list_g delta_g delta_b delta_x delta_t Prs_n )))
End



val t_map_to_pass_def = Define `
 t_map_to_pass (funn:funn) (delta_b:delta_b) =
  case funn of
   | (funn_name x) =>
    (case ALOOKUP delta_b x of
     | SOME (txdl,t) => SOME delta_b
     | NONE => SOME []
    )
   | _ => SOME []
`;

val t_tbl_to_pass_def = Define `
 t_tbl_to_pass (funn:funn) (delta_b:delta_b) (delta_t:delta_t) =
  case funn of
   | (funn_name x) =>
    (case ALOOKUP delta_b x of
     | SOME (txdl,t) => SOME delta_t
     | NONE => SOME []
    )
   | _ => SOME []
`;



       



val type_frames_def = Define `
type_frames (g_scope_list:g_scope_list) (frames_list:frame_list) (Prs_n:Prs_n)
(order:order) (t_scope_list_g:t_scope_list_g)  (t_scopes_frames:t_scopes_frames)  (delta_g:delta_g) (delta_b:delta_b) (delta_x:delta_x) (delta_t:delta_t) 
func_map b_func_map =

∀ i funnl stml scl .
     
    (funnl = MAP (λ(f,stml,scl). f) frames_list ∧
     stml = MAP (λ(f,stml,scl). stml) frames_list ∧
     scl = MAP (λ(f,stml,scl). scl) frames_list) ⇒
   
    (i < LENGTH frames_list ==>
       ∃ passed_tslg passed_delta_b passed_delta_t passed_gscope. 
          t_scopes_to_pass (EL i funnl) delta_g delta_b t_scope_list_g = SOME passed_tslg ∧
          t_map_to_pass (EL i funnl) delta_b =  SOME passed_delta_b ∧ 
          t_tbl_to_pass (EL i funnl) delta_b delta_t = SOME passed_delta_t /\
          scopes_to_pass (EL i funnl) func_map b_func_map g_scope_list = SOME passed_gscope /\
          frame_typ (passed_tslg,EL i t_scopes_frames) (order,EL i funnl,delta_g,passed_delta_b,delta_x,passed_delta_t) Prs_n passed_gscope (EL i scl) (EL i stml))     
`;





val f_decl_in_def = Define
‘f_decl_in (funn_name x) l =
 ∃ sig . ALOOKUP l x = SOME sig ’;
   

val t_decl_in_def = Define
‘t_decl_in t l =
  ∃ sig . ALOOKUP l t = SOME sig’;
    

val IoE_decl_in_def = Define ` 
  IoE_decl_in (funn_inst x) l =
    ∃ sig . ALOOKUP l x = SOME sig
`;

val MoE_decl_in_def = Define ` 
  MoE_decl_in (funn_ext x x') l =
    ( ∃ ext_MoE sig a1. ALOOKUP l x = SOME (a1, ext_MoE) ∧ ALOOKUP ext_MoE x' = SOME sig ) 
`;


val deltas_order_def = Define
 ` deltas_order (delta_g:delta_g) (delta_b:delta_b) (delta_x:delta_x) (order:order) =

    (* order of ext and global functions : ext defined before global *)

((∀s s'.   IoE_decl_in (funn_inst s) delta_x ∧ f_decl_in (funn_name s') delta_g ⇒
          order (order_elem_f (funn_inst s)) (order_elem_f (funn_name s'))) ∧
          
(∀s s' s''. MoE_decl_in (funn_ext s s') delta_x ∧ f_decl_in (funn_name s'') delta_g ⇒
            order (order_elem_f (funn_ext s s')) (order_elem_f (funn_name s''))) ∧


    (* order of global and local functions : global defined before local *)           

(∀s s'.   f_decl_in (funn_name s) delta_g ∧ f_decl_in (funn_name s') delta_b ⇒
          order (order_elem_f (funn_name s)) (order_elem_f (funn_name s'))))
 `;


(** definitions *)

(* defns WF_ft_order *)
Inductive WF_ft_order:
(* defn WF_ft_order *)

[WF_ft_order_ft:] (! (funn_list:funn list) (funn_list:funn_list) (delta_g:delta_g) (delta_b:delta_b) (delta_x:delta_x) (order:order) .
(clause_name "WF_ft_order_ft") /\
(( (ordered_list  order  ( MAP (\f. order_elem_f f )  (funn_list) )  ) ) /\
( (deltas_order  delta_g   delta_b   delta_x   order  ) ))
 ==> 
( ( WF_ft_order funn_list delta_g delta_b delta_x order )))
End
(** definitions *)

(* defns WT_state *)
Inductive WT_state:
(* defn WT_state *)

[WT_state_state:] (! (funn_stmt_stack_scope_list_t_scope_list_list:(funn#stmt_stack#scope_list#t_scope_list) list) (apply_table_f:'a apply_table_f) (ext_map:'a ext_map) (func_map:func_map) (b_func_map:b_func_map) (pars_map:pars_map) (tbl_map:tbl_map) (ascope:'a) (g_scope_list:g_scope_list) (status:status) (Prs_n:Prs_n) (order:order) (t_scope_list_g:t_scope_list_g) (delta_g:delta_g) (delta_b:delta_b) (delta_x:delta_x) (delta_t:delta_t) (ctx:'a ctx) .
(clause_name "WT_state_state") /\
(( ( WF_ft_order (funn_list_fl ((MAP (\(funn_,stmt_stack_,scope_list_,t_scope_list_) . funn_) funn_stmt_stack_scope_list_t_scope_list_list))) delta_g delta_b delta_x order )) /\
( ( type_state_tsll  ((MAP (\(funn_,stmt_stack_,scope_list_,t_scope_list_) . scope_list_) funn_stmt_stack_scope_list_t_scope_list_list))   ((MAP (\(funn_,stmt_stack_,scope_list_,t_scope_list_) . t_scope_list_) funn_stmt_stack_scope_list_t_scope_list_list))  ) ) /\
( ( type_scopes_list  g_scope_list   t_scope_list_g  ) ) /\
( ( WT_c ctx order t_scope_list_g delta_g delta_b delta_x delta_t Prs_n )) /\
( ( type_frames  g_scope_list    ( ((MAP (\(funn_,stmt_stack_,scope_list_,t_scope_list_) . (funn_,stmt_stack_,scope_list_)) funn_stmt_stack_scope_list_t_scope_list_list)) )    Prs_n   order   t_scope_list_g   ((MAP (\(funn_,stmt_stack_,scope_list_,t_scope_list_) . t_scope_list_) funn_stmt_stack_scope_list_t_scope_list_list))   delta_g   delta_b   delta_x   delta_t   func_map   b_func_map  ) ))
 ==> 
( ( WT_state  ( apply_table_f ,  ext_map ,  func_map ,  b_func_map  ,  pars_map ,  tbl_map )   ( ascope ,  g_scope_list ,   ( ((MAP (\(funn_,stmt_stack_,scope_list_,t_scope_list_) . (funn_,stmt_stack_,scope_list_)) funn_stmt_stack_scope_list_t_scope_list_list)) )  ,  status )  Prs_n order t_scope_list_g  ( ((MAP (\(funn_,stmt_stack_,scope_list_,t_scope_list_) . t_scope_list_) funn_stmt_stack_scope_list_t_scope_list_list)) )   (  delta_g  ,  delta_b  ,  delta_x  ,  delta_t  )  )))
End

val _ = export_theory ();




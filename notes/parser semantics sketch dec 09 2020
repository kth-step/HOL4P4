This is a sketch of an axiomatic semantics for a fragment of the P4 parser. 

P4 State s is:
	 ID of current parser state 'c (in 'C) 
	 values of input and output (i, o) (in Ti * To, where Ti is a finite list of V and To is a function from fields F to lists of V)
	 Index of the current statement: n (in N)
	 Status: 'd (in Running, TypeError, Reject 'err, ...)


 [exp](in, out, status) -> bool

 _________________ :: exp_red_1
 [I == O.f](in, out, status) = (i = o.f)


 [stm](in, out, status) -> (in',out',status')

 size(f1) = sz
 in = [v1, ..., vsz, vsz+1, ..., vn]
 in' = [vsz+1, ..., vn]
 out'.f1 = [v1, ..., vsz]
 _________________ :: stm_red_1
 [extract f1](in, out, status) = (in', out', status)


 size(f1) = sz
 in = [v1, ..., vn]
 vn < sz
 _________________ :: stm_red_2
 [extract f1](in, out, status) = (in, out, TypeError)

 P ; s -> s'

 'd = Running
 P(s.n, s.c) = verify(p, err)
 [p]s.(i,o)
 s'.n = s.n + 1
 ____________________
 P ; s -> s'


 'd = Running
 P(s.n, s.c) = verify(p, err)
 ~[p]s.(i,o)
 s'.'d = Reject(err)
 ____________________
 P ; s -> s'


 'd = Running
 P(s.n, s.c) = extract f1
 [extract f1](i, o) = (i', o')
 s'.(i, o) = (i', o')
 s'.n = s.n + 1
 ____________________
 P ; s -> s'


 'd = Running
 P(s.n, s.c) = extract(f1)
 [f1](i, o) = TypeError
 s'.d = TypeError
 ____________________
 P ; s -> s'


 'd = Running
 P(s.n, s.c) = transition c'
 s'.c = c'
 s'.n = 0
 ____________________
 P ; s -> s'

 'd = Running
 size(P(s.c)) <= s.n
 s'.'d = JumpOutside
 ____________________
 P ; s -> s'


